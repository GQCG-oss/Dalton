head	1.1;
access;
symbols;
locks
	hjj:1.1; strict;
comment	@c @;


1.1
date	2018.02.18.07.08.51;	author hjj;	state Exp;
branches;
next	;


desc
@@


1.1
log
@OLD files before fixing open shell
@
text
@C****************************************************************************
      SUBROUTINE DESR(ESR,rho,grd,mu,norder,
     >                d1Edrho,d1Edgrd,d1Edgrda2,
     >                d2Edrhodrho,d2Edgrddgrd,d2Edrhodgrd)
C*****************************************************************************
C     Compute first-order and/or second-order numerical derivatives 
C     of a generic short-range functional ESR(rho,grd,mu,E)
C
C     Input: ESR    : functional routine
C            rho    : density
C            grd    : norm of gradient of density
C            mu     : Interation parameter
C            norder : order of derivatives
C
C     Ouput: d1Edrho       : first derivative wrt to rho
C            d1Edgrd       : first derivative wrt to grd  (for 2nd-order optimisation)
C            d1Edgrda2     : first derivative wrt to grda2 (for HF optimisation)
C            (grda2 is the square of gradient of spin-alpha density)
C            d2Edrhodrho   : second derivative wrt to rho and rho
C            d2Edgrddgrd   : second derivative wrt to grd and grd
C            d2Edrhodgrd   : second derivative wrt to rho and grd
C
C     Author: J. Toulouse
C     Date  : 16-02-05
C*****************************************************************************
      implicit none

      external ESR
      integer norder
      double precision rho, grd, mu
      double precision E, d1Edrho,d1Edgrd,d1Edgrda2
      double precision d2Edrhodrho,d2Edgrddgrd,d2Edrhodgrd

      double precision hr, hg, hr2, hg2, hrg
      double precision rhom, rhop, rhopp, grdm, grdp, grdpp

      double precision Em0, Ep0, Epp0
      double precision E0m, E0p, E0pp
      double precision Emm, Epp, Epm, Emp
      double precision d1Edgrd2, dsdgrd, dgrddgrd2

C     check
      if(norder .le. 0 .or. norder .ge. 3) then
       print *,'DESR: norder=',norder
       call quit('DESR: norder must be 1 or 2')
      endif

C     energy
      call ESR(rho,grd,mu,E)
!      print *,'D1SR: E=',E

C     (optimal?) numerical step
      hr = 1.d-4*rho
      hg = 1.d-4*grd

C     variations of variables
      rhom = rho-hr
      rhop = rho+hr
      grdm = grd-hg
      grdp = grd+hg

C First-order derivatives --------------------------------------------

C     derivative wrt rho ---------------------
!      if(rhom .ge. 0.d0) then 
!      central 2nd-order approximation
       call ESR(rhom,grd,mu,Em0)
       call ESR(rhop,grd,mu,Ep0)
       d1Edrho = (Ep0 - Em0)/(2.d0*hr)
!      else 
!       stop 'rhom < 0'
!!      forward 1st-order approximation
!       call ESR(rhop,grd,mu,Ep0)
!       d1Edrho = (Ep0 - E)/hr
!      endif
!      print *,'D1SR: d1Edrho=',d1Edrho

C     derivative wrt grd ---------------------
!      if(grdm .ge. 0.d0) then
!      central 2nd-order approximation
       call ESR(rho,grdm,mu,E0m)
       call ESR(rho,grdp,mu,E0p)
       d1Edgrd = (E0p - E0m)/(2.d0*hg)
!      else
!       stop 'grdm < 0'
!!      forward 1st-order approximation
!       call ESR(rho,grdp,mu,E0p)
!       d1Edgrd = (E0p - E)/hg
!      endif
!      print *,'D1SR: d1Edgrd=',d1Edgrd

C     derivative wrt grd2
      dgrddgrd2 = 1.d0/(2.d0*grd)
      d1Edgrd2 = d1Edgrd * dgrddgrd2

C     derivative wrt grda2
      d1Edgrda2 = 4.d0*d1Edgrd2

C Second-order derivatives --------------------------------------------
      if(norder .ge. 2) then

      hr2= hr*hr
      hg2= hg*hg
      hrg= hr*hg

C     derivative wrt rho and rho -----------------
!      if(rhom .ge. 0.d0) then 
!      central 2nd-order approximation
       d2Edrhodrho = (Ep0 - 2.d0*E + Em0)/hr2
!      else 
!       stop 'rhom < 0'
!!      forward 1st-order approximation
!       rhopp = rho + 2.d0*hr
!       call ESR(rhop,grd,mu,Ep0)
!       call ESR(rhopp,grd,mu,Epp0)
!       d2Edrhodrho = (Epp0 -2.d0*Ep0 + E)/hr2
!      endif

C     derivative wrt grd and grd -----------------------
!      if(grdm .ge. 0.d0) then
!      central 2nd-order approximation
       d2Edgrddgrd = (E0p - 2.d0*E + E0m)/hg2
!      else
!       stop 'grdm < 0'
!!      forward 1st-order approximation
!       grdpp = grd + 2.d0*hg
!       call ESR(rho,grdp,mu,E0p)
!       call ESR(rho,grd,mu,E0pp)
!       d2Edgrddgrd = (E0pp -2.d0*E0p + E)/hg2
!      endif

C     derivative wrt rho and grd -----------------------
!      if(rhom.ge. 0.d0 .and. grdm .ge. 0.d0) then
       call ESR(rhop,grdp,mu,Epp)
       call ESR(rhom,grdp,mu,Emp)
       call ESR(rhop,grdm,mu,Epm)
       call ESR(rhom,grdm,mu,Emm)
!      central 2nd-order approximation
       d2Edrhodgrd = (Epp - Emp - Epm + Emm)/(4.d0*hrg)
!      else
!       stop 'rhom < 0 or grdm < 0'
!       call ESR(rhop,grdp,mu,Epp)
!!      forward 1st-order approximation
!       d2Edrhodgrd = (Epp - E0p - Ep0 + E)/hrg
!      endif
     
      endif

      return
      end
C****************************************************************************
      SUBROUTINE DELA(ESR,rhot,grd,VLAMBDA,norder,
     >                d1Edrho,d1Edgrd,d1Edgrda2,
     >                d2Edrhodrho,d2Edgrddgrd,d2Edrhodgrd)

C Linear complement exchange PBE functional, Kamal SHARKAS 20/05/2011
C*****************************************************************************

      implicit none

      external ESR
      integer norder

      double precision rhot, grd, VLAMBDA
      double precision d1Edrho,d1Edgrd,d1Edgrda2
      double precision d2Edrhodrho, d2Edgrddgrd, d2Edrhodgrd

      call   DESR(ESR,rhot,grd,0.d0,norder,
     >            d1Edrho,d1Edgrd,d1Edgrda2,
     >            d2Edrhodrho,d2Edgrddgrd,d2Edrhodgrd)


      d1Edrho = (1.d0- VLAMBDA) * d1Edrho

      d1Edgrd = (1.d0- VLAMBDA) * d1Edgrd

      d1Edgrda2 = (1.d0- VLAMBDA) * d1Edgrda2

      d2Edrhodrho = (1.d0- VLAMBDA) * d2Edrhodrho

      d2Edgrddgrd =  (1.d0- VLAMBDA) * d2Edgrddgrd

      d2Edrhodgrd = (1.d0- VLAMBDA) * d2Edrhodgrd

          return
           end

C****************************************************************************
      SUBROUTINE DELANSC(ESR,rhot,grd,VLAMBDA,norder,
     >                d1Edrho,d1Edgrd,d1Edgrda2,
     >                d2Edrhodrho,d2Edgrddgrd,d2Edrhodgrd)

C Linear complement (NON-Scaled) correlation PBE GWS functional, Kamal SHARKAS 20/05/2011
C*****************************************************************************
      implicit none

      external ESR
      integer norder

      double precision rhot, grd, VLAMBDA
      double precision d1Edrho,d1Edgrd,d1Edgrda2
      double precision d2Edrhodrho, d2Edgrddgrd, d2Edrhodgrd

      call   DESR(ESR,rhot,grd,0.d0,norder,
     >            d1Edrho,d1Edgrd,d1Edgrda2,
     >            d2Edrhodrho,d2Edgrddgrd,d2Edrhodgrd)


      d1Edrho = (1.d0- VLAMBDA**2) * d1Edrho

      d1Edgrd = (1.d0- VLAMBDA**2) * d1Edgrd

      d1Edgrda2 = (1.d0- VLAMBDA**2) * d1Edgrda2

      d2Edrhodrho = (1.d0- VLAMBDA**2) * d2Edrhodrho

      d2Edgrddgrd =  (1.d0- VLAMBDA**2) * d2Edgrddgrd

      d2Edrhodgrd = (1.d0- VLAMBDA**2) * d2Edrhodgrd

          return
           end

C****************************************************************************
      SUBROUTINE DELASC(ESR,rhot,grd,VLAMBDA,norder,
     >                d1Edrho,d1Edgrd,d1Edgrda2,
     >                d2Edrhodrho,d2Edgrddgrd,d2Edrhodgrd)

C Linear complement Scaled correlation PBE functional, Kamal SHARKAS 20/05/2011
C*****************************************************************************
      implicit none

      external ESR
      integer norder

      double precision rhot, rhotscaled, grd, grdscaled, VLAMBDA
      double precision d1Edrho,d1Edgrd,d1Edgrda2
      double precision d2Edrhodrho, d2Edgrddgrd, d2Edrhodgrd
      double precision d1Edrhocoul,d1Edgrdcoul,d1Edgrda2coul
      double precision d2Edrhodrhocoul, d2Edgrddgrdcoul, d2Edrhodgrdcoul
      double precision d1Edrhosca,d1Edgrdsca,d1Edgrda2sca
      double precision d2Edrhodrhosca, d2Edgrddgrdsca, d2Edrhodgrdsca

      d1Edrhocoul = 0.d0
      d1Edgrdcoul = 0.d0
      d1Edgrda2coul = 0.d0
      d2Edrhodrhocoul = 0.d0
      d2Edgrddgrdcoul = 0.d0
      d2Edrhodgrdcoul =  0.d0

      call  DESR(ESR,rhot,grd,0.d0,norder,
     >           d1Edrhocoul,d1Edgrdcoul,d1Edgrda2coul,
     >           d2Edrhodrhocoul,d2Edgrddgrdcoul,d2Edrhodgrdcoul)

      rhotscaled = rhot/VLAMBDA**3
      grdscaled  = grd/VLAMBDA**4

      d1Edrhosca = 0.d0
      d1Edgrdsca = 0.d0
      d1Edgrda2sca = 0.d0
      d2Edrhodrhosca = 0.d0
      d2Edgrddgrdsca = 0.d0
      d2Edrhodgrdsca =  0.d0

      call  DESR(ESR,rhotscaled,grdscaled,0.d0,norder,
     >           d1Edrhosca,d1Edgrdsca,d1Edgrda2sca,
     >           d2Edrhodrhosca,d2Edgrddgrdsca,d2Edrhodgrdsca)


      d1Edrho = d1Edrho + (d1Edrhocoul - VLAMBDA**2 * d1Edrhosca)

      d1Edgrd = d1Edgrd + (d1Edgrdcoul - VLAMBDA * d1Edgrdsca)

      d1Edgrda2 = d1Edgrda2+(d1Edgrda2coul-(d1Edgrda2sca/VLAMBDA**3))

      d2Edrhodrho= d2Edrhodrho + (d2Edrhodrhocoul -
     >                 (1.d0/VLAMBDA)*d2Edrhodrhosca)

      d2Edgrddgrd = d2Edgrddgrd + (d2Edgrddgrdcoul-
     >                   (d2Edgrddgrdsca/VLAMBDA**3))

      d2Edrhodgrd = d2Edrhodgrd + (d2Edrhodgrdcoul-
     >                   (d2Edrhodgrdsca/VLAMBDA**2))


          return
           end
C****************************************************************************

C****************************************************************************
      SUBROUTINE DESRSPIN(ESRSPIN,rhot,rhos,mu,dospin,norder,
     >                d1Edrhot,d1Edrhos,
     >                d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos)
C*****************************************************************************
C     Compute first-order and/or second-order numerical derivatives 
C     of a generic spin-dependent short-range LDA functional ESRSPIN(rhot,rhos,mu,dospin,E)
C
C     Input: ESRSPIN    : functional routine
C            rhot   : total density
C            rhos   : spin density
C            dospin : use spin density
C            mu     : Interation parameter
C            norder : order of derivatives
C
C     Ouput: d1Edrhot      : first derivative wrt to rhot
C            d1Edrhos      : first derivative wrt to rhos
C            d2Edrhotdrhot : second derivative wrt to rhot and rhot
C            d2Edrhotdrhos : second derivative wrt to rhot and rhos
C            d2Edrhosdrhos : second derivative wrt to rhos and rhos
C
C     Created: 17-08-09, J. Toulouse
C*****************************************************************************
      implicit none

      external ESRSPIN
      integer norder
      logical dospin
      double precision rhot, rhos, mu
      double precision E, d1Edrhot, d1Edrhos
      double precision d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos

      double precision hrt, hrs, hrt2, hrs2, hrts
      double precision rhotm, rhotp, rhosp, rhosm
      double precision arhos

      double precision Em0, Ep0, Epp0
      double precision E0m, E0p, E0pp
      double precision Emm, Epp, Epm, Emp

      logical  pure_spin

C     check
      if(norder .le. 0 .or. norder .ge. 3) then
       print *,'DESRSPIN: norder=',norder
       call quit('DESRSPIN: norder must be 1 or 2')
      endif

      arhos = abs(rhos)
      if (arhos .gt. rhot) then
         call quit('DESRSPIN error: |rhos| > rhot')
      end if
      pure_spin = (rhot - arhos .le. 1.d-14 ) ! pure alpha or pure beta

C     energy
      call ESRSPIN(rhot,rhos,mu,dospin,E)
!      print *,'D1SRSPIN: E=',E

C     (optimal?) numerical step
      hrt = 1.d-4*rhot
      hrs = hrt
!      arhos_min = 1.d-10*max(1.d0,rhot) ! for numerical accuracy
!      if (arhos .gt. 1.d-10*rhot) then
!      !   not closed shell
!         hrs = 1.d-4*rhos
!      else
!         hrs = 0.0d0
!      end if
!      hg = 1.d-4*grd

C     variations of variables
      rhotm = rhot-hrt
      rhotp = rhot+hrt
      rhosm = rhos-hrs
      rhosp = rhos+hrs
!      grdm = grd-hg
!      grdp = grd+hg

C First-order derivatives --------------------------------------------

C     derivative wrt rhot ---------------------
!      central 2nd-order approximation

       if (pure_spin) then
          call ESRSPIN(rhotm,rhosm,mu,dospin,Em0)
          call ESRSPIN(rhotp,rhosp,mu,dospin,Ep0)
          d1Edrhot = (Ep0 - Em0)/(2.d0*hrt)
!         if (rhos .gt. 0.0d0) then
!            d1Edrhos = d1Edrhot
!         else
!            d1Edrhos = -d1Edrhot
!         end if
       else
          call ESRSPIN(rhotm,rhos,mu,dospin,Em0)
          call ESRSPIN(rhotp,rhos,mu,dospin,Ep0)
          d1Edrhot = (Ep0 - Em0)/(2.d0*hrt)
          d1Edrhos = 0.0d0
       end if

C     derivative wrt rhos ---------------------
!      central 2nd-order approximation
       if (dospin .and. .not. pure_spin) then
       if (hrs .gt. 0.0d0) then
         call ESRSPIN(rhot,rhosm,mu,dospin,E0m)
         call ESRSPIN(rhot,rhosp,mu,dospin,E0p)
         d1Edrhos = (E0p - E0m)/(2.d0*hrs)
       else
         d1Edrhos = 0.0d0
       end if
       endif

C Second-order derivatives --------------------------------------------
      if(norder .ge. 2) then

      hrt2= hrt*hrt
      hrs2= hrs*hrs
      hrts= hrt*hrs
!      hg2= hg*hg
!      hrg= hr*hg

C     derivative wrt rhot and rhot -----------------
!      central 2nd-order approximation
       d2Edrhotdrhot = (Ep0 - 2.d0*E + Em0)/hrt2
      if (dospin) then
       if (pure_spin) then
         d2Edrhosdrhos = 0.0d0
         d2Edrhotdrhos = 0.0d0
       else if (hrs .gt. 0.0d0) then
C       derivative wrt rhos and rhos -----------------------
!        central 2nd-order approximation
         d2Edrhosdrhos = (E0p - 2.d0*E + E0m)/hrs2

C       derivative wrt rhot and rhos -----------------------
         call ESRSPIN(rhotp,rhosp,mu,dospin,Epp)
         call ESRSPIN(rhotm,rhosp,mu,dospin,Emp)
         call ESRSPIN(rhotp,rhosm,mu,dospin,Epm)
         call ESRSPIN(rhotm,rhosm,mu,dospin,Emm)
!        central 2nd-order approximation
         d2Edrhotdrhos = (Epp - Emp - Epm + Emm)/(4.d0*hrts)
        else
         d2Edrhosdrhos = 0.0d0
         d2Edrhotdrhos = 0.0d0
        end if
       endif
     
      endif

      return
      end
      SUBROUTINE DESRSPINGGA(ESRSPINGGA,rhot,rhos,grdt,grds,
     >                mu,norder, E, d1E, d2E)
C*****************************************************************************
C     Compute first-order and/or second-order numerical derivatives 
C     of a generic spin-dependent short-range GGA functional
C     ESRSPINGGA(rhot,rhos,grdt,grds,mu,E)
C
C     Input: ESRSPINGGA : spin-density GGA functional routine
C            rhot   : total density
C            rhos   : spin density
C            grdt   : gradient of rhot
C            grds   : gradient of rhos
C            mu     : Interation parameter
C            norder : order of derivatives
C
C     Ouput: d1E(1) = d1Edrhot      : first derivative wrt to rhot
C            d1E(2) = d1Edrhos      : first derivative wrt to rhos
C            d1E(3) = d1Edgrdt      : first derivative wrt to grdt (grad rhot)
C            d1E(4) = d1Edgrds      : first derivative wrt to grds (grad rhos)
C
C            d2E(1) = d2Edrhotdrhot : second derivative wrt to rhot and rhot
C            d2E(2) = d2Edrhotdrhos : second derivative wrt to rhot and rhos
C            d2E(3) = d2Edrhosdrhos : second derivative wrt to rhos and rhos
C            d2E(4) = d2Edrhotdgrdt : second derivative wrt to rhot and grdt
C            d2E(5) = d2Edrhosdgrdt : second derivative wrt to rhos and grdt
C            d2E(6) = d2Edgrdtdgrdt : second derivative wrt to grdt and grdt
C            d2E(7) = d2Edrhotdgrds : second derivative wrt to rhot and grds
C            d2E(8) = d2Edrhosdgrds : second derivative wrt to rhos and grds
C            d2E(9) = d2Edgrdtdgrds : second derivative wrt to grdt and grds
C            d2E(10)= d2Edgrdsdgrds : second derivative wrt to grds and grds
C
C     Created: 29-01-16, H. J. Aa. Jensen + Erik D. Hedegård)
C     (from routine by J. Toulouse)
C*****************************************************************************
      implicit none

      external         ESRSPINGGA
      integer          norder

      double precision rhot, rhos, grdt, grds, mu
      double precision E, d1E(4), d2E(10)

      double precision hrt, hrs,  hgt, hgs
      double precision hrt2, hrtrs, hrs2
      double precision hrtgt, hrsgt, hgt2, hrtgs, hrsgs, hgtgs, hgs2
      double precision rhotm, rhotp, rhosp, rhosm
      double precision grdtm, grdtp, grdsp, grdsm
      double precision arhos

      double precision Em000, Ep000, E0m00, E0p00
      double precision E00m0, E00p0, E000m, E000p

      double precision Emm00, Epp00, Epm00, Emp00
      double precision Em0m0, Ep0p0, Ep0m0, Em0p0
      double precision Em00m, Ep00p, Ep00m, Em00p
      double precision E0mm0, E0pp0, E0pm0, E0mp0
      double precision E0m0m, E0p0p, E0p0m, E0m0p
      double precision E00mm, E00pp, E00pm, E00mp

      logical  pure_spin, dospin
!     edh dospin always true but later on we can use this routine
!     general for open and closed shell cases...     

C     check
      if(norder .le. 0 .or. norder .ge. 3) then
       print *,'DESRSPINGGA: norder=',norder
       call quit('DESRSPINGGA: norder must be 0, 1, or 2')
      endif

      arhos = abs(rhos)
      if (arhos .gt. rhot) then
         call quit('DESRSPINGGA error: |rhos| > rhot')
      end if
      pure_spin = ((rhot - arhos) .le. 1.d-14 ) ! pure alpha or pure beta

      if (rhot .lt. 1.d-10) then ! no significant density in this point
         E = 0.0d0
         IF (NORDER.ge.1) d1E(:) = 0.0d0
         IF (NORDER.ge.2) D2E(:) = 0.0d0
         return
      end if

C     energy
      call ESRSPINGGA(rhot,rhos,grdt,grds,mu,dospin,E)
!      print *,'D1SRSPIN: E=',E

C     (optimal?) numerical step
C     (step length of hx=1.d-4*X should give a relative accuracy of approx. 16 digits
C      because we use central 2nd-order approximation=)

      hrt = 1.d-4*rhot
      hrs = hrt

      if (grdt .lt. 1.d-10) then
         hgt = 0.0d0
      else
         hgt = abs(1.d-4*grdt)
      end if
      hgs = hgt
      
!      arhos_min = 1.d-10*max(1.d0,rhot) ! for numerical accuracy
!      if (arhos .gt. 1.d-10*rhot) then
!      !   not closed shell
!         hrs = 1.d-4*rhos
!      else
!         hrs = 0.0d0
!      end if
!      hg = 1.d-4*grd

C     variations of variables
      rhotm = rhot-hrt
      rhotp = rhot+hrt
      rhosm = rhos-hrs
      rhosp = rhos+hrs
      grdtm = grdt-hgt
      grdtp = grdt+hgt
      grdsm = grds-hgs
      grdsp = grds+hgs
C
C Special treatment of pure spin

      if (pure_spin) then

       call quit('DESRSPINGGA: pure_spin not implemented yet')

         if (norder .ge. 1) then
           d1E(:) = 0.0d0
           call ESRSPINGGA(rhotm,rhosm,grdt,grds,mu,dospin,Em000)
           call ESRSPINGGA(rhotp,rhosp,grdt,grds,mu,dospin,Ep000)
           d1E(1) = (Ep000 - Em000)/(2.d0*hrt) ! d1Edrhot
!         if (rhos .gt. 0.0d0) then
!            d1Edrhos = d1Edrhot
!         else
!            d1Edrhos = -d1Edrhot
!         end if
         end if

         if (norder .ge. 2) then
            d2E(:) = 0.0d0
         end if

         return
      end if

! (All derivatives in the following calculated with central 2nd-order approximation)

C First-order derivatives --------------------------------------------
      if (norder .lt. 1) return

      d1E(:) = 0.0d0

C     derivatives wrt rhot, rhos, grdt, grds ---------------------

      call ESRSPINGGA(rhotm,rhos,grdt,grds,mu,dospin,Em000)
      call ESRSPINGGA(rhotp,rhos,grdt,grds,mu,dospin,Ep000)
      d1E(1) = (Ep000 - Em000)/(2.d0*hrt) ! d1Edrhot

      if (hrs .gt. 0.0d0) then
         call ESRSPINGGA(rhot,rhosm,grdt,grds,mu,dospin,E0m00)
         call ESRSPINGGA(rhot,rhosp,grdt,grds,mu,dospin,E0p00)
         d1E(2) = (E0p00 - E0m00)/(2.d0*hrs) ! d1Edrhos
       end if

      if (hgt .gt. 0.0d0) then
         call ESRSPINGGA(rhot,rhos,grdtm,grds,mu,dospin,E00m0)
         call ESRSPINGGA(rhot,rhos,grdtp,grds,mu,dospin,E00p0)
         d1E(3) = (E00p0 - E00m0)/(2.d0*hgt) ! d1Edgrdt
       end if

      if (hgs .gt. 0.0d0) then
         call ESRSPINGGA(rhot,rhos,grdt,grdsm,mu,dospin,E000m)
         call ESRSPINGGA(rhot,rhos,grdt,grdsp,mu,dospin,E000p)
         d1E(4) = (E000p - E000m)/(2.d0*hgs) ! d1Edgrds
       end if

C Second-order derivatives --------------------------------------------
      if (norder .lt. 2) return

      d2E(:) = 0.0d0

C     derivative wrt rhot and rhot -----------------
       d2E(1) = (Ep000 - 2.d0*E + Em000)/(hrt*hrt) ! d2Edrhotdrhot

       if (hrs .gt. 0.0d0) then
C        derivative wrt rhos and rhos -----------------------
         d2E(3) = (E0p00 - 2.d0*E + E0m00)/(hrs*hrs) ! d2Edrhosdrhos

C        derivative wrt rhot and rhos -----------------------
         call ESRSPINGGA(rhotp,rhosp,grdt,grds,mu,dospin,Epp00)
         call ESRSPINGGA(rhotm,rhosp,grdt,grds,mu,dospin,Emp00)
         call ESRSPINGGA(rhotp,rhosm,grdt,grds,mu,dospin,Epm00)
         call ESRSPINGGA(rhotm,rhosm,grdt,grds,mu,dospin,Emm00)
         d2E(2) = (Epp00 - Emp00 - Epm00 + Emm00)/(4.d0*hrt*hrs) ! d2Edrhotdrhos
       end if

       if (hgt .gt. 0.0d0) then
C        derivative wrt grdt and grdt -----------------------
         d2E(6) = (E00p0 - 2.d0*E + E00m0)/(hgt*hgt) ! d2Edgrdtgrdt

C        derivative wrt rhot and grdt -----------------------
         call ESRSPINGGA(rhotp,rhos,grdt,grdsp,mu,dospin,Ep0p0)
         call ESRSPINGGA(rhotm,rhos,grdt,grdsp,mu,dospin,Em0p0)
         call ESRSPINGGA(rhotp,rhos,grdt,grdsm,mu,dospin,Ep0m0)
         call ESRSPINGGA(rhotm,rhos,grdt,grdsm,mu,dospin,Em0m0)
         d2E(4) = (Ep0p0 - Em0p0 - Ep0m0 + Em0m0)/(4.d0*hrt*hgt) ! d2Edrhotdgrdt

       if (hrs .gt. 0.0d00) then

C        derivative wrt rhos and grdt -----------------------
         call ESRSPINGGA(rhot,rhosp,grdtp,grds,mu,dospin,E0pp0)
         call ESRSPINGGA(rhot,rhosm,grdtp,grds,mu,dospin,E0mp0)
         call ESRSPINGGA(rhot,rhosp,grdtm,grds,mu,dospin,E0pm0)
         call ESRSPINGGA(rhot,rhosm,grdtm,grds,mu,dospin,E0mm0)
         d2E(5) = (E0pp0 - E0mp0 - E0pm0 + E0mm0)/(4.d0*hrs*hgt) ! d2Edrhosdgrdt
       end if

       end if ! hgt .gt. 0

       if (hgs .gt. 0.0d0) then
C        derivative wrt grds and grds -----------------------
         d2E(10) = (E000p - 2.d0*E + E000m)/(hgs*hgs) ! d2Edgrdsgrds

C        derivative wrt rhot and grds -----------------------
         call ESRSPINGGA(rhotp,rhos,grdt,grdsp,mu,dospin,Ep00p)
         call ESRSPINGGA(rhotm,rhos,grdt,grdsp,mu,dospin,Em00p)
         call ESRSPINGGA(rhotp,rhos,grdt,grdsm,mu,dospin,Ep00m)
         call ESRSPINGGA(rhotm,rhos,grdt,grdsm,mu,dospin,Em00m)
         d2E(7) = (Ep00p - Em00p - Ep00m + Em00m)/(4.d0*hrt*hgs) ! d2Edrhotdgrds

       if (hrs .gt. 0.0d00) then

C        derivative wrt rhos and grds -----------------------
         call ESRSPINGGA(rhot,rhosp,grdt,grdsp,mu,dospin,E0p0p)
         call ESRSPINGGA(rhot,rhosm,grdt,grdsp,mu,dospin,E0m0p)
         call ESRSPINGGA(rhot,rhosp,grdt,grdsm,mu,dospin,E0p0m)
         call ESRSPINGGA(rhot,rhosm,grdt,grdsm,mu,dospin,E0m0m)
         d2E(8) = (E0p0p - E0m0p - E0p0m + E0m0m)/(4.d0*hrs*hgs) ! d2Edrhosdgrds
       end if

       if (hgt .gt. 0.0d00) then

C        derivative wrt grdt and grds -----------------------
         call ESRSPINGGA(rhot,rhos,grdtp,grdsp,mu,dospin,E00pp)
         call ESRSPINGGA(rhot,rhos,grdtm,grdsp,mu,dospin,E00mp)
         call ESRSPINGGA(rhot,rhos,grdtp,grdsm,mu,dospin,E00pm)
         call ESRSPINGGA(rhot,rhos,grdtm,grdsm,mu,dospin,E00mm)
         d2E(9) = (E00pp - E00mp - E00pm + E00mm)/(4.d0*hgt*hgs) ! d2Edgrdtdgrds
       end if

       end if ! hgs .gt. 0

      return
      end
      SUBROUTINE DESRSPINGGA_ab(ESRSPINGGA_ab,rho,grd,mu,
     >                norder, E, d1E, d2E)
C*****************************************************************************
C     Compute first-order and/or second-order numerical derivatives
C     of a generic spin-dependent short-range GGA functional
C     ESRSPINGGA_ab(rhoa,rhob,grda,grdb,mu,E)
C
C     Input: ESRSPINGGA_ab : spin-density GGA functional routine
C            rho(1:4) : total density, spin density, 2 rho_a, 2 rho_b
C            grd(1:4) : grd(i) = gradient norm of rho(i)
C            mu     : Interation parameter
C            norder : order of derivatives
C
C     Ouput: d1E(1) = d1Edrhot      : first derivative wrt to rhot
C            d1E(2) = d1Edrhos      : first derivative wrt to rhos
C            d1E(3) = d1Edgrdt      : first derivative wrt to grdt (grad rhot)
C            d1E(4) = d1Edgrds      : first derivative wrt to grds (grad rhos)
C
C            d2E(1) = d2Edrhotdrhot : second derivative wrt to rhot and rhot
C            d2E(2) = d2Edrhotdrhos : second derivative wrt to rhot and rhos
C            d2E(3) = d2Edrhosdrhos : second derivative wrt to rhos and rhos
C            d2E(4) = d2Edrhotdgrdt : second derivative wrt to rhot and grdt
C            d2E(5) = d2Edrhosdgrdt : second derivative wrt to rhos and grdt
C            d2E(6) = d2Edgrdtdgrdt : second derivative wrt to grdt and grdt
C            d2E(7) = d2Edrhotdgrds : second derivative wrt to rhot and grds
C            d2E(8) = d2Edrhosdgrds : second derivative wrt to rhos and grds
C            d2E(9) = d2Edgrdtdgrds : second derivative wrt to grdt and grds
C            d2E(10)= d2Edgrdsdgrds : second derivative wrt to grds and grds
C
C     Created: 07-02-16, H. J. Aa. Jensen (from routine by J. Toulouse)
C*****************************************************************************
      implicit none

      external         ESRSPINGGA_ab
      integer          norder

      double precision rho(4), grd(4), mu
      double precision E, d1E(4), d2E(10)
      double precision    d1W(4), d2W(10) ! for derivative wrt rhoa, rhob, grda, grdb

!     double precision rhot, rhos, grdt, grds
!     double precision rhotx, rhosx, grdtx, grdsx ! modified values used in numerical differentiation

      double precision rhoa, rhob, grda, grdb
      double precision rhoam, rhoap, rhobp, rhobm ! modified values used in numerical differentiation
      double precision grdam, grdap, grdbp, grdbm ! modified values used in numerical differentiation

      double precision hra, hrb,  hga, hgb
      double precision hra2, hrarb, hrb2
      double precision hraga, hrbga, hga2, hragb, hrbgb, hgagb, hgb2

      double precision Em000, Ep000, E0m00, E0p00
      double precision E00m0, E00p0, E000m, E000p

      double precision Emm00, Epp00, Epm00, Emp00
      double precision Em0m0, Ep0p0, Ep0m0, Em0p0
      double precision Em00m, Ep00p, Ep00m, Em00p
      double precision E0mm0, E0pp0, E0pm0, E0mp0
      double precision E0m0m, E0p0p, E0p0m, E0m0p
      double precision E00mm, E00pp, E00pm, E00mp

      logical  pure_spin

C     check
      if(norder .le. 0 .or. norder .ge. 3) then
        print *,'DESRSPINGGA_ab: norder=',norder
        call quit('DESRSPINGGA_ab: norder must be 0, 1, or 2')
      endif

      if (rho(1) .lt. 1.d-10) then ! no significant density in this point
         E = 0.0d0
         IF (NORDER.ge.1) d1E(:) = 0.0d0
         IF (NORDER.ge.2) D2E(:) = 0.0d0
         return
      end if

      rhoa = rho(3)/2
      rhob = rho(4)/2
      grda = grd(3)/2
      grdb = grd(4)/2
      if (rhoa .lt. 0.0d0 .or. rhob .lt. 0.0d0) then
         call quit('DESRSPINGGA_ab error: rhoa or rhob negative')
      end if
      pure_spin = (rhoa .le. 1.d-14  .or. rhob .le. 1.d-14) ! pure alpha or pure beta

C     energy
      call ESRSPINGGA_ab(rhoa,rhob,grda,grdb,mu,E)
!     print *,'D1SRSPIN: E=',E

C     (optimal?) numerical step
C     (step length of hx=1.d-4*X should give a relative accuracy of approx. 16 digits
C      because we use central 2nd-order approximation=)

      hra = 1.d-4*rhoa
      hrb = 1.d-4*rhob
      hga = 1.d-4*grda
      hgb = 1.d-4*grdb
      if (hra .lt. 1.d-12) hra = 0.d0
      if (hrb .lt. 1.d-12) hrb = 0.d0
      if (hga .lt. 1.d-12) hga = 0.d0
      if (hgb .lt. 1.d-12) hgb = 0.d0

C     variations of variables
      rhoam = rhoa-hra
      rhoap = rhoa+hra
      rhobm = rhob-hrb
      rhobp = rhob+hrb
      grdam = grda-hga
      grdap = grda+hga
      grdbm = grdb-hgb
      grdbp = grdb+hgb
C
C Special treatment of pure spin

      if (pure_spin) then

       call quit('DESRSPINGGA_ab: pure_spin not implemented yet')

         if (norder .ge. 1) then
           d1E(:) = 0.0d0
!          call ESRSPINGGA(rhotm,rhosm,grdt,grds,mu,Em000)
!          call ESRSPINGGA(rhotp,rhosp,grdt,grds,mu,Ep000)
           d1E(1) = (Ep000 - Em000)/(2.d0*hra) ! d1Edrhot
!         if (rhos .gt. 0.0d0) then
!            d1Edrhos = d1Edrhot
!         else
!            d1Edrhos = -d1Edrhot
!         end if
         end if

         if (norder .ge. 2) then
            d2E(:) = 0.0d0
         end if

         return
      end if

! (All derivatives in the following calculated with central 2nd-order approximation)

C First-order derivatives --------------------------------------------
      if (norder .lt. 1) return

      d1W(:) = 0.0d0

C     derivatives wrt rhoa, rhob, grda, grdb ---------------------

      if (hra .gt. 0.0d0) then
         call ESRSPINGGA_ab(rhoam,rhob,grda,grdb,mu,Em000)
         call ESRSPINGGA_ab(rhoap,rhob,grda,grdb,mu,Ep000)
         d1W(1) = (Ep000 - Em000)/(2.d0*hra) ! d1Edrhoa
      end if

      if (hrb .gt. 0.0d0) then
         call ESRSPINGGA_ab(rhoa,rhobm,grda,grdb,mu,E0m00)
         call ESRSPINGGA_ab(rhoa,rhobp,grda,grdb,mu,E0p00)
         d1W(2) = (E0p00 - E0m00)/(2.d0*hrb) ! d1Edrhob
       end if

      if (hga .gt. 0.0d0) then
         call ESRSPINGGA_ab(rhoa,rhob,grdam,grdb,mu,E00m0)
         call ESRSPINGGA_ab(rhoa,rhob,grdap,grdb,mu,E00p0)
         d1W(3) = (E00p0 - E00m0)/(2.d0*hga) ! d1Edgrda
       end if

      if (hgb .gt. 0.0d0) then
         call ESRSPINGGA_ab(rhoa,rhob,grda,grdbm,mu,E000m)
         call ESRSPINGGA_ab(rhoa,rhob,grda,grdbp,mu,E000p)
         d1W(4) = (E000p - E000m)/(2.d0*hgb) ! d1Edgrdb
       end if

       d1E(1) = d1W(1) + d1W(2)
       d1E(2) = d1W(1) - d1W(2)
       d1E(3) = d1W(3) + d1W(4)
       d1E(4) = d1W(3) - d1W(4)

C Second-order derivatives --------------------------------------------
      if (norder .lt. 2) return

      d2W(:) = 0.0d0

C     derivative wrt rhoa and rhoa -----------------
       IF (hra .gt. 0.0d0) then
         d2W(1) = (Ep000 - 2.d0*E + Em000)/(hra*hra) ! d2Edrhoadrhoa
       END IF

C        derivative wrt rhob and rhob -----------------------
       IF (hrb .gt. 0.0d0) then
         d2W(3) = (E0p00 - 2.d0*E + E0m00)/(hrb*hrb) ! d2Edrhobdrhob

C        derivative wrt rhoa and rhob -----------------------
       if (hra .gt. 0.0d0) then
         call ESRSPINGGA_ab(rhoap,rhobp,grda,grdb,mu,Epp00)
         call ESRSPINGGA_ab(rhoam,rhobp,grda,grdb,mu,Emp00)
         call ESRSPINGGA_ab(rhoap,rhobm,grda,grdb,mu,Epm00)
         call ESRSPINGGA_ab(rhoam,rhobm,grda,grdb,mu,Emm00)
         d2W(2) = (Epp00 - Emp00 - Epm00 + Emm00)/(4.d0*hra*hrb) ! d2Edrhoadrhob
       end if
       END IF ! hrb .gt. 0


C        derivative wrt grda and grda -----------------------
       IF (hga .gt. 0.0d0) then
         d2W(6) = (E00p0 - 2.d0*E + E00m0)/(hga*hga) ! d2Edgrdagrda

C        derivative wrt rhoa and grda -----------------------
       if (hra .gt. 0.0d0) then
         call ESRSPINGGA_ab(rhoap,rhob,grda,grdbp,mu,Ep0p0)
         call ESRSPINGGA_ab(rhoam,rhob,grda,grdbp,mu,Em0p0)
         call ESRSPINGGA_ab(rhoap,rhob,grda,grdbm,mu,Ep0m0)
         call ESRSPINGGA_ab(rhoam,rhob,grda,grdbm,mu,Em0m0)
         d2W(4) = (Ep0p0 - Em0p0 - Ep0m0 + Em0m0)/(4.d0*hra*hga) ! d2Edrhoadgrda
       end if

C        derivative wrt rhob and grda -----------------------
       if (hrb .gt. 0.0d00) then
         call ESRSPINGGA_ab(rhoa,rhobp,grdap,grdb,mu,E0pp0)
         call ESRSPINGGA_ab(rhoa,rhobm,grdap,grdb,mu,E0mp0)
         call ESRSPINGGA_ab(rhoa,rhobp,grdam,grdb,mu,E0pm0)
         call ESRSPINGGA_ab(rhoa,rhobm,grdam,grdb,mu,E0mm0)
         d2W(5) = (E0pp0 - E0mp0 - E0pm0 + E0mm0)/(4.d0*hrb*hga) ! d2Edrhobdgrda
       end if
       END IF ! hga .gt. 0


C        derivative wrt grdb and grdb -----------------------
       IF (hgb .gt. 0.0d0) then
         d2W(10) = (E000p - 2.d0*E + E000m)/(hgb*hgb) ! d2Edgrdbgrdb

C        derivative wrt rhoa and grdb -----------------------
       if (hra .gt. 0.0d0) then
         call ESRSPINGGA_ab(rhoap,rhob,grda,grdbp,mu,Ep00p)
         call ESRSPINGGA_ab(rhoam,rhob,grda,grdbp,mu,Em00p)
         call ESRSPINGGA_ab(rhoap,rhob,grda,grdbm,mu,Ep00m)
         call ESRSPINGGA_ab(rhoam,rhob,grda,grdbm,mu,Em00m)
         d2W(7) = (Ep00p - Em00p - Ep00m + Em00m)/(4.d0*hra*hgb) ! d2Edrhoadgrdb
       end if

C        derivative wrt rhob and grdb -----------------------
       if (hrb .gt. 0.0d00) then
         call ESRSPINGGA_ab(rhoa,rhobp,grda,grdbp,mu,E0p0p)
         call ESRSPINGGA_ab(rhoa,rhobm,grda,grdbp,mu,E0m0p)
         call ESRSPINGGA_ab(rhoa,rhobp,grda,grdbm,mu,E0p0m)
         call ESRSPINGGA_ab(rhoa,rhobm,grda,grdbm,mu,E0m0m)
         d2W(8) = (E0p0p - E0m0p - E0p0m + E0m0m)/(4.d0*hrb*hgb) ! d2Edrhobdgrdb
       end if

C        derivative wrt grda and grdb -----------------------
       if (hga .gt. 0.0d00) then
         call ESRSPINGGA_ab(rhoa,rhob,grdap,grdbp,mu,E00pp)
         call ESRSPINGGA_ab(rhoa,rhob,grdam,grdbp,mu,E00mp)
         call ESRSPINGGA_ab(rhoa,rhob,grdap,grdbm,mu,E00pm)
         call ESRSPINGGA_ab(rhoa,rhob,grdam,grdbm,mu,E00mm)
         d2W(9) = (E00pp - E00mp - E00pm + E00mm)/(4.d0*hga*hgb) ! d2Edgrdadgrdb
       end if

       END IF ! hgb .gt. 0

!      d2Edrt2   = d2Edra2 + d2Edrb2 + 2 d2Edradrb
       d2E(1)    = d2W(1)  + d2W(3)  + 2*d2W(2)
!      d2Edrtdrs = d2Edra2 - d2Edrb2
       d2E(2)    = d2W(1)  - d2W(3)
!      d2Edrs2   = d2Edra2 + d2Edrb2 - 2 d2Edradrb
       d2E(3)    = d2W(1)  + d2W(3)  - 2*d2W(2)

!      d2Edrtdgt = d2Edradga + d2Edradgb + d2Edrbdga + d2Edrbdgb
       d2E(4)    = d2W(4)    + d2W(7)    + d2W(5)    + d2W(8)
!      d2Edrtdgs = d2Edradga - d2Edradgb + d2Edrbdga - d2Edrbdgb
       d2E(7)    = d2W(4)    - d2W(7)    + d2W(5)    - d2W(8)
!      d2Edrsdgt = d2Edradga + d2Edradgb - d2Edrbdga - d2Edrbdgb
       d2E(5)    = d2W(4)    + d2W(7)    - d2W(5)    - d2W(8)
!      d2Edrsdgs = d2Edradga - d2Edradgb - d2Edrbdga + d2Edrbdgb
       d2E(8)    = d2W(4)    - d2W(7)    - d2W(5)    + d2W(8)

!      d2Edgt2   = d2Edga2 + d2Edgb2 + 2 d2Edgadgb
       d2E(6)    = d2W(6)  + d2W(10) + 2*d2W(9)
!      d2Edgtdgs = d2Edga2 - d2Edgb2
       d2E(9)    = d2W(6)  - d2W(10)
!      d2Edgs2   = d2Edga2 + d2Edgb2 - 2 d2Edgadgb
       d2E(10)   = d2W(6)  + d2W(10) - 2*d2W(9)

      return
      end
C****************************************************************************
      SUBROUTINE DELSPIN(ESRSPIN,rhot,rhos,VLAMBDA,dospin,norder,
     >                d1Edrhot,d1Edrhos,
     >                d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos)

C linear complement spin-dependent exchange LDA functional, Kamal SHARKAS 23/04/2011
C*****************************************************************************
      implicit none

      external ESRSPIN
      integer norder
      logical dospin
      double precision rhot, rhos, VLAMBDA
      double precision d1Edrhot, d1Edrhos
      double precision d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos

      call  DESRSPIN(ESRSPIN,rhot,rhos,0.d0,dospin,norder,
     >                d1Edrhot,d1Edrhos,
     >                d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos)


      d1Edrhot = (1.d0- VLAMBDA) * d1Edrhot

       if (dospin) d1Edrhos = (1.d0- VLAMBDA) * d1Edrhos

      d2Edrhotdrhot = (1.d0- VLAMBDA) * d2Edrhotdrhot

       if (dospin) d2Edrhotdrhos = (1.d0- VLAMBDA) * d2Edrhotdrhos

       if (dospin) d2Edrhosdrhos =  (1.d0- VLAMBDA) * d2Edrhosdrhos

          return
           end

C****************************************************************************
      SUBROUTINE DELSPINnSC(ESRSPIN,rhot,rhos,VLAMBDA,dospin,norder,
     >                d1Edrhot,d1Edrhos,
     >                d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos)
C linear complement non-scaled spin-dependent correlation LDA functional, Kamal SHARKAS 23/04/2011
C*****************************************************************************
      implicit none

      external ESRSPIN
      integer norder
      logical dospin
      double precision rhot, rhos, VLAMBDA
      double precision d1Edrhot, d1Edrhos
      double precision d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos

      call  DESRSPIN(ESRSPIN,rhot,rhos,0.d0,dospin,norder,
     >                d1Edrhot,d1Edrhos,
     >                d2Edrhotdrhot,d2Edrhotdrhos,d2Edrhosdrhos)


      d1Edrhot = (1.d0- VLAMBDA**2)* d1Edrhot
        if (dospin) d1Edrhos = (1.d0- VLAMBDA**2)* d1Edrhos

      d2Edrhotdrhot = (1.d0- VLAMBDA**2)* d2Edrhotdrhot
        if (dospin) d2Edrhotdrhos = (1.d0- VLAMBDA**2)* d2Edrhotdrhos

        if (dospin) d2Edrhosdrhos =  (1.d0- VLAMBDA**2)* d2Edrhosdrhos

          return
           end
C****************************************************************************

C****************************************************************************
      subroutine ESRX_PBETCSERF(rho,grd,mu,e)
C*****************************************************************************
C     Short-range PBE exchange functional from 
C       Toulouse, Colonna, Savin JCP 122, 014110 (2005)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interation parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 19-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision rho13
      double precision drho2

      double precision exerflda
      double precision exerfpbe
      double precision t1,t2,t3,t4

      double precision XKSR(3)
      logical ERFEXP(0:2)

! function 
      double precision berft

C     LDA energy
      rho13 = rho**(1.d0/3.d0)
      ERFEXP(0:2) = .false.
      call VXSRLDA(XKSR,rho,rho13,mu,0,ERFEXP)
      exerflda = XKSR(1)

      drho2 = grd*grd

!      Code generated by Mathematica
       exerfpbe = (-5.521381337364587693627982d1*exerflda*(1.63580000000
     & 000014281909d0*rho**4 + 4.272901476924512165211922d-2*drho2*berft
     &  (1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(4.d0/
     &  3.d0) + 1.d0*exerflda*rho**(8.d0/3.d0)))/(-9.0318755916609930523
     & 0091d1*rho**4 + 1.442249570307408301772512d0*drho2*exerflda*berft
     &  (1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)) - 5.5213813
     &  37364587693627982d1*exerflda*rho**(8.d0/3.d0))

        e = exerfpbe

      return
      end
C****************************************************************************
      subroutine ESRX_PBEHSEERF(rho,grd,mu,e)
C*****************************************************************************
C     Short-range PBE exchange functional from 
C       Heyd and Scuseria, JCP 120, 7274 (2004)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interation parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision pi,rho13,kF,s
      double precision exLDA
      double precision FxHSE

C     constants
      pi = 3.141592653589793d0

C     LDA exchange
      rho13 = rho**(1.d0/3.d0)
      CALL EDRC(exLDA,rho,rho13)

C     Gradient
      kF = (3.d0*(pi**2)*rho)**(1.d0/3.d0)
      s = grd/(2.d0*kF*rho)

C     Enhancement factor (over LDA) of short-range PBE from HSE
      call wpbe_analytical_erfc_approx(rho,s,mu,FxHSE)

C     Energy
      e = exLDA*FxHSE
       
      return
      end
C****************************************************************************
      SUBROUTINE VSRXPBEERF(e,d1edrho,d1edgrd,d1edgrda2,d2edrhodrho,
     >                      d2edgrddgrd,d2edrhodgrd,rho,grd,mu,
     >                      norder,FxSR)
C*****************************************************************************
C     Short-range PBE exchange functional from 
C       Heyd and Scuseria, JCP 120, 7274 (2004)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interation parameter
C            norder : Order of derivative
C            FxSR   : routine for evaluation of Fx(short-range PBE)
C
C     Ouput: e             : energy
C            d1edrho       : first derivative wrt to rho
C            d1edgrd       : first derivative wrt to grd   (for 2nd-order optimisation)
C            d1edgrda2     : first derivative wrt to grda2 (for HF optimisation)
C            (grda2 is the square of gradient of spin-alpha density)
C            d2edrhodrho   : second derivative wrt to rho and rho
C            d2edgrddgrd   : second derivative wrt to grd and grd
C            d2edrhodgrd   : second derivative wrt to rho and grd
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C
C     Derivatives wrong. Not used.
C*****************************************************************************
      implicit none

      integer norder

      double precision rho, grd, mu
      double precision e, d1edrho, d1edgrd, d1edgrda2
      double precision d2edrhodrho,d2edgrddgrd,d2edrhodgrd

      double precision pi,rho13,kF,s
      double precision exLDA
      double precision FxHSE

      integer i
      double precision rho1, rho2, s1, s2
      double precision FxHSE1, FxHSE2

      double precision h, h2
      double precision rhom, rhop, rhopp, sm, sp, spp

      double precision d1exLDAdrho
      double precision FxHSEm0, FxHSEp0, FxHSEpp0
      double precision FxHSE0m, FxHSE0p, FxHSE0pp
      double precision FxHSEmm, FxHSEmp, FxHSEpm, FxHSEpp
      double precision d1FxHSEdrho
      double precision d1FxHSEds, d1FxHSEdgrd, d1FxHSEdgrd2
      double precision d1FxHSEdgrda2
      double precision dsdrho, dsdgrd, dgrddgrd2

      double precision d2exLDAdrhodrho
      double precision d2FxHSEdrhodrho
      double precision d2FxHSEdrhods, d2FxHSEdgrddgrd
      double precision d2FxHSEdsds, d2FxHSEdrhodgrd
      double precision dsdgrd2

      external FxSR

      double precision rhom13, rhop13, rhopp13
      double precision DF1000,DF0010,DF2000,DF1010,DF0020

!      print *,'VSRPBEXERF: mu=',mu
!      print *,'VSRPBEXERF: rho=',rho
!      print *,'VSRPBEXERF: grd=',grd

      call quit('routine is wrong. Use ESRX_PBEERF instead')
C     constants
      pi = 3.141592653589793d0

!      print *,'VSRPBEXERF: mu=',mu
!      print *,'VSRPBEXERF: rho=',rho,' grd=',grd

C     LDA exchange
      rho13 = rho**(1.d0/3.d0)
      CALL EDRC(exLDA,rho,rho13)

C     Gradient
      kF = (3.d0*(pi**2)*rho)**(1.d0/3.d0)
      s = grd/(2.d0*kF*rho)

C     Enhancement factor (over LDA) of short-range PBE from HSE
      call FxSR(rho,s,mu,FxHSE)

C     Energy
      e = exLDA*FxHSE
!debug LDA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      FxHSE = exLDA
!      e = FxHSE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!      print *,'VSRXPBEERF: E=',E
       
C     First-order (numerical) derivatives ---------------------------------
      if(norder .ge. 1) then

!     LDA
      CALL VDRC(d1exLDAdrho,rho13)

      dsdgrd = 1.d0/(2.d0*kF*rho)

C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C debug: test values for h
      if(.false.) then
      rho = 1.003d0
      s   = 1.000d0
      mu  = 1.000d0

      print *,'rho=',rho
      print *,'s=',s
      print *,'mu=',mu

      call FxSR(rho,s,mu,FxHSE)
      print *,'FxHSE=',FxHSE

      do i = 0, 20
      h = 10.d0**(-i)

      rho1 = rho-h
      rho2 = rho+h
      if(rho1 .ge. 0.d0) then
       call FxSR(rho1,s,mu,FxHSE1)
       call FxSR(rho2,s,mu,FxHSE2)
       d1FxHSEdrho = (FxHSE2 - FxHSE1)/(2.d0*h)
      else
       call FxSR(rho2,s,mu,FxHSE2)
       d1FxHSEdrho = (FxHSE2 - FxHSE)/h
      endif

C     derivative wrt s
      s1 = s-h
      s2 = s+h
      if(s1 .ge. 0.d0) then
       call FxSR(rho,s1,mu,FxHSE1)
       call FxSR(rho,s2,mu,FxHSE2)
       d1FxHSEds = (FxHSE2 - FxHSE1)/(2.d0*h)
      else
       call FxSR(rho,s2,mu,FxHSE2)
       d1FxHSEds = (FxHSE2 - FxHSE)/h
      endif

C     Print
      write(*,'(A,D10.5,A,F25.20,A,F25.20)') 'h=',h,
     >               ' d1FxHSEdrho=',d1FxHSEdrho,' d1FxHSEds=',d1FxHSEds
      enddo
      stop
      endif
C end debug !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C     numerical step
      h = 1.d-4

C     variations of variables
      rhom = rho-h
      rhop = rho+h
      sm = s-h
      sp = s+h
!debug LDA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      rhom13 = rhom**(1.d0/3.d0)
!      rhop13 = rhop**(1.d0/3.d0)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C     derivative wrt rho ---------------------
      call FxSR(rhop,s,mu,FxHSEp0)
      if(rhom .ge. 0.d0) then 
!      central 2nd-order approximation
       call FxSR(rhom,s,mu,FxHSEm0)
       d1FxHSEdrho = (FxHSEp0 - FxHSEm0)/(2.d0*h)
      else 
!      forward 1st-order approximation
       d1FxHSEdrho = (FxHSEp0 - FxHSE)/h
      endif

      d1edrho = d1exLDAdrho*FxHSE + exLDA*d1FxHSEdrho
!      print *,'VSRXPBEERF: d1edrho=',d1edrho

C     derivative wrt grd ---------------------

C     derivative wrt s
      call FxSR(rho,sp,mu,FxHSE0p)
      if(sm .ge. 0.d0) then
!      central 2nd-order approximation
       call FxSR(rho,sm,mu,FxHSE0m)
       d1FxHSEds = (FxHSE0p - FxHSE0m)/(2.d0*h)
      else
!      forward 1st-order approximation
       d1FxHSEds = (FxHSE0p - FxHSE)/h
      endif

C     derivative wrt grd
      d1FxHSEdgrd = d1FxHSEds * dsdgrd 
      d1edgrd   = exLDA*d1FxHSEdgrd
!      print *,'VSRXPBERF: d1Edgrd=',d1Edgrd
      
C     derivative wrt grd2
      dgrddgrd2 = 1.d0/(2.d0*grd)
      d1FxHSEdgrd2 = d1FxHSEdgrd * dgrddgrd2

C     derivative wrt grda2
      d1FxHSEdgrda2 = 4.d0*d1FxHSEdgrd2
      d1edgrda2 = exLDA*d1FxHSEdgrda2

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      dsdrho = -grd*2.d0/(3.d0**(4.d0/3.d0)*
     >  pi**(2.d0/3.d0)*rho**(7.d0/3.d0))
      d1FxHSEdrho = d1FxHSEdrho + d1FxHSEds * dsdrho
      d1edrho = d1exLDAdrho*FxHSE + exLDA*d1FxHSEdrho
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      

!debug LDA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      if(rhom .ge. 0.d0) then 
!!      central 2nd-order approximation
!       CALL EDRC(FxHSEm0,rhom,rhom13)
!       CALL EDRC(FxHSEp0,rhop,rhop13)
!       d1FxHSEdrho = (FxHSEp0 - FxHSEm0)/(2.d0*h)
!      else 
!!      forward 1st-order approximation
!       CALL EDRC(FxHSEp0,rhop,rhop13)
!       d1FxHSEdrho = (FxHSEp0 - FxHSE)/h
!      endif
!      d1edrho   = d1FxHSEdrho
!      d1edgrd   = 0.d0
!      d1edgrda2 = 0.d0
!!      print *,'VSRXPBERF: d1edrho=',d1edrho
!!      print *,'VSRXPBERF: d1exLDAdrho=',d1exLDAdrho
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      endif

C     Second-order (numerical) derivatives ------------------------------
      if(norder .ge. 2) then
      
C     LDA
      call V1DRC(d1exLDAdrho,d2exLDAdrhodrho,rho,rho13)

      h2 = h*h

C     derivative wrt rho and rho -----------------
      if(rhom .ge. 0.d0) then 
!      central 2nd-order approximation
       d2FxHSEdrhodrho = (FxHSEp0 - 2.d0*FxHSE + FxHSEm0)/h2
      else 
!      forward 1st-order approximation
       rhopp = rho + 2.d0*h
       call FxSR(rhopp,s,mu,FxHSEpp0)
       d2FxHSEdrhodrho = (FxHSEpp0 -2.d0*FxHSEp0 + FxHSE)/h2
      endif

      d2edrhodrho = d2exLDAdrhodrho*FxHSE + 2.d0*d1exLDAdrho*d1FxHSEdrho
     >            + exLDA*d2FxHSEdrhodrho

C     derivative wrt grd and grd -----------------------

C     derivative wrt s and s
      if(sm .ge. 0.d0) then
!      central 2nd-order approximation
       d2FxHSEdsds = (FxHSE0p - 2.d0*FxHSE + FxHSE0m)/h2
      else
!      forward 1st-order approximation
       spp = s + 2.d0*h
       call FxSR(rho,spp,mu,FxHSE0pp)
       d2FxHSEdsds = (FxHSE0pp -2.d0*FxHSE0p + FxHSE)/h2
      endif

C     derivative wrt grd and grd
      dsdgrd2 = dsdgrd*dsdgrd
      d2FxHSEdgrddgrd = d2FxHSEdsds * dsdgrd2
      
      d2edgrddgrd = exLDA*d2FxHSEdgrddgrd

C     derivative wrt rho and grd -----------------------

C     derivative wrt rho and s
      if(rhom.ge. 0.d0 .and. sm .ge. 0.d0) then
       call FxSR(rhop,sp,mu,FxHSEpp)
       call FxSR(rhom,sp,mu,FxHSEmp)
       call FxSR(rhop,sm,mu,FxHSEpm)
       call FxSR(rhom,sm,mu,FxHSEmm)
!      central 2nd-order approximation
       d2FxHSEdrhods = (FxHSEpp - FxHSEmp - FxHSEpm + FxHSEmm)/(4.d0*h2)
      else
       call FxSR(rhop,sp,mu,FxHSEpp)
!      forward 1st-order approximation
       d2FxHSEdrhods = (FxHSEpp - FxHSE0p - FxHSEp0 + FxHSE)/h2
      endif

      d2FxHSEdrhodgrd = d2FxHSEdrhods * dsdgrd 

      d2edrhodgrd = d1exLDAdrho*d1FxHSEdgrd + exLDA*d2FxHSEdrhodgrd


      Call V1BCK(DF1000,DF0010,DF2000,DF1010,DF0020,
     &                 RHO,GRD)
      DF1000 = DF1000 + d1exLDAdrho
      DF2000 = DF2000 + d2exLDAdrhodrho

      print *, 'rho=',rho,'grd=',grd
      print *, 'DF1000=',DF1000,d1Edrho,DF1000-d1Edrho
      print *, 'DF0010=',DF0010,d1Edgrd,DF0010-d1Edgrd
      print *, 'DF2000=',DF2000,d2Edrhodrho,DF2000-d2Edrhodrho
      print *, 'DF0020=',DF0020,d2Edgrddgrd,DF0020-d2Edgrddgrd
      print *, 'DF1010=',DF1010,d2Edrhodgrd,DF1010-d2Edrhodgrd

!debug LDA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      if(rhom .ge. 0.d0) then 
!!      central 2nd-order approximation
!       d2FxHSEdrhodrho = (FxHSEp0 - 2.d0*FxHSE + FxHSEm0)/h2
!      else 
!!      forward 1st-order approximation
!       rhopp = rho + 2.d0*h
!       rhopp13 = rhopp**(1.d0/3.d0)
!       CALL EDRC(FxHSEpp0,rhopp,rhopp13)
!       d2FxHSEdrhodrho = (FxHSEpp0 -2.d0*FxHSEp0 + FxHSE)/h2
!      endif
!      d2edrhodrho   = d2FxHSEdrhodrho
!      d2edgrddgrd   = 0.d0
!      d2edrhodgrd   = 0.d0
!!      print *,'VSRXPBERF: d2edrhodrho=',d2edrhodrho
!!      print *,'VSRXPBERF: d2exLDAdrhodrho=',d2exLDAdrhodrho
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      endif

      RETURN
      END
C------------------------------------------------------------------
      Subroutine FxB(Rho,s,Omega,Fx)
C     for debug
C------------------------------------------------------------------
      implicit none
      
      double precision Rho,s,Omega,Fx
      double precision EXLDA, BECKI, RHO13, kF, RHOGRD, pi

C     constants
      pi = 3.141592653589793d0

      RHO13 = RHO**(1.d0/3.d0)
      kF = (3.d0*(pi**2)*rho)**(1.d0/3.d0)
      RHOGRD = s*(2.d0*kF*RHO)

      call EDRC(EXLDA,RHO,RHO13) 
      call EBCK(BECKI,RHO,RHO13,RHOGRD)
   
      Fx = 1.d0 + BECKI/EXLDA

      return 
      end
C------------------------------------------------------------------
      Subroutine HSEFx(Rho,s,Omega,FxHSE)
C------------------------------------------------------------------
C    Short-range exchange PBE enhancement factor
C    from Heyd and Scuseria, JCP 120, 7274 (2004)
C
C    The Erfc function is approximated instead of the PBE exchange hole
C    to perform the integration over r12
C
C    routine taken from PhD thesis of J. Heyd
C    modified by J. Toulouse:
C    gexp  -> dexp
C    gerf  -> derf
C    gerfc -> derfc
C    gei(x)-> ei
C
C    Should be the same as wpbe_analytical_erfc_approx
C------------------------------------------------------------------
      Implicit Real*8(A-H,O-Z)
      Real*8 rho,s,omega,Fxhse
C
      Real*8 A,B,C,D,E
      Real*8 Ha1,Ha2,Ha3,Ha4,Ha5
      Real*8 Fc1,Fc2
      Real*8 ea1,ea2,ea3,ea4,ea5,ea6,ea7,ea8,eb1,wcut
      Real*8 EGscut,EGa1,EGa2,EGa3
      Real*8 expcut,exei1,exei2,exei3,exei4
      Real*8 smax,strans,sconst
C
      Real*8 Zero,One,Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten
      Real*8 FIfteen,Sixteen
      Real*8 r12,r64,r36,r81,r256,r384
      Real*8 r18,r20,r25,r27,r128,r144,r288,r324,r729
      Real*8 r30,r32,r75,r243,r2187,r6561,r40,r105,r54,r135
      Real*8 r1215,r15309
      Real*8 f12,f14,f32,f34,f94,f98,f1516
C
      Save A,B,C,D,E
      Save Ha1,Ha2,Ha3,Ha4,Ha5
      Save Fc1,Fc2
      Save ea1,ea2,ea3,ea4,ea5,ea6,ea7,ea8,wcut
      Save EGscut,EGa1,EGa2,EGa3
      Save expcut,exei1,exei2,exei3,exei4
      Save smax,strans,sconst
      Save Zero,One,Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten
      Save Fifteen,Sixteen
      Save r36,r64,r81,r256,r384
      Save r27,r128,r144,r288,r324,r729
      Save r18,r20,r32,r243,r2187,r6561,r40
      Save r12,r25,r30,r54,r75,r105,r135,r1215,r15309
      Save f12,f14,f32,f34,f94,f98,f1516
C
C         Constants for PBE hole
C

      Data A,B,C,D,E
     $     / 1.0161144D0,-3.7170836D-1,-7.7215461D-2,
     $        5.7786348D-1,-5.1955731D-2 /
C
C         Constants for fit of H(s) (PBE hole)
C
      Data Ha1,Ha2,Ha3,Ha4,Ha5
     $     / 9.79681d-3,4.10834d-2,1.87440d-1,1.20824d-3,3.47188d-2 /
C
C         Constants for F(H) (PBE hole)
C
      Data Fc1,Fc2 / 6.4753871d0,4.7965830d-1 /
C
C         Constants for expansion of erfc(x) (eb1 set later
C         depending on wcut)
C
      Data ea1,ea2,ea3,ea4,ea5,ea6,ea7,ea8,wcut
     $     / -1.128223946706117d0,1.452736265762971d0,
     $        -1.243162299390327d0,0.971824836115601d0,
     $        -0.568861079687373d0,0.246880514820192d0,
     $        -0.065032363850763d0,0.008401793031216d0,1.4D1 /
C
C         Constants for polynomial expansion of EG for small s
C
      Data EGscut,EGa1,EGa2,EGa3
     $     / 8.0d-2,-2.628417880d-2,-7.117647788d-2,8.534541323d-2 /
C
C         Constants for large x expansion of exp(x)*ei(-x)
C
      Data expcut,exei1,exei2,exei3,exei4
     $     / 7.0D2,4.03640D0,1.15198D0,5.03627D0,4.19160D0 /
C
C         Constants for enforcement of local Lieb-Oxford bound
C
      Data smax,strans,sconst
     $     / 8.572844D0,8.3D0,1.879622316D1 /
C
C         Whole numbers used during evaluation
C
      Data Zero,One,Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten
     $     / 0D0,1D0,2D0,3D0,4D0,5D0,6D0,7D0,8D0,9D0,10D0 /
      Data FIfteen,Sixteen / 1.5D1, 1.6D1 /
      Data r36,r64,r81,r256,r384
     $     / 3.6D1,6.4D1,8.1D1,2.56D2,3.84D2 /
      Data r27,r128,r144,r288,r324,r729
     $         / 2.7D1,1.28D2,1.44D2,2.88D2,3.24D2,7.29D2 /
      Data r18,r20,r32,r243,r2187,r6561,r40
     $         / 1.8d1,2.0d1,3.2D1,2.43D2,2.187D3,6.561D3,4.0d1 /
      Data r12,r25,r30,r54,r75,r105,r135,r1215,r15309
     $         / 1.2D1,2.5d1,3.0d1,5.4D1,7.5d1,1.05D2,1.35D2,1.215D3,
     $            1.5309D4 /
C
C         Fractions used during evaluation
C
      Data f12,f14,f32,f34,f94,f98,f1516
     $         / 0.5D0,0.25D0,1.5D0,0.75D0,2.25D0,1.125D0,0.9375D0 /
C
C         General constants
C
          f13      = One/Three
          pi       = ACos(-One)
          pi2      = pi*pi
          srpi = sqrt(pi)
          X        = -Eight/Nine
C
C         Cutoff criterion to enforce local Lieb-Oxford bound
C         This ensures that the enhancement factor does not exceed the
C         one of the original PBE functional (Fx(max)=1.804).
C
          sreal               = s
          If(s.gt.strans) then
               s = smax-(sconst/sreal**2)
               stra1s = Two*sconst/sreal**3
          else
               stra1s = One
          endIf
C
C    Calculate prelim variables
C
      xkf      = (Three*pi2*rho) ** f13
      A2      = A*A
      A3      = A2*A
      A4      = A3*A
      A12     = Sqrt(A)
      A32     = A12*A
      A52     = A32*A
      w       = omega / xkf
      w2      = w * w
      w3      = w2 * w
      w4      = w2 * w2
      w5      = w3 * w2
      w6      = w5 * w
      w7      = w6 * w
      w8      = w7 * w
      s2      = s*s
      s3      = s2*s
      s4      = s2*s2
      s5      = s4*s
      s6      = s5*s
C
C    Calculate H(s) and F(H(s)) for the PBE hole
C
      Hnum    = Ha1*s2 + Ha2*s4
      Hden    = One + Ha3*s4 + Ha4*s5 + Ha5*s6
      H        = Hnum/Hden
      Hnu1s = Two*Ha1*s + Four*Ha2*s3
      Hde1s = Four*Ha3*s3 + Five*Ha4*s4 + Six*Ha5*s5
      H1s      = (Hden*Hnu1s - Hnum*Hde1s) / (Hden*Hden)
      F        = Fc1*H + Fc2
C
C    Set exponent of Gaussian in approx depending on which approx
C    we use for erfc(x)
C
      If(w .lt. wcut) then
          eb1 = 1.455915450052607d0
      else
          eb1 = 2.0d0
      endIf
C
C    Calculate helper variables
C
      Hsbw = s2*H + eb1*w2
      Hsbw2     = Hsbw*Hsbw
      Hsbw3     = Hsbw2*Hsbw
      Hsbw4     = Hsbw3*Hsbw
      Hsbw6     = Hsbw3*Hsbw3
      Hsbw12 = Sqrt(Hsbw)
      Hsbw32 = Hsbw12*Hsbw
      Hsbw52 = Hsbw32*Hsbw
      Hsbw72 = Hsbw52*Hsbw
      DHsb      = D + s2*H + eb1*w2
      DHsb2     = DHsb*DHsb
      DHsb3     = DHsb2*DHsb
      DHsb4     = DHsb3*DHsb
      DHsb5     = DHsb4*DHsb
      DHsb12 = Sqrt(DHsb)
      DHsb32 = DHsb12*DHsb
      DHsb52 = DHsb32*DHsb
      DHsb72 = DHsb52*DHsb
      DHsb92 = DHsb72*DHsb
      HA94     = f94 * Hsbw / A
      HA942    = HA94*HA94
      HA943    = HA942*HA94
      HA945    = HA943*HA942
      HA9412 = Sqrt(HA94)
      DHs      = D + s2*H
      DHs2     = DHs*DHs
      DHs3     = DHs2*DHs
      DHs4     = DHs3*DHs
      DHs72    = DHs3*sqrt(DHs)
      DHs92    = DHs72*DHs
      DHsw     = DHs + w2
      DHsw2    = DHsw*DHsw
      DHsw52 = sqrt(DHsw)*DHsw2
      DHsw72 = DHsw52*DHsw
C
C         Calculate EG(s), using expansion for small s If necessary
C
          If(s .gt. EGscut) then
           G_a     = srpi * (FIfteen*E + Six*C*(One+F*s2)*DHs +
     $                           Four*B*(DHs2) + Eight*A*(DHs3))
     $                    * (One / (Sixteen * DHs72))
     $                    - f34*pi*sqrt(A) * dexp(f94*H*s2/A) *
     $                          (One - derf(f32*s*sqrt(H/A)))
           G_b     = (f1516 * srpi * s2) / DHs72
           EG      = - (f34*pi + G_a) / G_b
          else
           EG      = EGa1 + EGa2*s2 + EGa3*s4
          endIf
C
C    Calculate the terms needed in any case
C
      tm2      = (DHs2*B + DHs*C + Two*E + DHs*s2*C*F + Two*s2*EG) /
     $               (Two*DHs3)
      tm3      = - w    * (Four*DHsw2*B + Six*DHsw*C + FIfteen*E
     $                         + Six*DHsw*s2*C*F + FIfteen*s2*EG) /
     $                         (Eight*DHs*DHsw52)
      tm4      = - w3 * (DHsw*C + Five*E + DHsw*s2*C*F + Five*s2*EG) /
     $                         (Two*DHs2*DHsw52)
      tm5      = - w5 * (E + s2*EG) / (DHs3*DHsw52)
C
C         Calculate t10 unless that would generate a div. by zero
C
          If((s.gt.0.0d0).or.(w.gt.0.0d0)) then
           t10       = (f12)*A*Log(Hsbw / DHsb)
          endIf
C
C         Calculate exp(x)*f(x) depending on size of x
C
          If(HA94 .lt. expcut) then
           exer      = pi*dexp(HA94)*derfc(HA9412)
           exHA94 = dexp(HA94)
           eiHA94 = ei(-HA94)
           exei      = exHA94*eiHA94
          else
           exer      = pi*(One/(srpi*HA9412)
     $                      - One/(Two*Sqrt(pi*HA943))
     $                      + Three/(Four*Sqrt(pi*HA945)))
           exei      = - (One/HA94) *
     $                      (HA942 + exei1*HA94 + exei2) /
     $                         (HA942 + exei3*HA94 + exei4)
          endIf
C
          If (w .eq. Zero) then
C
C          Fall back to original expression for the PBE hole
C
           t1            = -f12*A*exei
C
           If(s .gt. 0.0D0) then
                  tm1        = t1 + t10
                  Fxhse      = X * (tm1 + tm2)
           else
                  Fxhse      = 1.0d0
           endIf
C
          else If(w .gt. wcut) then
C
C          Use simple Gaussian approximation for large w
C
           tm1             = -f12*A*(exei+log(DHsb)-log(Hsbw))
           Fxhse           = X * (tm1 + tm2 + tm3 + tm4 + tm5)
          else
C
C          For everything else, use the full blown expression
C
C          First, we calculate the polynomials for the first term
C
           pn1             = -f32*ea1*A12*w + r27*ea3*w3/(Eight*A12)
     $                 - r243*ea5*w5/(r32*A32) + r2187*ea7*w7/(r128*A52)
          pn2     = -A + f94*ea2*w2 - r81*ea4*w4/(Sixteen*A)
     $                 + r729*ea6*w6/(r64*A2) - r6561*ea8*w8/(r256*A3)
C
C         The first term is
C
          t1      = f12*(pn1*exer + pn2*exei)
C
C         The factors for the main polynomoal in w
C
          f2      = (f12)*ea1*srpi*A / DHsb12
          f3      = (f12)*ea2*A / DHsb
          f4      =    ea3*srpi*(-f98 / Hsbw12
     $                  + f14*A / DHsb32)
          f5      = ea4*(One/r128) * (-r144*(One/Hsbw)
     $                  + r64*(One/DHsb2)*A)
          f6      = ea5*(Three*srpi*(Three*DHsb52*(Nine*Hsbw-Two*A)
     $                 + Four*Hsbw32*A2))
     $                 / (r32*DHsb52*Hsbw32*A)
          f7      = ea6*(((r32*A)/DHsb3
     $                  + (-r36 + (r81*s2*H)/A)/Hsbw2)) / r32
          f8      = ea7*(-Three*srpi*(-r40*Hsbw52*A3
     $                  +Nine*DHsb72*(r27*Hsbw2-Six*Hsbw*A+Four*A2)))
     $                  / (r128 * DHsb72*Hsbw52*A2)
       f9      = (r324*ea6*eb1*DHsb4*Hsbw*A
     $             + ea8*(r384*Hsbw3*A3 + DHsb4*(-r729*Hsbw2
     $             + r324*Hsbw*A - r288*A2))) / (r128*DHsb4*Hsbw3*A2)
C
          t2t9    = f2*w     + f3*w2 + f4*w3 + f5*w4 + f6*w5
     $                 + f7*w6 + f8*w7 + f9*w8
C
C     The final value of term1 for 0 < omega < wcut is:
C
      tm1     = t1 + t2t9 + t10
C
C     The final value for the enhancement factor is
C
      Fxhse = X * (tm1 + tm2 + tm3 + tm4 + tm5)
      endIf
C
      end

C------------------------------------------------------------------
      subroutine wpbe_analytical(rho,s,omega,Fx_wpbe)
C------------------------------------------------------------------
C    Short-range exchange PBE enhancement factor
C    from Heyd, Scuseria, Ernzerhof, JCP 118, 8207 (2003)
C
C    The PBE exchange hole is approximated to perform the integration
C    over r12
C    
c    'wPBE Enhancement Factor (analytical, no gradients)'
C    routine from J. Heyd
C
C    Gives sligthly different results compared to wpbe_analytical_erfc_approx
c--------------------------------------------------------------------
      Implicit None

      Real*8 rho,s,omega,Fx_wpbe

      Real*8 f12,f13,f14,f18,f23,f43,f32,f72,f34,f94,f1516
      Real*8 pi,pi2,pi_23,srpi
      Real*8 Three_13
    
      Real*8 fa1,fa2,fa3,fa4,fa5
      Real*8 fb1,fb2,fb3,fb4,fb5
      Real*8 A,B,C,D,E
      Real*8 Ha1,Ha2,Ha3,Ha4,Ha5
      Real*8 Fc1,Fc2
      Real*8 EGa1,EGa2,EGa3
      Real*8 EGscut

      Real*8 xkf, xkfrho
      Real*8 wk,wk2,wk3,wk5
      Real*8 X
      Real*8 s2,s4

      Real*8 H,xF,C_0,H_0,DH_0,DH_072
      Real*8 aDH,aDH2,aDHwk2,sraDH,sraDH2,sraDH3,sraDH5
      Real*8 G_a,G_b,EG,E_0

      Real*8 ab1H,srab1H,ab2H,srab2H,b3H,srb3H,srb3H3
      Real*8 b4H,srb4H,srb4H3,ab5H,srab5H,srb5H3

      Real*8 atb3H,atb4H

      Real*8 term1,term2,term3,term4,term5,term6,term7,term8

      Real*8 ax,um,uk,ul
      Real*8 gc1,gc2

      Real*8 derf

      Real*8 One,Two,Three,Four,Six,Eight,Nine,Ten
      Real*8 Fifteen,Sixteen

      Save One,Two,Three,Four,Six,Eight,Nine,Ten
      Data One,Two,Three,Four,Six,Eight,Nine,Ten
     $  / 1D0,2D0,3D0,4D0,6D0,8D0,9D0,10D0 /
      Save Fifteen,Sixteen
      Data Fifteen,Sixteen / 1.5D1, 1.6D1 /

c     General constants

      f12    = 0.5d0
      f13    = One/Three
      f14    = 0.25d0
      f18    = 0.125d0

      f23    = Two * f13
      f43    = Two * f23

      f32    = 1.5d0
      f72    = 3.5d0
      f34    = 0.75d0
      f94    = 2.25d0
      f1516  = Fifteen / Sixteen

      pi     = ACos(-One)
      pi2    = pi*pi
      pi_23  = pi2**f13
      srpi   = sqrt(pi)

      Three_13 = Three**f13

c     Constants from fit

      fa1    = 2.054837628d-4
      fa2    = 1.094652397d-1
      fa3    = 6.407879991d-2
      fa4    = 8.181734694d-3
      fa5    = 1.106664933d-4

      fb1    = 6.601358926d-3
      fb2    = 2.599311408d-1
      fb3    = 5.203522409d-1
      fb4    = 1.185510426d-1
      fb5    = 4.600377701d-2

c     Constants for PBE hole

      A      =  1.0161144d0
      B      = -3.7170836d-1
      C      = -7.7215461d-2
      D      =  5.7786348d-1
      E      = -5.1955731d-2
      X      = - Eight/Nine

c     Constants for fit of H(s) (PBE)

      Ha1    = 9.79681d-3
      Ha2    = 4.10834d-2
      Ha3    = 1.87440d-1
      Ha4    = 1.20824d-3
      Ha5    = 3.47188d-2

c     Constants for F(H) (PBE)

      Fc1    = 6.4753871d0
      Fc2    = 4.7965830d-1

c     Constants for polynomial expansion for EG for small s

      EGa1   = -2.628417880d-2
      EGa2   = -7.117647788d-2
      EGa3   =  8.534541323d-2

c     Cutoff criterion below which to use polynomial expansion

      EGscut =  8.0d-2

c     Constants for LDA and PBE (from paper)

      ax     = -0.930525736348d0
      um     = 0.2195149727645171d0
      uk     = 0.8040d0
      ul     = um/uk

c     Constants for PBE (from Gaussian99)

      gc1    = 0.00336116d0
      gc2    = 0.00449267d0

c     Calculate the wPBE enhancement factor

      xkf    = (Three*pi2*rho) ** f13
      xkfrho = xkf * rho

      wk     = omega / xkf
      wk2    = wk * wk
      wk3    = wk2 * wk
      wk5    = wk3 * wk2

      X      = - Eight/Nine

      s2     = s*s
      s4     = s2*s2

c     Calculate wPBE enhancement factor

      H      = (Ha1*s2 + Ha2*s4) /
     1         (One + Ha3*s4 + Ha4*s4*s + Ha5*s4*s2)

      xF     = Fc1*H + Fc2

      C_0    = C * (One + s2*xF)
      H_0    = s2 * H
      DH_0   = D + H_0
      DH_072 = DH_0**f72

      aDH    = wk2 + D + H_0
      aDH2   = aDH*aDH
      aDHwk2 = aDH - wk2
      sraDH  = sqrt(aDH)
      sraDH2 = sraDH*sraDH
      sraDH3 = sraDH2*sraDH
      sraDH5 = sraDH2*sraDH3

      if(s .gt. EGscut) then

        G_a    = srpi * (Fifteen*E + Six*C_0*DH_0 +
     1                   Four*B*(DH_0**2) + Eight*A*(DH_0**3))
     2                * (One / (Sixteen * DH_072))
     3                 - f34*pi*sqrt(A) * exp(f94*H_0/A) *
     4                   (One - derf(f32*s*sqrt(H/A)))

        G_b    = (f1516 * srpi * s2) / DH_072

        EG     = - (f34*pi + G_a) / G_b

      else

        EG = EGa1 + EGa2*s2 + EGa3*s4

      endif

      E_0    = E + s2*EG

      ab1H   = wk2 + fb1 + H_0
      srab1H = sqrt(ab1H)
      ab2H   = wk2 + fb2 + H_0
      srab2H = sqrt(ab2H)
      b3H    = fb3 + H_0
      srb3H  = sqrt(b3H)
      srb3H3 = srb3H*srb3H*srb3H
      b4H    = fb4 + H_0
      srb4H  = sqrt(b4H)
      srb4H3 = srb4H*srb4H*srb4H
      ab5H   = wk2 + fb5 + H_0
      srab5H = sqrt(ab5H)
      srb5H3 = srab5H*srab5H*srab5H

      term1  = f12 * (fa1 * (wk - srab1H)) /
     1               (srab1H * (wk2 - ab1H))

      term2  = f12 * (fa2 * (wk - srab2H)) /
     1               (srab2H * (ab2H - wk2))

      atb3H  = atan(srb3H / wk)

      term3  = f12 * (fa3 * (atb3H*wk2 + atb3H*b3H - wk*srb3H)) /
     1               (srpi*srb3H3*(wk2 + b3H))

      atb4H  = atan(srb4H / wk)

      term4  = f12 * (fa4 * (atb4H*wk2 + atb4H*b4H - wk*srb4H)) /
     1               (srpi*srb4H3*(wk2 + b4H))

      term5  = f14 * (fa5 * (wk3 - Three*ab5H*wk + Two*srb5H3)) / 
     1               (srb5H3 * (wk2 - ab5H)**2)

      term6  = f12 * (B * (wk - sraDH)) / 
     1               (sraDH * aDHwk2)

      term7  = f14 * (C_0 * (Three*aDH*wk - wk3 - Two*sraDH3)) /
     1               (sraDH3 * aDHwk2**2)

      term8  = f18 * (E_0 * (Ten*aDH*wk3 - Three*wk5 -
     1               Fifteen*aDH2*wk + Eight*sraDH5)) /
     1               (sraDH5 * aDHwk2**3) 

      Fx_wpbe = X * (-term1 + term2 - term3 - term4 - term5 -
     1                term6 - term7 + term8)

      end

C------------------------------------------------------------------
      subroutine wpbe_analytical_erfc_approx(rho,s,omega,Fx_wpbe)
C------------------------------------------------------------------
C    Short-range exchange PBE enhancement factor
C    from Heyd and Scuseria, JCP 120, 7274 (2004)
C
C    The Erfc function is approximated instead of the PBE exchange hole
C    to perform the integration over r12
C    
c    'wPBE Enhancement Factor (erfc approx.,analytical, no gradients)'
C    routine from J. Heyd
C
C    It is the preferred routine. Should be the same as HSEFx
c--------------------------------------------------------------------
      Implicit None

      Real*8 rho,s,omega,Fx_wpbe

      Real*8 f12,f13,f14,f18,f23,f43,f32,f72,f34,f94,f1516,f98
      Real*8 pi,pi2,pi_23,srpi
      Real*8 Three_13
    
      Real*8 ea1,ea2,ea3,ea4,ea5,ea6,ea7,ea8
      Real*8 eb1
      Real*8 A,B,C,D,E
      Real*8 Ha1,Ha2,Ha3,Ha4,Ha5
      Real*8 Fc1,Fc2
      Real*8 EGa1,EGa2,EGa3
      Real*8 EGscut,wcutoff,expfcutoff

      Real*8 xkf, xkfrho
      Real*8 w,w2,w3,w4,w5,w6,w7,w8
      Real*8 A2,A3,A4,A12,A32,A52,A72
      Real*8 X
      Real*8 s2,s3,s4,s5,s6

      Real*8 H,xF,C_0,H_0,DH_0,DH_072
      Real*8 aDH,aDH2,aDHw2,sraDH,sraDH2,sraDH3,sraDH5
      Real*8 G_a,G_b,EG,E_0

      Real*8 Hsbw,Hsbw2,Hsbw3,Hsbw12,Hsbw32,Hsbw52
      Real*8 DHsbw,DHsbw2,DHsbw3,DHsbw4
      Real*8 DHsbw12,DHsbw32,DHsbw52,DHsbw72
      Real*8 HsbwA94,HsbwA9412
      Real*8 HsbwA942,HsbwA943,HsbwA945
      Real*8 experf,expei
      Real*8 expei1,expei2,expei3,expei4

      Real*8 np1,np2
      Real*8 factor1,t1,t2f1,t3f1,t4f1,t9,t10f1
      Real*8 t5f1,t6f1,t7f1,t8f1,t9f1

      Real*8 atb3H,atb4H

      Real*8 term1,term2,term3,term4
c     Real*8 term1p,p0,p1,p2,p3,p4,p5,p6,p7,p8

      Real*8 ax,um,uk,ul
      Real*8 gc1,gc2

      Real*8 derf,derfc,ei,fexpei

      Real*8 Zero,One,Two,Three,Four,Six,Eight,Nine,Ten
      Real*8 Fifteen,Sixteen
      Real*8 r64,r36,r81,r256,r384,r864,r1944,r4374
      Real*8 r27,r48,r120,r128,r144,r288,r324,r512,r729
      Real*8 r32,r243,r2187,r6561,r40

      Save Zero,One,Two,Three,Four,Six,Eight,Nine,Ten
      Data Zero,One,Two,Three,Four,Six,Eight,Nine,Ten
     $  / 0D0,1D0,2D0,3D0,4D0,6D0,8D0,9D0,10D0 /
      Save Fifteen,Sixteen
      Data Fifteen,Sixteen / 1.5D1, 1.6D1 /
      Save r36,r64,r81,r256,r384,r864,r1944,r4374
      Data r36,r64,r81,r256,r384,r864,r1944,r4374
     $  / 3.6D1,6.4D1,8.1D1,2.56D2,3.84D2,8.64D2,1.944D3,4.374D3 /
      Save r27,r48,r120,r128,r144,r288,r324,r512,r729
      Data r27,r48,r120,r128,r144,r288,r324,r512,r729
     $  / 2.7D1,4.8D1,1.2D2,1.28D2,1.44D2,2.88D2,3.24D2,5.12D2,7.29D2 /
      Save r32,r243,r2187,r6561,r40
      Data r32,r243,r2187,r6561,r40
     $  / 3.2D1,2.43D2,2.187D3,6.561D3,4.0d1 /

c     General constants

      f12    = 0.5d0
      f13    = One/Three
      f14    = 0.25d0
      f18    = 0.125d0

      f23    = Two * f13
      f43    = Two * f23

      f32    = 1.5d0
      f72    = 3.5d0
      f34    = 0.75d0
      f94    = 2.25d0
      f98    = 1.125d0
      f1516  = Fifteen / Sixteen

      pi     = ACos(-One)
      pi2    = pi*pi
      pi_23  = pi2**f13
      srpi   = sqrt(pi)

      Three_13 = Three**f13

c     Constants from fit

      ea1 = -1.128223946706117d0
      ea2 = 1.452736265762971d0
      ea3 = -1.243162299390327d0
      ea4 = 0.971824836115601d0
      ea5 = -0.568861079687373d0
      ea6 = 0.246880514820192d0
      ea7 = -0.065032363850763d0
      ea8 = 0.008401793031216d0

      eb1 = 1.455915450052607d0

c     Constants for PBE hole

      A      =  1.0161144d0
      B      = -3.7170836d-1
      C      = -7.7215461d-2
      D      =  5.7786348d-1
      E      = -5.1955731d-2
      X      = - Eight/Nine

c     Constants for fit of H(s) (PBE)

      Ha1    = 9.79681d-3
      Ha2    = 4.10834d-2
      Ha3    = 1.87440d-1
      Ha4    = 1.20824d-3
      Ha5    = 3.47188d-2

c     Constants for F(H) (PBE)

      Fc1    = 6.4753871d0
      Fc2    = 4.7965830d-1

c     Constants for polynomial expansion for EG for small s

      EGa1   = -2.628417880d-2
      EGa2   = -7.117647788d-2
      EGa3   =  8.534541323d-2

c     Constants for large x expansion of exp(x)*ei(-x)

      expei1 = 4.03640D0
      expei2 = 1.15198D0
      expei3 = 5.03627D0
      expei4 = 4.19160D0

c     Cutoff criterion below which to use polynomial expansion

      EGscut     = 8.0d-2
      wcutoff    = 1.4D1
      expfcutoff = 7.0D2

c     Calculate prelim variables

      xkf    = (Three*pi2*rho) ** f13
      xkfrho = xkf * rho

      A2 = A*A
      A3 = A2*A
      A4 = A3*A
      A12 = Sqrt(A)
      A32 = A12*A
      A52 = A32*A
      A72 = A52*A

      w      = omega / xkf
      w2    = w * w
      w3    = w2 * w
      w4    = w2 * w2
      w5    = w3 * w2
      w6    = w5 * w
      w7    = w6 * w
      w8    = w7 * w

      X      = - Eight/Nine

      s2     = s*s
      s3     = s2*s
      s4     = s2*s2
      s5     = s4*s
      s6     = s5*s

c     Calculate wPBE enhancement factor

      H      = (Ha1*s2 + Ha2*s4) /
     1         (One + Ha3*s4 + Ha4*s4*s + Ha5*s4*s2)

      xF     = Fc1*H + Fc2

      C_0    = C * (One + s2*xF)
      H_0    = s2 * H
      DH_0   = D + H_0
      DH_072 = DH_0**f72

      aDH    = w2 + D + H_0
      aDH2   = aDH*aDH
      aDHw2  = aDH - w2
      sraDH  = sqrt(aDH)
      sraDH2 = sraDH*sraDH
      sraDH3 = sraDH2*sraDH
      sraDH5 = sraDH2*sraDH3

      if(s .gt. EGscut) then

        G_a    = srpi * (Fifteen*E + Six*C_0*DH_0 +
     1                   Four*B*(DH_0**2) + Eight*A*(DH_0**3))
     2                * (One / (Sixteen * DH_072))
     3                 - f34*pi*sqrt(A) * exp(f94*H_0/A) *
     4                   (One - derf(f32*s*sqrt(H/A)))

        G_b    = (f1516 * srpi * s2) / DH_072

        EG     = - (f34*pi + G_a) / G_b

      else

        EG = EGa1 + EGa2*s2 + EGa3*s4

      endif

      E_0    = E + s2*EG

c     Change exponent of Gaussian if we're using the simple approx.

      if(w .gt. wcutoff) then

        eb1 = 2.0d0

      endif

c     Calculate helper variables (should be moved later on...)

      Hsbw = s2*H + eb1*w2
      Hsbw2 = Hsbw*Hsbw
      Hsbw3 = Hsbw2*Hsbw
      Hsbw12 = Sqrt(Hsbw)
      Hsbw32 = Hsbw12*Hsbw
      Hsbw52 = Hsbw32*Hsbw
      
      DHsbw = D + s2*H + eb1*w2
      DHsbw2 = DHsbw*DHsbw
      DHsbw3 = DHsbw2*DHsbw
      DHsbw4 = DHsbw3*DHsbw
      DHsbw12 = Sqrt(DHsbw)
      DHsbw32 = DHsbw12*DHsbw
      DHsbw52 = DHsbw32*DHsbw
      DHsbw72 = DHsbw52*DHsbw
      
      HsbwA94   = f94 * Hsbw / A
      HsbwA942  = HsbwA94*HsbwA94
      HsbwA943  = HsbwA942*HsbwA94
      HsbwA945  = HsbwA943*HsbwA942
      HsbwA9412 = Sqrt(HsbwA94)

c    Calculate the terms needed in any case

      term2  = f12 * (B * (w - sraDH)) / 
     1               (sraDH * aDHw2)

      term3  = f14 * (C_0 * (Three*aDH*w - w3 - Two*sraDH3)) /
     1               (sraDH3 * aDHw2**2)

      term4  = f18 * (E_0 * (Ten*aDH*w3 - Three*w5 -
     1               Fifteen*aDH2*w + Eight*sraDH5)) /
     2               (sraDH5 * aDHw2**3) 


      t10f1 = (f12)*A*Log(Hsbw / DHsbw)

c     Calculate exp(x)*f(x) depending on size of x

      if(HsbwA94 .lt. expfcutoff) then

        experf = Exp(HsbwA94)*dErfc(HsbwA9412)
        expei  = Exp(HsbwA94)*Ei(-HsbwA94)

      else

c       print *,rho,s," LARGE HsbwA94"

        experf = One/(srpi*HsbwA9412) 
     1           - One/(Two*Sqrt(pi*HsbwA943))
     2           + Three/(Four*Sqrt(pi*HsbwA945))

        expei  = - (One/HsbwA94) *
     1             (HsbwA942 + expei1*HsbwA94 + expei2) /
     2             (HsbwA942 + expei3*HsbwA94 + expei4)

      endif

      if (w .eq. Zero) then

c       Fall back to original expression for the PBE hole

        t1 = -f12*A*expei

        if(s .gt. 0.0D0) then

          t10f1 = (f12)*A*(Log(Hsbw) - Log(DHsbw))

          term1 = t1 + t10f1

          Fx_wpbe = X * (term1 - term2 - term3 + term4)

        else

c         term1 = f12*A* -8.23742D-1

          Fx_wpbe = 1.0d0

        endif


      elseif(w .gt. wcutoff) then

c       Use simple Gaussian approximation for large w

c       print *,rho,s," LARGE w"

        term1 = -f12*A*(expei+log(DHsbw)-log(Hsbw))

c       Fx_wpbe = X * (term1 - term2 - term3 + term4)
        Fx_wpbe = term1

      else

c       For everything else, use the full blown expression

        np1 = -f32*ea1*A12*w + r27*ea3*w3/(Eight*A12)
     $        - r243*ea5*w5/(r32*A32) + r2187*ea7*w7/(r128*A52)

        np2 = -A + f94*ea2*w2 - r81*ea4*w4/(Sixteen*A)
     $        + r729*ea6*w6/(r64*A2) - r6561*ea8*w8/(r256*A3)


        t1 = f12*(np1*pi*experf + np2*expei)

        factor1 = One / (r128*DHsbw4*Hsbw3*A2)
        
        t2f1 = (f12)*ea1*srpi*A*w / DHsbw12
        
        t3f1 = (f12)*ea2*A*w2 / DHsbw
        
        t4f1 = srpi*(-f98*ea3 / Hsbw12 
     $           + f14*ea3*A / DHsbw32)*w3
        
        t5f1 = (One/r128) * (-r144*(One/Hsbw) 
     $        + r64*(One/DHsbw2)*A)*ea4*w4
        
        t6f1 = (Three*ea5*srpi*(Three*DHsbw52*(Nine*Hsbw-Two*A)
     $           + Four*Hsbw32*A2) * w5)
     $           / (r32*DHsbw52*Hsbw32*A)
        
        t7f1 = (ea6*((r32*A)/DHsbw3
     $         + (-r36 + (r81*s2*H)/A)/Hsbw2) * w6) / r32
        
        t8f1 = (-Three*ea7*srpi*(-r40*Hsbw52*A3
     $          +Nine*DHsbw72*(r27*Hsbw2-Six*Hsbw*A+Four*A2)) * w7)
     $         / (r128 * DHsbw72*Hsbw52*A2)
        
        t9 = (r324*ea6*eb1*DHsbw4*Hsbw*A 
     $        + ea8*(r384*Hsbw3*A3 + DHsbw4*(-r729*Hsbw2
     $        + r324*Hsbw*A - r288*A2)))*w8
      
c       The final value of term1 for 0 < omega < wcutoff is:

        term1 = t1 + t2f1 + t3f1 + t4f1 + t5f1 + t6f1 + t7f1 + t8f1
     $             + factor1*t9 + t10f1

        Fx_wpbe = X * (term1 - term2 - term3 + term4)
c       Fx_wpbe = term1

      endif

      end

C****************************************************************************
      subroutine ECPBE(rho,grd,e)
C*****************************************************************************
C     PBE correlation functional
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision pi, pi2
      double precision rho13, eLDA, epsLDA
      double precision gam, bet
      double precision kF, ks, t, t2
      double precision A, At2
      double precision frac, H

C     General constants
      parameter ( pi = 3.141592653589793d0 )
      parameter ( pi2 = 9.869604401089358d0 )
C     PBE constants
      parameter (gam = 0.031090690869654897d0)
      parameter (bet = 0.066725d0)

C     LDA energy
      rho13 = rho**(1.d0/3.d0)
      call EVWN(eLDA,rho,rho13)
      epsLDA = eLDA/rho

      A = dexp(-epsLDA/gam) - 1.d0

      if (abs(A) .lt. 1.0d-14) then
         H = 0.0d0
      else
         A = (bet/gam)/A
      
         kF = (3.d0*pi2*rho)**(1.d0/3.d0)
         ks = dsqrt(4.d0*kF/pi) 
         t = dabs(grd)/(2.d0*ks*rho)
         t2  = t*t
         At2 = A*t2

         frac = 1.d0 + At2
         frac = frac/(frac + At2*At2)
         H = gam*dlog(1.d0+(bet/gam)*t2*frac)
      end if

      e = rho*(epsLDA + H)

      return
      end

C****************************************************************************
      subroutine ECPBE_old(rho,grd,e)
C*****************************************************************************
C     PBE correlation functional (old version)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision rho13
      double precision exLDA
      double precision ecLDA

      double precision drho2
      double precision t1, bPBE

C     LDA energy
      rho13 = rho**(1.d0/3.d0)
      call EDRC(exLDA,rho,rho13)
      call EVWN(ecLDA,rho,rho13)

!     square of density gradient 
      drho2 = grd*grd

      bPBE = 0.21951d0

!     Code generated by Mathematica
C     Energy
       t1 = 9.869604401089358618834491d0*ecLDA + 3.068528194400546905
     & 827679d-1*rho*dlog(1.d0 - (8.401605835889726292406297d-1*drho2*
     &  exLDA*bPBE*
     &  rho**(-1.1d1/3.d0)*(1.d0 - (8.401605835889726292406297d-1*drho2*
     &  exLDA*bPBE
     &  *rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009
     &  d1*ecLDA)/rho))))/(1.d0 + (7.058698062165630644545894d-1*drho
     &  2**2*exLDA**2*bPBE
     &  **2*rho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.2163968442914
     &  82112072009d1*ecLDA)/rho))**2 - (8.401605835889726292406297d-
     &  1*drho2*exLDA*bPBE
     &  *rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.2163968442914821
     &  12072009d1*ecLDA)/rho))))
       e = 1.013211836423377714438795d-1*t1

      return
      end

C****************************************************************************
      subroutine ESRC_PBERIERF(rho,grd,mu,e)
C*****************************************************************************
C     rational interpolation for short-range erf correlation functional
C     Toulouse, Colonna, Savin PRA 70, 062505 (2004)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision mu2, rs, sqrt2
      double precision d, a, bet, gam
      double precision grs12, expgrs12, g0
      double precision e_pbe, eps_pbe, eps_LDA_fac, mu_ref
      double precision d1, d2, denom, p6, q7, q8, d2od1, mu6

C     General constants
#include "pi.h"
      double precision mu_0, mu_0_m6, mu_0_m7, mu_0_m4
      common /cb_srcpbe_RI/ mu_0, mu_0_m6, mu_0_m7, mu_0_m4

C     Constants for g0
      parameter ( d = 32.D0/(3.D0*pi) )
      parameter ( a = 3.2581D0 )
      parameter ( bet = 163.44D0 )
      parameter ( gam = 4.7125D0 )
      sqrt2 = sqrt(2.0d0)
      
!      print *,'ESRC_PBERIERF: mu=',mu
!      print *,'ESRC_PBERIERF: rho=',rho,' grd=',grd
     

!     Variables
      rs = (3.d0/(4.d0*pi*rho))**(1.d0/3.d0)
      mu2 =mu*mu

!     PBE correlation energy
      call ECPBE(rho,grd,e_pbe)
      if (abs(e_pbe) .lt. 1.0D-15) then
         e = 0.0d0
         return
      end if
      eps_pbe = e_pbe/rho
!      print *,'ESRC_PBERIERF: e_pbe=',e_pbe

!     g0 from Burke, Perdew, Ernzerhof
      grs12 = sqrt(gam+rs)
      expgrs12 = exp(-a*grs12)
      g0 = d*(grs12**3+bet)*expgrs12


C    modified d1 coefficient from Gori-Giorgi and Savin (submitted)
C    added by Emmanuel Fromager 13.12.05    
C      d2 = 2.d0*eps_pbe/(pi*rho*(g0 - 0.5d0))
C      d1 = -2.d0*(d2**2)*sqrtpi*rho*g0/(3.d0*eps_pbe)
Cefr   d1 = -2.d0*(d2**2)*sqrt2*sqrtpi*rho*g0/(3.d0*eps_pbe)
Chjaaj 4-oct-06: this d1 code below gave NaN if eps_pbe .eq. 0.0d0
C                thus the new code
      d2 = 2.d0/(pi*rho*(g0 - 0.5d0))
      d1 = -2.d0*eps_pbe*(d2**2)*sqrt2*sqrtpi*rho*g0/3.d0
      d2 = d2*eps_pbe
      if (mu_0 .eq. 0.0d0) then
         e = e_pbe
      else if (mu_0 .lt. 0.0d0) then
C        using e = e_pbe * ( 1 / (1 + d1*mu + d2*mu^2) )
C        based on the asymptotic Taylor expansion to 3. order
C        eps_LDA_asymptot3 = 1/d2 *  mu^(-2) - d1/(d2^2) * mu^(-3)
         denom = 1.d0 + d1*mu + d2*mu2
         e = e_pbe/denom
      else
C        using e = e_pbe * ( (1 + p6*mu^6) / (1 + q7*mu^7 + q8*mu^8) )
C        based on 
C        1) the asymptotic Taylor expansion to 3. order
C           eps_LDA_asymptot3 = 1/d2 *  mu^(-2) - d1/(d2^2) * mu^(-3)
C        2) the condition that eps(mu) = eps(0) + O(mu^6)
C        2) the condition that eps(mu_0) = eps_LDA_asymptot3(mu_0)
C        4) mu_0 is determined by the inflection point
C           d2(eps_LDA_asymptot3)/dmu^2 : mu_0 = 2 d1/d2
C        (e = eps * rho)
         d2od1 = d2 / d1
C ----- first attempt. fixed mu_0, does not work!!!!
C        p6 = d2od1/d1 * mu_0_m6 - mu_0_m7 / d1 - d2od1**2 * mu_0_m4
c --- second attmpt
C        using mu_ref = alfa * d1/d2:
C        p6 = alfa**(-4) * d2od1**6 * ( alfa**(-3)*(alfa-1.0d0)*d2od1/d1
C        - 1.0d0 )
C        with alfa = 2 (the inflection point):
!        p6 = 0.0625D0 * d2od1**6 * (0.125D0*d2od1/d1 - 1.0D0 )
!        q7 = d1 * p6
!        q8 = d2 * p6
!        mu6 = mu2**3
!        e = e_pbe * (1.0D0 + p6 * mu6)
!    &             / (1.0D0 + mu6 * (q7 * mu + q8 * mu2))
c --- third attmpt
c        mu_ref = alfa * d1/d2 = 2.D0 * d1/d2 ! the inflection point
c        eps_LDA = e_pbe/d2 * ( mu_ref**(-2) - d1od2 * mu_ref**(-3))
c                = e_pbe/d2 * ( 0.25d0 * d2od1**2 - 0.125d0 * d2od1**2)
         mu_ref  = 2.0d0 / d2od1
         if (mu .ge. mu_ref) then
            e = e_pbe/(d2*mu2) * (1.0d0 - d1 / (d2*mu))
         else
c           e_pbe * (1 + p6 * mu_ref**6) =  eps_LDA(mu_ref)
            eps_LDA_fac = 0.125d0/d2 * d2od1**2
            p6 = (eps_LDA_fac - 1.0d0) * d2od1**6 * 0.015625d0
            e = e_pbe * (1.0d0 + p6 * mu2**3)
         end if
      end if

!      print *,'ESRC_PBERIERF: e=',e
      return
      end

C****************************************************************************
      subroutine ESRC_LYPRIERF(rho,grd,mu,e)
C*****************************************************************************
C     rational interpolation for short-range erf correlation functional
C     Toulouse, Colonna, Savin PRA 70, 062505 (2004)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision mu2, rs, sqrt2
      double precision d, a, bet, gam
      double precision grs12, expgrs12, g0, rho13
      double precision e_lyp, eps_lyp, eps_LDA_fac, mu_ref
      double precision d1, d2, denom, p6, q7, q8, d2od1, mu6

C     General constants
#include "pi.h"
      double precision mu_0, mu_0_m6, mu_0_m7, mu_0_m4
      common /cb_srclyp_RI/ mu_0, mu_0_m6, mu_0_m7, mu_0_m4

C     Constants for g0
      parameter ( d = 32.D0/(3.D0*pi) )
      parameter ( a = 3.2581D0 )
      parameter ( bet = 163.44D0 )
      parameter ( gam = 4.7125D0 )
      sqrt2 = sqrt(2.0d0)
      
!      print *,'ESRC_LYPRIERF: mu=',mu
!      print *,'ESRC_LYPRIERF: rho=',rho,' grd=',grd

!     set code for do rational interpolation
      mu_0 = -1.0D0

!     Variables
      rs = (3.d0/(4.d0*pi*rho))**(1.d0/3.d0)
      mu2 =mu*mu

!     LYP correlation energy
      RHO13 = RHO**(1.0D0/3.0D0)
      CALL ELYP(e_lyp,rho,RHO13,grd)
      if (abs(e_lyp) .lt. 1.0D-15) then
         e = 0.0d0
         return
      end if
      eps_lyp = e_lyp/rho
!      print *,'ESRC_LYPRIERF: e_lyp=',e_lyp

!     g0 from Burke, Perdew, Ernzerhof
      grs12 = sqrt(gam+rs)
      expgrs12 = exp(-a*grs12)
      g0 = d*(grs12**3+bet)*expgrs12


C    modified d1 coefficient from Gori-Giorgi and Savin (submitted)
C    added by Emmanuel Fromager 13.12.05    
C      d2 = 2.d0*eps_lyp/(pi*rho*(g0 - 0.5d0))
C      d1 = -2.d0*(d2**2)*sqrtpi*rho*g0/(3.d0*eps_lyp)
Cefr   d1 = -2.d0*(d2**2)*sqrt2*sqrtpi*rho*g0/(3.d0*eps_lyp)
Chjaaj 4-oct-06: this d1 code below gave NaN if eps_lyp .eq. 0.0d0
C                thus the new code
      d2 = 2.d0/(pi*rho*(g0 - 0.5d0))
      d1 = -2.d0*eps_lyp*(d2**2)*sqrt2*sqrtpi*rho*g0/3.d0
      d2 = d2*eps_lyp
      if (mu_0 .eq. 0.0d0) then
         e = e_lyp
      else if (mu_0 .lt. 0.0d0) then
C        using e = e_lyp * ( 1 / (1 + d1*mu + d2*mu^2) )
C        based on the asymptotic Taylor expansion to 3. order
C        eps_LDA_asymptot3 = 1/d2 *  mu^(-2) - d1/(d2^2) * mu^(-3)
         denom = 1.d0 + d1*mu + d2*mu2
         e = e_lyp/denom
      else
C        using e = e_lyp * ( (1 + p6*mu^6) / (1 + q7*mu^7 + q8*mu^8) )
C        based on 
C        1) the asymptotic Taylor expansion to 3. order
C           eps_LDA_asymptot3 = 1/d2 *  mu^(-2) - d1/(d2^2) * mu^(-3)
C        2) the condition that eps(mu) = eps(0) + O(mu^6)
C        2) the condition that eps(mu_0) = eps_LDA_asymptot3(mu_0)
C        4) mu_0 is determined by the inflection point
C           d2(eps_LDA_asymptot3)/dmu^2 : mu_0 = 2 d1/d2
C        (e = eps * rho)
         d2od1 = d2 / d1
C ----- first attempt. fixed mu_0, does not work!!!!
C        p6 = d2od1/d1 * mu_0_m6 - mu_0_m7 / d1 - d2od1**2 * mu_0_m4
c --- second attmpt
C        using mu_ref = alfa * d1/d2:
C        p6 = alfa**(-4) * d2od1**6 * ( alfa**(-3)*(alfa-1.0d0)*d2od1/d1
C        - 1.0d0 )
C        with alfa = 2 (the inflection point):
!        p6 = 0.0625D0 * d2od1**6 * (0.125D0*d2od1/d1 - 1.0D0 )
!        q7 = d1 * p6
!        q8 = d2 * p6
!        mu6 = mu2**3
!        e = e_lyp * (1.0D0 + p6 * mu6)
!    &             / (1.0D0 + mu6 * (q7 * mu + q8 * mu2))
c --- third attmpt
c        mu_ref = alfa * d1/d2 = 2.D0 * d1/d2 ! the inflection point
c        eps_LDA = e_lyp/d2 * ( mu_ref**(-2) - d1od2 * mu_ref**(-3))
c                = e_lyp/d2 * ( 0.25d0 * d2od1**2 - 0.125d0 * d2od1**2)
         mu_ref  = 2.0d0 / d2od1
         if (mu .ge. mu_ref) then
            e = e_lyp/(d2*mu2) * (1.0d0 - d1 / (d2*mu))
         else
c           e_lyp * (1 + p6 * mu_ref**6) =  eps_LDA(mu_ref)
            eps_LDA_fac = 0.125d0/d2 * d2od1**2
            p6 = (eps_LDA_fac - 1.0d0) * d2od1**6 * 0.015625d0
            e = e_lyp * (1.0d0 + p6 * mu2**3)
         end if
      end if

!      print *,'ESRC_LYPRIERF: e=',e
      return
      end

C
C  begin Manu
C****************************************************************************
      subroutine ESRX_PBERIERF(rho,grd,mu,e)
C*****************************************************************************
C     rational interpolation for short-range erf exchange functional
C     using the two first terms of both developments at small and large mu
C     (eqs. 17 and 33 in Ref : Toulouse, Colonna, Savin PRA 70, 062505 (2004)) 
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: Emmanuel Fromager (Southern Denmark University) 
C     Date  : 31-01-2006
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision mu2, mu6, pi, sqrtpi 
      double precision three53, pi13, pi43, zero 
      double precision epbe
      double precision d, d2, denom1, denom2
      
!      print *,'ESRX_PBERIERF: mu=',mu
!      print *,'ESRX_PBERIERF: rho=',rho,' grd=',grd
     
C     General constants
      pi = 3.141592653589793d0
      sqrtpi = dsqrt(pi)
      three53 = 3.d0**(5.d0/3.d0) 
      pi13 = pi**(1.d0/3.d0)
      pi43 = pi**(4.d0/3.d0) 

!     Variables
      zero = 0.d0 
      mu2 =mu*mu
      mu6 =mu2*mu2*mu2

      d = -5.d0*(rho**(4.d0/3.d0))/(pi13*three53)      
      d2 = 20.d0/(pi43*three53*(rho**(2.d0/3.d0)))
      denom1 = 1.d0 + d2*mu2
      denom2 = 1.d0 + mu6

C Get standard PBE exchange functional calling HSEPBE with mu=0
      call ESRX_PBEHSEERF(rho,grd,zero,epbe)

      e = (d/denom1) + ((epbe + (rho*mu/sqrtpi) - d )/denom2)  
C      eps_pbe = epbe/rho
!      print *,'ESRX_PBERIERF: epbe=',epbe
!      print *,'ESRX_PBERIERF: e=',e
      return
      end
C
C end Manu
C
C****************************************************************************
      subroutine ESRC_PBELOERF(rho,grd,mu,e)
C*****************************************************************************
C     Our new local energy formula for sr correlation functional.
C     With PBE functional.
C
C     E_sr_c = max( E_c_pbe, E_c_srlda(mu) )
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e      : energy
C
C     Author: M. N. Pedersen
C     Date  : Nov. 2011
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e, e_pbe, e_lda,p,z,Ha,Hb
      double precision rho13

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision ZKSR(3)

      rho13 = rho**(1.0d0/3.0d0)

!     PBE correlation energy (mu=0)
      call ECPBE(rho,grd,e_pbe)
      if (abs(e_pbe) .lt. 1.0D-15) then
         e = 0.0d0
         return
      end if

!    short-range LDA energy
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,0,ERFEXP)
      e_lda = ZKSR(1)

!      e = max(e_lda,e_pbe)
!     Instead of max(e_lda,e_pbe) we use a smoothing function HS
      z = (e_pbe - e_lda)/(e_pbe**2 + e_lda**2)

      call HS(z,1.5d0,Ha)
      call HS(-z,1.5d0,Hb)
      e = e_pbe*Ha + e_lda*Hb

      return
      end

C****************************************************************************
      subroutine ESRC_PBEWIERF(rho,grd,mu,e)
C*****************************************************************************
C     weighted interpolation for for short-range erf correlation functional
C     Toulouse, Colonna, Savin PRA 70, 062505 (2004)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e, derfc

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision mu0,rho13, rs, pi
      double precision elda,epbe,eldamu
      double precision ZKSR(3)
C     
!      print *,'ESRC_PBEWIERF: mu=',mu
!      print *,'ESRC_PBEWIERF: rho=',rho,' grd=',grd

      pi = 3.141592653589793d0
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      rho13 = rho**(1.d0/3.d0)
      rs = (3.d0/(4.d0*pi*rho))**(1.d0/3.d0)

!     LDA energy
      mu0 = 0.d0
      call VCSRLDA(ZKSR,rho,rho13,mu0,MULOCAL,0,ERFEXP)
      elda = ZKSR(1)
!      print *,'ESRC_PBEWIERF: elda=',elda

!     PBE energy
      call ECPBE(rho,grd,epbe)
!      print *,'ESRC_PBEWIERF: epbe=',epbe

!     short-range LDA energy
      call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,0,ERFEXP)
      eldamu = ZKSR(1)
!      print *,'ESRC_PBEWIERF: eldamu=',eldamu

      e = (epbe - elda)*derfc(mu*rs) + eldamu

!      print *,'ESRC_PBEWIERF: e=',e
      return
      end
C****************************************************************************
      subroutine ESRC_PBETCSERF(rho,grd,mu,e)
C*****************************************************************************
C     Short-range PBE correlation functional
C       Toulouse, Colonna, Savin JCP 122, 014110 (2005)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision rho13

      double precision drho2
      double precision exerflda
      double precision ecerflda
      double precision ecerfpbe
      double precision t1

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision XKSR(3), ZKSR(3)

! function 
      double precision berft

!      print *,'ESRC_PBETCSERF: mu=',mu
!      print *,'ESRC_PBETCSERF: rho=',rho,' grd=',grd

C     LDA energy
      rho13 = rho**(1.d0/3.d0)
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      call VXSRLDA(XKSR,rho,rho13,mu,0,ERFEXP)
      call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,0,ERFEXP)
      exerflda = XKSR(1)
      ecerflda = ZKSR(1)

!     square of density gradient 
      drho2 = grd*grd

!     Code generated by Mathematica
C     Energy
       t1 = 9.869604401089358618834491d0*ecerflda + 3.068528194400546905
     & 827679d-1*rho*dlog(1.d0 - (8.401605835889726292406297d-1*drho2*ex
     & erflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*
     &  rho**(-1.1d1/3.d0)*(1.d0 - (8.401605835889726292406297d-1*drho2*
     & exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)
     &  )*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009
     &  d1*ecerflda)/rho))))/(1.d0 + (7.058698062165630644545894d-1*drho
     & 2**2*exerflda**2*berft(1.616204596739954813316614d-1*mu*rho**(-1.
     &  d0/3.d0))**2*rho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.2163968442914
     &  82112072009d1*ecerflda)/rho))**2 - (8.401605835889726292406297d-
     & 1*drho2*exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.
     &  d0/3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.2163968442914821
     &  12072009d1*ecerflda)/rho))))
       ecerfpbe = 1.013211836423377714438795d-1*t1

      e = ecerfpbe
!      print *,'ESRC_PBETCSERF: e=',e

      return
      end
C****************************************************************************
      subroutine ESRC_PBETCSJERF(rho,grd,mu,e)
C*****************************************************************************
C     Short-range PBE correlation functional
C       Toulouse, Colonna, Savin JCP 122, 014110 (2005)
C       with modification by Jensen
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision rho13

      double precision drho2
      double precision exerflda
      double precision ecerflda
      double precision ecerfpbe
      double precision t1

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision XKSR(3), ZKSR(3)

      double precision epbe

! function 
      double precision berft

!      print *,'ESRC_PBETCSERF: mu=',mu
!      print *,'ESRC_PBETCSERF: rho=',rho,' grd=',grd

C     LDA energy
      rho13 = rho**(1.d0/3.d0)
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      call VXSRLDA(XKSR,rho,rho13,mu,0,ERFEXP)
      call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,0,ERFEXP)
      exerflda = XKSR(1)
      ecerflda = ZKSR(1)

!     square of density gradient 
      drho2 = grd*grd

!     Code generated by Mathematica
C     Energy
       t1 = 9.869604401089358618834491d0*ecerflda + 3.068528194400546905
     & 827679d-1*rho*dlog(1.d0 - (8.401605835889726292406297d-1*drho2*ex
     & erflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*
     &  rho**(-1.1d1/3.d0)*(1.d0 - (8.401605835889726292406297d-1*drho2*
     & exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)
     &  )*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009
     &  d1*ecerflda)/rho))))/(1.d0 + (7.058698062165630644545894d-1*drho
     & 2**2*exerflda**2*berft(1.616204596739954813316614d-1*mu*rho**(-1.
     &  d0/3.d0))**2*rho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.2163968442914
     &  82112072009d1*ecerflda)/rho))**2 - (8.401605835889726292406297d-
     & 1*drho2*exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.
     &  d0/3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.2163968442914821
     &  12072009d1*ecerflda)/rho))))
       ecerfpbe = 1.013211836423377714438795d-1*t1

      call ECPBE(rho,grd,epbe)

! modification of ESRC_PBETCS:
      e = max(ecerfpbe,epbe)
!      print *,'ESRC_PBETCSERF: e=',e

      return
      end
C****************************************************************************
      SUBROUTINE VSRCPBEERF(e,d1edrho,d1edgrd,d1edgrda2,d2edrhodrho,
     >                      d2edgrddgrd,d2edrhodgrd,rho,grd,mu,
     >                      norder)
C*****************************************************************************
C     Short-range PBE correlation functional from 
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interation parameter
C            norder : Order of derivative
C
C     Ouput: e             : energy
C            d1edrho       : first derivative wrt to rho
C            d1edgrd       : first derivative wrt to grd   (for 2nd-order optimisation)
C            d1edgrda2     : first derivative wrt to grda2 (for HF optimisation)
C            (grda2 is the square of gradient of spin-alpha density)
C            d2edrhodrho   : second derivative wrt to rho and rho
C            d2edgrddgrd   : second derivative wrt to grd and grd
C            d2edrhodgrd   : second derivative wrt to rho and grd
C
C     Author: J. Toulouse
C     Date  : 12-02-05
C*****************************************************************************
      implicit none

      integer norder
      double precision rho, grd, mu
      double precision e, d1edrho, d1edgrd, d1edgrda2
      double precision d2edrhodrho, d2edgrddgrd, d2edrhodgrd

      double precision rho13
      double precision exLDA, d1exLDAdrho
      double precision ecLDA, d1ecLDAdrho

      double precision drho2
      double precision exerflda,dexerfldadrho
      double precision ecerflda,decerfldadrho
      double precision ecerfpbe,decerfpbedrho,decerfpbeddrho2 
      double precision t1,t2,t3,t4,t5,t6,t7,t8,t9,t10
      double precision t11,t12,t13,t14,t15,t16,t17,t18,t19

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision XKSR(3), ZKSR(3)

! function 
      double precision berft
      double precision dberftda

!      print *,'VSRPBECERF: mu=',mu
!      print *,'VSRPBECERF: rho=',rho,' grd=',grd

      if(rho .lt. 1.d-10) then
       return
      endif

C     LDA energy
      rho13 = rho**(1.d0/3.d0)
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      call VXSRLDA(XKSR,rho,rho13,mu,0,ERFEXP)
      call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,0,ERFEXP)
      exerflda = XKSR(1)
      ecerflda = ZKSR(1)

!     square of density gradient 
      drho2 = grd*grd

!     Code generated by Mathematica
C     Energy
       t1 = 9.869604401089358618834491d0*ecerflda + 3.068528194400546905
     & 827679d-1*rho*dlog(1.d0 - (8.401605835889726292406297d-1*drho2*ex
     & erflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*
     &  rho**(-1.1d1/3.d0)*(1.d0 - (8.401605835889726292406297d-1*drho2*
     & exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)
     &  )*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009
     &  d1*ecerflda)/rho))))/(1.d0 + (7.058698062165630644545894d-1*drho
     & 2**2*exerflda**2*berft(1.616204596739954813316614d-1*mu*rho**(-1.
     &  d0/3.d0))**2*rho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.2163968442914
     &  82112072009d1*ecerflda)/rho))**2 - (8.401605835889726292406297d-
     & 1*drho2*exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.
     &  d0/3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.2163968442914821
     &  12072009d1*ecerflda)/rho))))
       ecerfpbe = 1.013211836423377714438795d-1*t1

      e = ecerfpbe
!      print *,'VSRCPBERF: e=',e

C Derivative
      if (norder .ge. 1) then
            
!      LDA energy density derivative
       call VXSRLDA(XKSR,rho,rho13,mu,1,ERFEXP)
       call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,1,ERFEXP)
       dexerfldadrho = XKSR(2)
       decerfldadrho = ZKSR(2)

!      Code generated by Mathematica
C      Derivative wrt rho
       t1 = ecerflda/rho
       t2 = -(ecerflda/rho**2)
       t3 = decerfldadrho/rho
       t4 = 1/(1.d0 -(8.401605835889726292406297d-1*drho2*exerflda*berft
     &  (1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d
     &  1/3.d0)*(1.d0 - (8.401605835889726292406297d-1*drho2*exerflda*be
     & rft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.
     &  1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda
     &  )/rho))))/(1.d0 + (7.058698062165630644545894d-1*drho2**2*exerfl
     & da**2*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**
     &  2*rho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009
     &  d1*ecerflda)/rho))**2 - (8.401605835889726292406297d-1*drho2*exe
     & rflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*r
     &  ho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*
     &  ecerflda)/rho))))
       t5 =(4.526237990654068686941552d-2*drho2*exerflda*mu*dberftda(1.6
     &  16204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*(1.d0 - (8.4016
     & 05835889726292406297d-1*drho2*exerflda*berft(1.616204596739954813
     &  316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dex
     &  p((-3.216396844291482112072009d1*ecerflda)/rho))))/(rho**5*(1.d0
     &  + (7.058698062165630644545894d-1*drho2**2*exerflda**2*berft(1.61
     &  6204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**2*rho**(-2.2d1/
     &  3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/rh
     & o))**2 - (8.401605835889726292406297d-1*drho2*exerflda*berft(1.61
     &  6204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.d
     &  0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/rho))
     &  ))
       t6 =(3.080588806492899640548976d0*drho2*exerflda*berft(1.61620459
     &  6739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.4d1/3.d0)*(1.
     & d0 - (8.401605835889726292406297d-1*drho2*exerflda*berft(1.616204
     &  596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.d0))/
     &  (-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/rho))))/(
     & 1.d0 + (7.058698062165630644545894d-1*drho2**2*exerflda**2*berft(
     &  1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**2*rho**(-2.
     &  2d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda
     & )/rho))**2 - (8.401605835889726292406297d-1*drho2*exerflda*berft(
     &  1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1
     &  /3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/r
     &  ho)))
       t7 =(-8.401605835889726292406297d-1*dexerfldadrho*drho2*berft(1.6
     &  16204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.
     & d0)*(1.d0 - (8.401605835889726292406297d-1*drho2*exerflda*berft(1
     &  .616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/
     &  3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/rh
     &  o))))/(1.d0 + (7.058698062165630644545894d-1*drho2**2*exerflda**
     & 2*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**2*rh
     &  o**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*e
     &  cerflda)/rho))**2 - (8.401605835889726292406297d-1*drho2*exerfld
     & a*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**
     &  (-1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecer
     &  flda)/rho)))
       t8 = -8.401605835889726292406297d-1*drho2*exerflda
       t9 =berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho
     &  **(-1.1d1/3.d0)
       t10 = 1/(1.d0 + (7.058698062165630644545894d-1*drho2**2*exerflda*
     & *2*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**2*r
     &  ho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*
     &  ecerflda)/rho))**2 - (8.401605835889726292406297d-1*drho2*exerfl
     & da*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho*
     &  *(-1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ece
     &  rflda)/rho)))
       t11 =(4.526237990654068686941552d-2*drho2*exerflda*mu*dberftda(1.
     &  616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)))/(rho**5*(-1.d
     &  0 + dexp((-3.216396844291482112072009d1*ecerflda)/rho))) + (3.08
     & 0588806492899640548976d0*drho2*exerflda*berft(1.61620459673995481
     &  3316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.4d1/3.d0))/(-1.d0 + de
     &  xp((-3.216396844291482112072009d1*ecerflda)/rho)) - (8.401605835
     & 889726292406297d-1*dexerfldadrho*drho2*berft(1.616204596739954813
     &  316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dex
     &  p((-3.216396844291482112072009d1*ecerflda)/rho)) + (8.4016058358
     &  89726292406297d-1*drho2*exerflda*((3.216396844291482112072009d1*
     &  ecerflda)/rho**2 - (3.216396844291482112072009d1*decerfldadrho)/
     & rho)*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*de
     &  xp((-3.216396844291482112072009d1*ecerflda)/rho)*rho**(-1.1d1/3.
     &  d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/rho)
     &  )**2
       t12 =8.401605835889726292406297d-1*drho2*exerflda*berft(1.6162045
     &  96739954813316614d-1*mu*rho**(-1.d0/3.d0))
       t13 = rho**(-1.1d1/3.d0)*(1.d0 - (8.401605835889726292406297d-1*d
     & rho2*exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/
     &  3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.2163968442914821120
     &  72009d1*ecerflda)/rho)))
       t14 = (1.d0 + (7.058698062165630644545894d-1*drho2**2*exerflda**2
     & *berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**2*rho
     &  **(-2.2d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ec
     &  erflda)/rho))**2 - (8.401605835889726292406297d-1*drho2*exerflda
     & *berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(
     &  -1.1d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerf
     &  lda)/rho)))**(-2)
       t15 =(4.526237990654068686941552d-2*drho2*exerflda*mu*dberftda(1.
     &  616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)))/(rho**5*(-1.d
     &  0 + dexp((-3.216396844291482112072009d1*ecerflda)/rho))) - (7.60
     & 5533503381002378534421d-2*drho2**2*exerflda**2*mu*berft(1.6162045
     & 96739954813316614d-1*mu*rho**(-1.d0/3.d0))*dberftda(1.61620459673
     &  9954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-2.6d1/3.d0))/(-1.d
     &  0 + dexp((-3.216396844291482112072009d1*ecerflda)/rho))**2
       t16 =(-5.176378578921462472666989d0*drho2**2*exerflda**2*berft(1.
     &  616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**2*rho**(-2.5d
     &  1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/
     &  rho))**2 + (1.411739612433126128909179d0*dexerfldadrho*drho2**2*
     & exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)
     &  )**2*rho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112072
     &  009d1*ecerflda)/rho))**2
       t17 = (-1.411739612433126128909179d0*drho2**2*exerflda**2*((3.216
     &  396844291482112072009d1*ecerflda)/rho**2 - (3.216396844291482112
     & 072009d1*decerfldadrho)/rho)*berft(1.616204596739954813316614d-1*
     &  mu*rho**(-1.d0/3.d0))**2*dexp((-3.216396844291482112072009d1*ece
     &  rflda)/rho)*rho**(-2.2d1/3.d0))/(-1.d0 + dexp((-3.21639684429148
     &  2112072009d1*ecerflda)/rho))**3 + (3.080588806492899640548976d0*
     & drho2*exerflda*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0
     &  /3.d0))*rho**(-1.4d1/3.d0))/(-1.d0 + dexp((-3.216396844291482112
     &  072009d1*ecerflda)/rho))
       t18 =(-8.401605835889726292406297d-1*dexerfldadrho*drho2*berft(1.
     &  616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3
     &  .d0))/(-1.d0 + dexp((-3.216396844291482112072009d1*ecerflda)/rho
     &  )) + (8.401605835889726292406297d-1*drho2*exerflda*((3.216396844
     &  291482112072009d1*ecerflda)/rho**2 - (3.216396844291482112072009
     & d1*decerfldadrho)/rho)*berft(1.616204596739954813316614d-1*mu*rho
     &  **(-1.d0/3.d0))*dexp((-3.216396844291482112072009d1*ecerflda)/rh
     &  o)*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.21639684429148211207200
     &  9d1*ecerflda)/rho))**2
       t19 = 3.109069086965489503494086d-2*log(1.d0 - (8.401605835889726
     & 292406297d-1*drho2*exerflda*berft(1.616204596739954813316614d-1*m
     &  u*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.d0)*(1.d0 - (8.4016058358897
     & 26292406297d-1*drho2*exerflda*berft(1.616204596739954813316614d-1
     &  *mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dexp((-3.216
     &  396844291482112072009d1*ecerflda)/rho))))/(1.d0 + (7.05869806216
     & 5630644545894d-1*drho2**2*exerflda**2*berft(1.6162045967399548133
     &  16614d-1*mu*rho**(-1.d0/3.d0))**2*rho**(-2.2d1/3.d0))/(-1.d0 + d
     &  exp((-3.216396844291482112072009d1*ecerflda)/rho))**2 - (8.40160
     & 5835889726292406297d-1*drho2*exerflda*berft(1.6162045967399548133
     &  16614d-1*mu*rho**(-1.d0/3.d0))*rho**(-1.1d1/3.d0))/(-1.d0 + dexp
     &  ((-3.216396844291482112072009d1*ecerflda)/rho))))
       decerfpbedrho = t1 + rho*(t2 + t3 + 3.109069086965489503494086d-2
     &  *t4*(t5 + t6 + t7 + t8*t9*t10*t11 + t12*t13*t14*(t15 + t16 + t17
     &   + t18))) + t19

C       Derivative wrt drho2
       t1 =-2.608295326454957778144342d0*exerflda*berft(1.61620459673995
     &  4813316614d-1*mu*rho**(-1.d0/3.d0))*(-1.d0 + dexp((3.21639684429
     &  1482112072009d1*ecerflda)/rho))**3
       t2 =(3.093667726280135930968945d0*drho2*exerflda*berft(1.61620459
     &  6739954813316614d-1*mu*rho**(-1.d0/3.d0))*dexp((3.21639684429148
     &  2112072009d1*ecerflda)/rho) + 1.841116916640328143496607d0*(-1.d
     &  0 + dexp((3.216396844291482112072009d1*ecerflda)/rho))*rho**(1.1
     &  d1/3.d0))/(9.570780000627306053141656d0*drho2**2*exerflda**2*ber
     & ft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0))**2*dexp((3
     &  .216396844291482112072009d1*ecerflda)/rho) + 1.13916079706371570
     & 5810133d1*drho2*exerflda*berft(1.616204596739954813316614d-1*mu*r
     &  ho**(-1.d0/3.d0))*(-1.d0 + dexp((3.216396844291482112072009d1*ec
     &  erflda)/rho))*rho**(1.1d1/3.d0) + 1.355884600295675603989991d1*(
     &  -1.d0 + dexp((3.216396844291482112072009d1*ecerflda)/rho))**2*rh
     &  o**(2.2d1/3.d0))
       t3 = rho**(2.5d1/3.d0)/(9.570780000627306053141656d0*drho2**2*exe
     & rflda**2*berft(1.616204596739954813316614d-1*mu*rho**(-1.d0/3.d0)
     &  )**2*dexp((6.432793688582964224144018d1*ecerflda)/rho) + 1.13916
     & 0797063715705810133d1*drho2*exerflda*berft(1.61620459673995481331
     &  6614d-1*mu*rho**(-1.d0/3.d0))*(-1.d0 + dexp((3.21639684429148211
     &  2072009d1*ecerflda)/rho))*dexp((3.216396844291482112072009d1*ece
     &  rflda)/rho)*rho**(1.1d1/3.d0) + 1.355884600295675603989991d1*(-1
     &  .d0 + dexp((3.216396844291482112072009d1*ecerflda)/rho))**2*rho*
     &  *(2.2d1/3.d0))
       decerfpbeddrho2 = t1*t2*t3

C      derivatives
       d1edrho  =  decerfpbedrho
       d1edgrda2  =  4.d0*decerfpbeddrho2

C     d1edgrd to do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C     End of derivative
      end if

C     Second derivative
      if(norder .ge. 2) then
       CALL QUIT ('Second derivative of VSRCPBEERF not yet implemented')
      endif

      RETURN
      END
!-------------------------------------------
      function berft(a)
!-------------------------------------------
!  Second-order exchange gradient expansion coefficient for erf 
!  interaction
!  a = mu/(2*kF)
!
!  Author : J. Toulouse
!  Date   : 10-03-04
!-------------------------------------------
      implicit none
 
      double precision a
      double precision berft, derf

      double precision pi

C     constants
      pi = 3.141592653589793d0

      if(a .lt. 0.02d0) then
!      expansion for small mu to avoid numerical problems
       berft = 7.d0/81.d0 + 56.d0*dsqrt(pi)*a/243.d0 
     >        + (-128.d0/81.d0 + 448.d0*pi/729.d0)*a*a

      else

!      Code generated by Mathematica
       berft =(1.851851851851851851851852d-2*(-1.d0 + 1.44d2*a**4*(-1.d0
     &   + dexp(2.5d-1/a**2)) - 2.d0*a**2*(1.1d1 + 7.d0*dexp(2.5d-1/a**2
     &  ))))/(a**2*(3.2d1*a**4*(-1.d0 + dexp(2.5d-1/a**2)) - 3.d0*dexp(2
     &  .5d-1/a**2) + 1.417963080724412821838534d1*a*derf(5.d-1/a)*dexp
     &  (2.5d-1/a**2) - 8.d0*a**2*(-2.d0 + 3.d0*dexp(2.5d-1/a**2))))

      endif

      return
      end

!-------------------------------------------
      function dberftda(a)
!-------------------------------------------
!  Derivative of second-order exchange gradient
!  expansion coefficient for erf interaction
!  a = mu/(2*kF)
!
!  Author : J. Toulouse
!  Date   : 10-03-04
!-------------------------------------------
      implicit none
 
      double precision a
      double precision dberftda, derf
      double precision t1,t2,t3,t4,t5
      double precision pi

C     constants
      pi = 3.141592653589793d0

      if(a .lt. 0.02d0) then
!      expansion for small mu to avoid numerical problems
       dberftda = 56.d0*dsqrt(pi)/243.d0
     >        + 2.d0*(-128.d0/81.d0 + 448.d0*pi/729.d0)*a

      else

!      Code generated by Mathematica
       t1 = (1.851851851851851851851852d-2*(5.76d2*a**3*(-1.d0 + dexp(2.
     &  5d-1/a**2)) + (7.d0*dexp(2.5d-1/a**2))/a - 7.2d1*a*dexp(2.5d-1/a
     &  **2) - 4.d0*a*(1.1d1 + 7.d0*dexp(2.5d-1/a**2))))/(a**2*(3.2d1*a*
     &  *4*(-1.d0 + dexp(2.5d-1/a**2)) - 3.d0*dexp(2.5d-1/a**2) + 1.4179
     &  63080724412821838534d1*a*derf(5.d-1/a)*dexp(2.5d-1/a**2) - 8.d0
     &  *a**2*(-2.d0 + 3.d0*dexp(2.5d-1/a**2))))
       t2 = -1.851851851851851851851852d-2/a**2
       t3 = -8.d0/a + 1.28d2*a**3*(-1.d0 + dexp(2.5d-1/a**2)) + (1.5d0*d
     &  exp(2.5d-1/a**2))/a**3 + (1.2d1*dexp(2.5d-1/a**2))/a - 1.6d1*a*d
     &  exp(2.5d-1/a**2) + 1.417963080724412821838534d1*derf(5.d-1/a)*d
     &  exp(2.5d-1/a**2) - (7.08981540362206410919267d0*derf(5.d-1/a)*d
     &  exp(2.5d-1/a**2))/a**2 - 1.6d1*a*(-2.d0 + 3.d0*dexp(2.5d-1/a**2)
     &  )
       t4 = (-1.d0 + 1.44d2*a**4*(-1.d0 + dexp(2.5d-1/a**2)) - 2.d0*a**2
     &  *(1.1d1 + 7.d0*dexp(2.5d-1/a**2)))/(3.2d1*a**4*(-1.d0 + dexp(2.5
     &  d-1/a**2)) - 3.d0*dexp(2.5d-1/a**2) + 1.417963080724412821838534
     &  d1*a*derf(5.d-1/a)*dexp(2.5d-1/a**2) - 8.d0*a**2*(-2.d0 + 3.d0*
     &  dexp(2.5d-1/a**2)))**2
       t5 = (-3.703703703703703703703704d-2*(-1.d0 + 1.44d2*a**4*(-1.d0 
     &  + dexp(2.5d-1/a**2)) - 2.d0*a**2*(1.1d1 + 7.d0*dexp(2.5d-1/a**2)
     &  )))/(a**3*(3.2d1*a**4*(-1.d0 + dexp(2.5d-1/a**2)) - 3.d0*dexp(2.
     &  5d-1/a**2) + 1.417963080724412821838534d1*a*derf(5.d-1/a)*dexp(
     &  2.5d-1/a**2) - 8.d0*a**2*(-2.d0 + 3.d0*dexp(2.5d-1/a**2))))
       dberftda = t1 + t2*t3*t4 + t5

      endif

      return
      end

C****************************************************************************
      subroutine ESRX_PBEGWSERF(rho,grd,mu,e)
C*****************************************************************************
C     Short-range PBE exchange functional from 
C       Goll, Werner, Stoll, PCCP 7, 3917 (2005)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interation parameter
C
C     Ouput: e      : energy
C
C     Author: J. Toulouse
C     Date  : 11-08-09
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision rho13
      double precision drho2

      double precision exerflda
      double precision exerfpbe
      double precision t1,t2,t3,t4
      double precision kappa,sq,fx

      double precision XKSR(3)
      logical ERFEXP(0:2)

! function 
      double precision berf

! edh debug
#include "priunit.h"

C     LDA energy
      rho13 = rho**(1.d0/3.d0)
      ERFEXP(0:2) = .false.
      call VXSRLDA(XKSR,rho,rho13,mu,0,ERFEXP)
      exerflda = XKSR(1)

      write(lupri,*)'LDA energy exerflda', exerflda

      drho2 = grd*grd

      kappa=0.804d0
      sq=drho2*2.6121172985233599567768d-2*rho**(-8.d0/3.d0)
      fx=1.d0+kappa
     &    -kappa/(1.d0+berf(1.616204596739954813d
     &    -1*mu*rho**(-1.d0/3.d0))*sq/kappa)
      exerfpbe=exerflda*fx

      e = exerfpbe

      return
      end
C****************************************************************************
      subroutine ESRX_PBEGWSERFSPIN(rho,rhos,grd,grds,mu,dospin,e)
C*****************************************************************************
C     Short-range PBE exchange functional from
C       Goll, Werner, Stoll, PCCP 7, 3917 (2005)
C
C     Input: rho    : density
C            rhos   : spin-density
C            grd    : norm of gradient of density
C            grds   : norm of gradient of spin-density
C            mu     : Interation parameter
C
C     Ouput: e      : energy
C
C     Author: Erik Donovan Hedegård (after original code by J. Toulouse)
C     Date  : 11-02-16
C*****************************************************************************
      implicit none

      double precision rho, rhos, grd, grds, mu
      double precision e

      double precision rho13
      double precision drho2

      double precision exerflda
      double precision exerfpbe
      double precision t1,t2,t3,t4 ! not used now
      double precision kappa,sq,fx

      logical dospin

! function
      double precision berf

C     LDA energy ----
C     ! In ESRX_PBEGWS VXSRLDA is used for the same purpose, but     
      ! as VXSRLDA does not include rhos ESRX_LDAERFSPIN is used instead 
      call ESRX_LDAERFSPIN(rho,rhos,mu,dospin,exerflda)

      ! Only for debugging... Remove !!!!!
      e = exerflda

!     GGA energy ----- Current no spin part???
!     drho2 = grd*grd
!
!     kappa=0.804d0
!     sq=drho2*2.6121172985233599567768d-2*rho**(-8.d0/3.d0)
!     fx=1.d0+kappa
!    &    -kappa/(1.d0+berf(1.616204596739954813d
!    &    -1*mu*rho**(-1.d0/3.d0))*sq/kappa)
!     exerfpbe=exerflda*fx

!     e = exerfpbe

      return
      end
C****************************************************************************
      subroutine ELAX_PBEGWS(rhot,grd,VLAMBDA,e)
C linear complement exchange PBE energy, Kamal SHARKAS 19/05/2011 beg
C*****************************************************************************
      double precision rhot, grd, VLAMBDA
      double precision e

      call ESRX_PBEGWSERF(rhot,grd,0.d0,e)
      e = (1.d0 - VLAMBDA) * e

      return
       end
C****************************************************************************
      subroutine ESRC_PBEGWSERF(rho,grd,mu,e)
C*****************************************************************************
C     Short-range PBE correlation functional from
C       Goll, Werner, Stoll, PCCP 7, 3917 (2005)
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: J. Toulouse
C     Date  : 11-08-09
C*****************************************************************************
      implicit none

      double precision rho, grd, mu
      double precision e

      double precision tol
      parameter(tol=1d-12)
      double precision rho13

      double precision drho2
      double precision ecerflda,eclda
      double precision ecerfpbe
      double precision t1
      double precision alpha, beta, gamma, Aa,Ab, Ac, tq, arglog
 
      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision XKSR(3), ZKSR(3)

!     short-range LDA energy (order = 0)
      rho13 = rho**(1.d0/3.d0)
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,0,ERFEXP)
      ecerflda = ZKSR(1)

!     full-range LDA energy
      call VCSRLDA(ZKSR,rho,rho13,0.d0,MULOCAL,0,ERFEXP)
      eclda = ZKSR(1)

      alpha=2.78d0
      gamma=3.1091d-2

!     square of density gradient 
      drho2 = grd*grd

      if ((ecerflda/eclda).le.0.d0) then
         beta=0.d0
      else
         beta=6.6725d-2*(ecerflda/eclda)**alpha
      endif
      tq=drho2*6.346820607d-2*rho**(-7.d0/3.d0)
      Ab=dexp(-ecerflda/(rho*gamma))-1.d0
      if (dabs(Ab).le.dabs(beta*tol)) then
         ecerfpbe=ecerflda
       else
         Aa=beta/(gamma*Ab)
         if (Aa.lt.tol) Aa=tol
         Ac=1.d0+Aa*tq+Aa**2*tq**2
         arglog=1.d0+beta*(1.d0-1.d0/Ac)/(gamma*Aa)
         ecerfpbe=ecerflda+rho*gamma*dlog(arglog)
       endif

      e = ecerfpbe

      return
      end
C****************************************************************************
      subroutine ESRC_PBEGWSERFSPIN(rho,rhos,grd,grds,mu,e)
C*****************************************************************************
C     WILL NOT WORK YET....
C     Short-range spin-dependent PBE correlation functional from
C       Goll et al. Chem. Phys. 329 (2006), 276
C
C     Input: rho    : density
C            rho    : spin-density
C            grd    : norm of gradient of density
C            grds   : norm of gradient spin-density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: Erik Hedegård (after Molpro code by J. Toulouse + A. Savin)
C     Date  : 11-02-16
C*****************************************************************************
      implicit none

      double precision rho, rhos, grd, grds, mu
      double precision e

      double precision tol
      parameter(tol=1d-12)
      double precision rho13

      double precision drho2
      double precision ecerflda,eclda
      double precision ecerfpbe
      double precision t1
      double precision alpha, beta, gamma, Aa,Ab, Ac, tq, arglog

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision XKSR(3), ZKSR(3)

!     Adapt to LSDA !!!!!
!     short-range LDA energy (order = 0)
      rho13 = rho**(1.d0/3.d0)
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      call VCSRLDA(ZKSR,rho,rho13,mu,MULOCAL,0,ERFEXP)
      ecerflda = ZKSR(1)

!     Adapt to LSDA !!!!!
!     full-range LDA energy
      call VCSRLDA(ZKSR,rho,rho13,0.d0,MULOCAL,0,ERFEXP)
      eclda = ZKSR(1)

!     Spin polarisation
!     Define rhoa, rhob, zeta
!     rhoa=max((rhoc(i)+rhoo(i))*.5d0,1.0d-15)
!     rhob=max((rhoc(i)-rhoo(i))*.5d0,1.0d-15)
!     zeta = (rhoa-rhob)/(rhoa+rhob)

      alpha=2.78d0
      gamma=3.1091d-2

!     square of density gradient
      drho2 = grd*grd

!     if ((ecerflda/eclda).le.0d0) then
!       ! edh define beta and check alpha!
!       beta=0d0
!     else
!       beta=6.6725d-2*(ecerflda/eclda)**alpha
!     endif
!     phi=((1d0+zeta)**(2d0/3d0)+(1d0-zeta)**(2d0/3d0))/2d0
!     phi2=phi*phi
!     phi3=phi2*phi
!     phi4=phi3*phi
!     tq=drho2*6.346820607d-2*rho**(-7d0/3d0)/phi2
!     Ab=dexp(-ecerflda/(rho*gamma*phi3))-1d0
!     if(dabs(Ab).le.dabs(beta*tol)) then
!       ecerfpbe=ecerflda
!     else
!       Aa=beta/(gamma*Ab)
!       Ac=1d0+Aa*tq+Aa**2*tq**2
!       if (Aa.lt.tol) Aa=tol
!       arglog=1d0+beta*(1d0-1d0/Ac)/(gamma*Aa)
!       ecerfpbe=ecerflda+rho*phi3*gamma*dlog(arglog)
!     endif

      e = ecerfpbe

      return
      end
C****************************************************************************
      subroutine ELAC_PBEGWS(rhot,grd,VLAMBDA,e)
C linear complement non-scaled correlation PBE functional energy, Kamal SHARKAS 20/05/2011 beg
C*****************************************************************************
      double precision rhot, grd, VLAMBDA
      double precision e

      call ESRC_PBEGWSERF(rhot,grd,0.d0,e)
      e = (1.d0 - VLAMBDA**2) * e

      return
       end

C****************************************************************************
      subroutine ELASC_PBEGWS(rhot,grd,VLAMBDA,e)
C linear complement Scaled correlation PBE functional energy, Kamal SHARKAS 20/05/2011
C*****************************************************************************
      double precision rhot, grd, VLAMBDA
      double precision e, ecoul, escaled,rhotscaled,grdscaled

      ecoul = 0.d0

      call ESRC_PBEGWSERF(rhot,grd,0.d0,ecoul)

      rhotscaled = rhot/VLAMBDA**3
      grdscaled  = grd/VLAMBDA**4

      escaled = 0.d0

      call ESRC_PBEGWSERF(rhotscaled,grdscaled,0.d0,escaled)

      e = ecoul - (VLAMBDA**5)*escaled

      return
       end

C*****************************************************************************

!-------------------------------------------
      function berf(a)
!-------------------------------------------
!  Second-order exchange gradient expansion coefficient for erf
!  interaction
!  a = mu/(2*kF)
! 
!  Modified version from Goll, Werner, Stoll, PCCP 7, 3917 (2005)
!
!  Author : J. Toulouse
!  Date   : 11-08-09
!-------------------------------------------
      implicit none

      double precision a
      double precision eta,fak,berf
      double precision pi

! function
      double precision derf

      pi = 3.141592653589793d0

      eta=19.0d0
      fak=2.540118935556d0*dexp(-eta*a*a)

      if(a .lt. 0.075d0) then
!      expansion for small mu to avoid numerical problems
!      denominator becomes zero for a approximately 0.4845801308
!      (and for one negative and two complex values of a)
       berf = (-7.d0+72.d0*a*a)
     >        /(27.d0*(-3.d0-24.d0*a*a+32.d0*a**4+8.d0*dsqrt(pi)*a))

      else if(a .gt. 50.d0) then
       berf = 1.d0/(72.d0*a*a)-1.d0/(17280.d0*a**4)
     >        - 23.d0/(358400.d0*a**6)

      else


!     Code generated by Mathematica
      berf = (1.851851851851851851851852d-2*(-1.d0 + 1.44d2*a**4*(-1.d0
     &  + dexp(2.5d-1/a**2)) - 2.d0*a**2*(1.1d1 + 7.d0*dexp(2.5d-1/a**2
     & ))))/(a**2*(3.2d1*a**4*(-1.d0 + dexp(2.5d-1/a**2)) - 3.d0*dexp(2
     &  .5d-1/a**2) + 1.417963080724412821838534d1*a*derf(5.d-1/a)*dexp
     &  (2.5d-1/a**2) - 8.d0*a**2*(-2.d0 + 3.d0*dexp(2.5d-1/a**2))))

      end if

      berf=berf*fak

      return
      end

C****************************************************************************
      subroutine ESRC_MULOC_GGA(rho,grd,mu,e)
C*****************************************************************************
C     Modified version of local mu formula C short-range correlation functional from
C     J. Toulouse, F. Colonna and A. Savin, J. Chem. Phys., 122, 014110 (2005)
C
C     Our modification: factor alpha below
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: M.N.P
C     Date  : 20-09-11
C*****************************************************************************
      implicit none

      double precision rho, grd, mu, mu_new, amul
      double precision e
      double precision alpha, x, a1, b1, c1
      parameter(a1 = 0.559463d0, b1 = -0.134086d0, c1 = 0.0296811d0)
      double precision rho13

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision ZKSR(3)
!     local mu parameter 
      rho13 = rho**(1.0d0/3.0d0)
!     Multiplication factor for mu parameter
      x = grd/rho
      alpha = a1 + b1*exp(-c1*x)
      amul = x*alpha
      mu_new = max(amul,mu)
!     short-range LDA energy
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
      call VCSRLDA(ZKSR,rho,rho13,mu_new,MULOCAL,0,ERFEXP)
      e = ZKSR(1)
      return
      end
C****************************************************************************
      subroutine ESRC_MULOD_GGA(rho,grd,mu,e)
C*****************************************************************************
C     Modified version of SRCMULO_A functional
C
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: M.N.P
C     Date  : 20-09-11
C*****************************************************************************

      implicit none

      double precision rho, grd, mu, amul, mu_new
      double precision e
      double precision rsfac, rs, x, a, b, c, d
      parameter(rsfac = 0.62035049089940008660d0)
      parameter(b = 1.741930d0, c = -0.528057d0, d = 0.0720226d0 )
      double precision rho13

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision ZKSR(3)

      rho13 = rho**(1.0d0/3.0d0)
      rs   = rsfac/rho13
!     Multiplying factor for mu parameter
      x = grd/rho
      a = b + c*exp(-d*x)
!     local mu parameter 
      amul = a/rs
      mu_new = max(amul,mu)
!     short-range LDA energy
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
!      print *,'mu = 0.1' , mu
      call VCSRLDA(ZKSR,rho,rho13,mu_new,MULOCAL,0,ERFEXP)
      e = ZKSR(1)
      return
      end

C****************************************************************************
      subroutine ESRC_MULOE_GGA(rho,grd,mu,e)
C*****************************************************************************
C     Modified version of SRCMULO_B correlation functional 
C
C
C
C     Input: rho    : density
C            grd    : norm of gradient of density
C            mu     : Interaction parameter
C
C     Ouput: e             : energy
C
C     Author: M.N.P
C     Date  : 20-09-11
C*****************************************************************************

      implicit none

      double precision rho, grd, mu, amul, mu_new, x, rs, alpha
      double precision e
      double precision rsfac, a, b, bfac
      parameter(rsfac = 0.62035049089940008660d0, a = 0.878435d0)
      parameter(b = 0.5676020d0, bfac = 0.814516076948D0)
      double precision rho13

      logical ERFEXP(0:2), MULOCAL(0:2)
      double precision ZKSR(3)

      rho13 = rho**(1.0d0/3.0d0)
      rs   = rsfac/rho13
      x = grd/rho
      alpha = a*x**b
!     local mu parameter 
      amul = (alpha*bfac)/sqrt(rs)
      mu_new = max(amul,mu)
!     short-range LDA energy
      ERFEXP(0:2) = .false.
      MULOCAL(0:2) = .false.
!      print *,'mu = 0.1' , mu
      call VCSRLDA(ZKSR,rho,rho13,mu_new,MULOCAL,0,ERFEXP)
      e = ZKSR(1)
      return
      end
C****************************************************************************
      subroutine ESRX_LDAERFSPIN (rhot,rhos,mu,dospin,e)
C*****************************************************************************
C     Short-range spin-dependent LDA exchange functional
C       obtained by spin-scaling Ex[na,nb] = 1/2 (Ex[na]+Ex[nb])
C       where Ex[n] is from Toulouse, Savin, Flad, IJQC 100, 1047 (2004)
C
C     subroutine adapted from Molpro
C
C     Input: rhot   : total density
C            rhos   : spin density
C            mu     : Interation parameter
C            dospin : use spin density
C
C     Ouput: e      : energy
C
C     Created: 17-08-09, J. Toulouse
C*****************************************************************************
      implicit none

      double precision rhot, rhos, mu
      logical dospin
      double precision e

      double precision derf

      double precision f13, pi, pisqrt, ckf
      double precision rho, akf, a, a2, a3

      double precision rhoa, rhob
      double precision ea, eb

      parameter(pi = 3.141592653589793d0)
      parameter(pisqrt = 1.772453850905516d0)
      parameter(ckf = 3.093667726280136d0)
      parameter(f13 = 0.333333333333333d0)
C     Spin-unpolarized case
      if (.not.dospin) then
C       Density and kF
        rho = rhot
        akf = ckf*(rho**f13)
        a = mu/(2.d0*akf)
        a2 = a*a
        a3 = a2*a

C       Test on the value of a

C       Limit for small a (expansion not so important as for large a)
        if (a.lt.1.d-9) then
          e = -3.d0/8.d0*rho*(24.d0*rho/pi)**f13

C       Intermediate values of a
        elseif (a.le.100) then
          e = - (rho*(24.d0*rho/pi)**f13)
     >       *(3.d0/8.d0-a*(pisqrt*derf(0.5d0/a)+
     >       (2.d0*a-4.d0*a3)*dexp(-0.25d0/a2)-3.d0*a+4.d0*a3))

C       Expansion for large a
        elseif (a.lt.1.d+9) then
          e = - (rho*(24.d0*rho/pi)**f13)*1.d0/(96.d0*a2)

C       Limit for large a
        else
          e = 0.d0
        end if

      
C     Spin-polarized case
      else

C       Density and kF for spin alpha
!       rhoa=max(0.5d0*(rhot+rhos),0d0)
!       rhoa=2.d0*rhoa ! spin-scaling
        rhoa=max((rhot+rhos),0d0) ! rhoa is twice real rho_a
        akf = ckf*(rhoa**f13)
        a = mu/(2.d0*akf)
        a2 = a*a
        a3 = a2*a

C       Test on the value of a

C       Limit for small a (expansion not so important as for large a)
        if (a.lt.1.d-9) then
          ea = -3.d0/8.d0*rhoa*(24.d0*rhoa/pi)**f13

C       Intermediate values of a
        elseif (a.le.100) then
          ea = - (rhoa*(24.d0*rhoa/pi)**f13)
     >       *(3.d0/8.d0-a*(pisqrt*derf(0.5d0/a)+
     >       (2.d0*a-4.d0*a3)*dexp(-0.25d0/a2)-3.d0*a+4.d0*a3))

C       Expansion for large a
        elseif (a.lt.1.d+9) then
          ea = - (rhoa*(24.d0*rhoa/pi)**f13)*1.d0/(96.d0*a2)

C       Limit for large a
        else
          ea = 0.d0
        end if


C       Density and kF for spin beta
!       rhob = max(0.5d0*(rhot-rhos),0d0)
!       rhob = 2.d0*rhob ! spin-scaling
        rhob=max((rhot-rhos),0d0) ! rhob is twice real rho_b
C
        akf = ckf*(rhob**f13)
        a = mu/(2.d0*akf)
        a2 = a*a
        a3 = a2*a

C       Test on the value of a

C       Limit for small a (expansion not so important as for large a)
        if (a.lt.1.d-9) then
          eb = -3.d0/8.d0*rhob*(24.d0*rhob/pi)**f13

C       Intermediate values of a
        elseif (a.le.100) then
          eb = - (rhob*(24.d0*rhob/pi)**f13)
     >       *(3.d0/8.d0-a*(pisqrt*derf(0.5d0/a)+
     >       (2.d0*a-4.d0*a3)*dexp(-0.25d0/a2)-3.d0*a+4.d0*a3))

C       Expansion for large a
        elseif (a.lt.1.d+9) then
          eb = - (rhob*(24.d0*rhob/pi)**f13)*1.d0/(96.d0*a2)

C       Limit for large a
        else
          eb = 0.d0
        end if

C       divide by two because of spin scaling
        e = 0.5d0 * (ea + eb)

      endif

      return
      end
C****************************************************************************
      subroutine ELX_LDALAMSPIN (rhot,rhos,VLAMBDA,dospin,e)
C linear complement spin-dependent exchange LDA functional energy, Kamal SHARKAS 23/04/2011
C*****************************************************************************
      double precision rhot, rhos, VLAMBDA
      double precision e
      logical dospin

      call ESRX_LDAERFSPIN(rhot,rhos,0.d0,dospin,e)
      e = (1.d0 - VLAMBDA) * e

      return
       end
C*****************************************************************************

C****************************************************************************
      subroutine ESRC_LDAERFSPIN (rhot,rhos,mu,dospin,e)
C*****************************************************************************
C     Short-range spin-dependent LDA correlation functional from 
C       Paziani, Moroni, Gori-Giorgi and Bachelet, PRB 73, 155111 (2006)
C
C     subroutine adapted from Molpro
C
C     Input: rhot   : total density
C            rhos   : spin density
C            mu     : Interation parameter
C            dospin : use spin density
C
C     Ouput: e      : energy
C
C     Created: 18-08-09, J. Toulouse
C*****************************************************************************
      implicit none

      double precision rhot, rhos, mu
      logical dospin
      double precision e

      double precision f13, pi, rsfac
      double precision rs
      double precision ec,ecd,ecz,eclr

      double precision rhoa, rhob, z
      double precision ea, eb

      parameter(f13 = 0.333333333333333d0)
      parameter(pi = 3.141592653589793d0)
      parameter(rsfac = 0.620350490899400d0)

C     Spin-unpolarized case
      if (.not.dospin) then

        rs = rsfac/(rhot**f13)

        call ecPW(rs,0.0d0,ec,ecd,ecz)
        call ecorrlr(rs,0.0d0,mu,eclr)
        e=(ec-eclr)*rhot

C     Spin-polarized case
      else

        rs=rsfac/(rhot**f13)
        rhoa=max((rhot+rhos)*.5d0,1.0d-15)
        rhob=max((rhot-rhos)*.5d0,1.0d-15)
        z=(rhoa-rhob)/(rhoa+rhob)
        if (abs(z) > 1.0d0) 
     &   call quit('in ESRC_LDAERFSPIN numerical problem for |z| = 1.0')

        call ecPW(rs,z,ec,ecd,ecz)
        call ecorrlr(rs,z,mu,eclr)
        e=(ec-eclr)*rhot

      endif

      return
      end
C****************************************************************************
      subroutine ELC_LDALAMSPIN (rhot,rhos,VLAMBDA,dospin,e)
C linear complement spin-dependent non-scaled correlation LDA functional, Kamal SHARKAS 23/04/2011
C*****************************************************************************
      double precision rhot, rhos, VLAMBDA
      double precision e
      logical dospin

      call ESRC_LDAERFSPIN(rhot,rhos,0.d0,dospin,e)
      e = (1.d0 - VLAMBDA**2) * e

      return
       end
C*****************************************************************************
C****************************************************************************
      subroutine ESRC_MD_LDAERF (rhot,rhos,mu,dospin,e)
C*****************************************************************************
C     Short-range spin-dependent LDA correlation functional with multideterminant reference
C       for OEP calculations from Section V of 
C       Paziani, Moroni, Gori-Giorgi and Bachelet, PRB 73, 155111 (2006)
C
C     Input: rhot   : total density
C            rhos   : spin density
C            mu     : Interation parameter
C            dospin : use spin density
C
C     Ouput: e      : energy
C
C     Created: 26-08-11, J. Toulouse
C*****************************************************************************
      implicit none

      double precision rhot, rhos, mu
      logical dospin
      double precision e

      double precision e1

      call ESRC_LDAERFSPIN (rhot,rhos,mu,dospin,e1)
      call DELTA_LRSR_LDAERF (rhot,rhos,mu,dospin,e)
      e = e1 + e

      end

C****************************************************************************
      subroutine DELTA_LRSR_LDAERF (rhot,rhos,mu,dospin,e)
C*****************************************************************************
C     LDA approximation to term Delta_(LR-SR) from  Eq. 42 of
C       Paziani, Moroni, Gori-Giorgi and Bachelet, PRB 73, 155111 (2006)
C
C     Input: rhot   : total density
C            rhos   : spin density
C            mu     : Interation parameter
C            dospin : use spin density
C
C     Ouput: e      : energy
C
C     Warning: not tested for z != 0
C
C     Created: 26-08-11, J. Toulouse
C*****************************************************************************
      implicit none

      double precision rhot, rhos, mu
      logical dospin
      double precision e

      double precision f13, f83, pi, rsfac, alpha2
      double precision rs, rs2, rs3

      double precision rhoa, rhob, z, z2, onepz, onemz, zp, zm, phi8
      double precision g0f, g0s
      double precision bd2, bd3
      double precision c45, c4, c5
      double precision bc2, bc4, bc3t, bc5t, d0
      double precision delta2,delta3,delta4,delta5,delta6
      double precision delta

      parameter(f13 = 0.333333333333333d0)
      parameter(f83 = 2.6666666666666665d0)
      parameter(pi = 3.141592653589793d0)
      parameter(rsfac = 0.620350490899400d0)
      parameter(alpha2 = 0.2715053589826032d0)

      rs = rsfac/(rhot**f13)
      rs2 = rs*rs
      rs3 = rs2*rs

C     Spin-unpolarized case
      if (.not.dospin) then
       z = 0.d0

C     Spin-polarized case
      else
        rhoa=max((rhot+rhos)*.5d0,1.0d-15)
        rhob=max((rhot-rhos)*.5d0,1.0d-15)
        z=(rhoa-rhob)/(rhoa+rhob)
      endif

      z2=z*z
 
      bd2=dexp(-0.547d0*rs)*(-0.388d0*rs+0.676*rs2)/rs2
      bd3=dexp(-0.31d0*rs)*(-4.95d0*rs+rs2)/rs3

      onepz=1.d0+z
      onemz=1.d0-z
      phi8=0.5d0*(onepz**f83+onemz**f83)

      zp=onepz/2.d0
      zm=onemz/2.d0
      c45=(zp**2)*g0s(rs*zp**(-f13))+(zm**2)*g0s(rs*zm**(-f13))
      c4=c45+(1.d0-z2)*bd2-phi8/(5.d0*alpha2*rs2)
      c5=c45+(1.d0-z2)*bd3
 
      bc2=-3.d0*(1-z2)*(g0f(rs)-0.5d0)/(8.d0*rs3)
      bc4=-9.d0*c4/(64.d0*rs3)
      bc3t=-(1-z2)*g0f(rs)*(2.d0*dsqrt(2.d0)-1)/(2.d0*dsqrt(pi)*rs3)
      bc5t = -3.d0*c5*(3.d0-dsqrt(2.d0))/(20.d0*dsqrt(2.d0*pi)*rs3)

      d0=(0.70605d0+0.12927d0*z2)*rs
      delta2=0.073867d0*(rs**(1.5d0))
      delta3=4*(d0**6)*bc3t+(d0**8)*bc5t;
      delta4=4*(d0**6)*bc2+(d0**8)*bc4;
      delta5=(d0**8)*bc3t;
      delta6=(d0**8)*bc2;

      delta=(delta2*(mu**2)+delta3*(mu**3)+delta4*(mu**4)+delta5*(mu**5)
     >      +delta6*(mu**6))/((1+(d0**2)*(mu**2))**4)

C     multiply by rhot to get energy density
      e=delta*rhot

      end

C*****************************************************************************
      subroutine ecorrlr(rs,z,mu,eclr)
C*****************************************************************************
ccc Hartree atomic units used
ccc for given density parameter rs, spin polarization z
ccc and cutoff parameter mu
ccc gives the correlation energy of the LR gas
ccc  => eclr
      implicit none
      double precision rs,z,mu,eclr,ec,ecd,ecz
      double precision alpha,cf,phi
      double precision g0f,dpol,d2anti,d3anti,Qrpa
      double precision coe2,coe3,coe4,coe5
      double precision a1,a2,a3,a4,b0
      double precision q1a,q2a,q3a,t1a,t2a,t3a,adib
#include "pi.h"
!     pi=dacos(-1.d0)
      alpha=(4.d0/9.d0/pi)**(1.d0/3.d0)
      cf=1.d0/alpha

      phi=((1.d0+z)**(2.d0/3.d0)+(1.d0-z)**(2.d0/3.d0))/2.d0
cc parameters from the fit
      adib   = 0.784949d0
      q1a    = -0.388d0
      q2a    = 0.676d0
      q3a    = 0.547d0
      t1a    = -4.95d0
      t2a    = 1.d0
      t3a    = 0.31d0

      b0=adib*rs

      d2anti=(q1a*rs+q2a*rs**2)*exp(-abs(q3a)*rs)/rs**2
      d3anti=(t1a*rs+t2a*rs**2)*exp(-abs(t3a)*rs)/rs**3

      coe2=-3.d0/8.d0/rs**3*(1.d0-z**2)*(g0f(rs)-0.5d0)

      coe3=-(1.d0-z**2)*g0f(rs)/(sqrt(2.d0*pi)*rs**3)

      if(abs(z).eq.1.d0) then

        coe4=-9.d0/64.d0/rs**3*(dpol(rs)
     $        -cf**2*2**(5.d0/3.d0)/5.d0/rs**2)
        coe5=-9.d0/40.d0/(sqrt(2.d0*pi)*rs**3)*dpol(rs)

      else

         coe4=-9.d0/64.d0/rs**3*(((1.d0+z)/2.d0)**2*
     $        dpol(rs*(2/(1.d0+z))**(1.d0/3.d0))+((1.d0-z)/2.d0)**2
     $        *dpol(rs*(2.d0/(1.d0-z))**(1.d0/3.d0))+
     $        (1.-z**2)*d2anti-cf**2/10.d0*((1.d0+z)**(8.d0/3.d0)
     $        +(1.-z)**(8.d0/3.d0))/rs**2)

         coe5=-9.d0/40.d0/(sqrt(2.d0*pi)*rs**3)*(((1.d0+z)/2.d0)**2
     $        *dpol(rs*(2.d0/(1.d0+z))**(1.d0/3.d0))+((1.d0-z)/2.d0)**2
     $        *dpol(rs*(2.d0/(1.d0-z))**(1.d0/3.d0))+(1.d0-z**2)*
     $        d3anti)
      end if

      call ecPW(rs,z,ec,ecd,ecz)

      a1=4.d0*b0**6*coe3+b0**8*coe5
      a2=4.d0*b0**6*coe2+b0**8*coe4+6.d0*b0**4*ec
      a3=b0**8*coe3
      a4=b0**6*(b0**2*coe2+4.d0*ec)

      eclr=(phi**3*Qrpa(mu*sqrt(rs)/phi)+a1*mu**3+a2*mu**4+a3*mu**5+
     $     a4*mu**6+b0**8*mu**8*ec)/((1.d0+b0**2*mu**2)**4)

!      Write(6,*)'Qrpa=',Qrpa(mu*sqrt(rs)/phi)
!      Write(6,*)'sqrt(rs)',sqrt(rs)
!      Write(6,*)'phi=',phi
!      Write(6,*)'mu=',mu
!      Write(6,*)'mu*sqrt(rs)/phi=',mu*sqrt(rs)/phi
      return
      end

C*****************************************************************************
      subroutine vcorrlr(rs,z,mu,vclrup,vclrdown)
C*****************************************************************************
ccc Hartree atomic units used
ccc for given density parameter rs, spin polarization z
ccc and cutoff mu it gives the correlation LSD potential for LR interaction
ccc  => vclrup (spin-up electrons), vclrdown (spin-down electrons)
      implicit none
      double precision rs,z,mu,eclr,eclrrs,eclrz,vclrup,vclrdown
      double precision ec,ecd,ecz
      double precision alpha,cf,phi
      double precision g0f,dpol,d2anti,d3anti,Qrpa
      double precision g0d,dpold,d2antid,d3antid,Qrpad,x
      double precision coe2,coe3,coe4,coe5
      double precision coe2rs,coe3rs,coe4rs,coe5rs
      double precision coe2z,coe3z,coe4z,coe5z
      double precision a1,a2,a3,a4,a5,b0,a1rs,a2rs,a3rs,a4rs,a5rs,
     $     b0rs,a1z,a2z,a3z,a4z,a5z,b0z
      double precision q1a,q2a,q3a,t1a,t2a,t3a,adib

#include "pi.h"
!     pi=dacos(-1.d0)
      alpha=(4.d0/9.d0/pi)**(1.d0/3.d0)
      cf=1.d0/alpha

      phi=((1.d0+z)**(2.d0/3.d0)+(1.d0-z)**(2.d0/3.d0))/2.d0
cc parameters from the fit
      adib   = 0.784949d0
      q1a    = -0.388d0
      q2a    = 0.676d0
      q3a    = 0.547d0
      t1a    = -4.95d0
      t2a    = 1.d0
      t3a    = 0.31d0

      b0=adib*rs

      d2anti=(q1a+q2a*rs)*exp(-q3a*rs)/rs
      d3anti=(t1a+t2a*rs)*exp(-t3a*rs)/rs**2

      d2antid=-((q1a + q1a*q3a*rs + q2a*q3a*rs**2)/
     -    rs**2)*exp(-q3a*rs)
      d3antid=-((rs*t2a*(1 + rs*t3a) + t1a*(2 + rs*t3a))/
     -    rs**3)*exp(-rs*t3a)

      coe2=-3.d0/8.d0/rs**3*(1.d0-z**2)*(g0f(rs)-0.5d0)
      coe2rs=-3.d0/8.d0/rs**3*(1.d0-z**2)*g0d(rs)+
     $     9.d0/8.d0/rs**4*(1.d0-z**2)*(g0f(rs)-0.5d0)
      coe2z=-3.d0/8.d0/rs**3*(-2.d0*z)*(g0f(rs)-0.5d0)

      coe3=-(1.d0-z**2)*g0f(rs)/(sqrt(2.d0*pi)*rs**3)
      coe3rs=-(1.d0-z**2)*g0d(rs)/(sqrt(2.d0*pi)*rs**3)+
     $    3.d0*(1.d0-z**2)*g0f(rs)/(sqrt(2.d0*pi)*rs**4)
      coe3z=2.d0*z*g0f(rs)/(sqrt(2.d0*pi)*rs**3)

      if(abs(z).eq.1.d0) then

        coe4=-9.d0/64.d0/rs**3*(dpol(rs)
     $        -cf**2*2**(5.d0/3.d0)/5.d0/rs**2)
        coe4rs=-3.d0/rs*coe4-9.d0/64.d0/rs**3*(dpold(rs)
     $        +2.d0*cf**2*2**(5.d0/3.d0)/5.d0/rs**3)
        coe4z=-9.d0/64.d0/rs**3*(dpol(rs)-rs/6.d0*dpold(rs)-2.d0*d2anti
     $       -4.d0/15.d0/rs**2*cf**2*2.d0**(5.d0/3.d0))*z
        coe5=-9.d0/40.d0/(sqrt(2.d0*pi)*rs**3)*dpol(rs)
        coe5rs=-3.d0/rs*coe5-9.d0/40.d0/(sqrt(2.d0*pi)*rs**3)*dpold(rs)
        coe5z=-9.d0/40.d0/(sqrt(2.d0*pi)*rs**3)*(dpol(rs)-rs/6.d0*
     $       dpold(rs)-2.d0*d3anti)*z

      else

         coe4=-9.d0/64.d0/rs**3*(((1.d0+z)/2.d0)**2*
     $        dpol(rs*(2/(1.d0+z))**(1.d0/3.d0))+((1.d0-z)/2.d0)**2
     $        *dpol(rs*(2.d0/(1.d0-z))**(1.d0/3.d0))+
     $        (1.-z**2)*d2anti-cf**2/10.d0*((1.d0+z)**(8.d0/3.d0)
     $        +(1.-z)**(8.d0/3.d0))/rs**2)
         coe4rs=-3.d0/rs*coe4-9.d0/64.d0/rs**3*(
     $        ((1.d0+z)/2.d0)**(5.d0/3.d0)*dpold(rs*(2/(1.d0+z))**
     $        (1.d0/3.d0))+((1.d0-z)/2.d0)**(5.d0/3.d0)*
     $        dpold(rs*(2/(1.d0-z))**(1.d0/3.d0))+(1.d0-z**2)*
     $        d2antid+cf**2/5.d0*((1.d0+z)**(8.d0/3.d0)
     $        +(1.d0-z)**(8.d0/3.d0))/rs**3)
         coe4z=-9.d0/64.d0/rs**3*(1.d0/2.d0*(1.d0+z)*
     $        dpol(rs*(2/(1.d0+z))**(1.d0/3.d0))-1.d0/2.d0*(1.d0-z)*
     $        dpol(rs*(2/(1.d0-z))**(1.d0/3.d0))-rs/6.d0*
     $        ((1.d0+z)/2.d0)**(2.d0/3.d0)*dpold(rs*(2/(1.d0+z))
     $        **(1.d0/3.d0))+rs/6.d0*((1.d0-z)/2.d0)**(2.d0/3.d0)
     $        *dpold(rs*(2/(1.d0-z))**(1.d0/3.d0))-2.d0*z*d2anti-
     $        4.d0/15.d0/rs**2*cf**2*((1.d0+z)**(5.d0/3.d0)-
     $        (1.d0-z)**(5.d0/3.d0)))

         coe5=-9.d0/40.d0/(sqrt(2.d0*pi)*rs**3)*(((1.d0+z)/2.d0)**2
     $        *dpol(rs*(2.d0/(1.d0+z))**(1.d0/3.d0))+((1.d0-z)/2.d0)**2
     $        *dpol(rs*(2.d0/(1.d0-z))**(1.d0/3.d0))+(1.d0-z**2)*
     $        d3anti)
         coe5rs=-3.d0/rs*coe5-9.d0/(40.d0*sqrt(2.d0*pi)*rs**3)*(
     $        ((1.d0+z)/2.d0)**(5.d0/3.d0)*dpold(rs*(2/(1.d0+z))**
     $        (1.d0/3.d0))+((1.d0-z)/2.d0)**(5.d0/3.d0)*
     $        dpold(rs*(2/(1.d0-z))**(1.d0/3.d0))+(1.d0-z**2)*
     $        d3antid)
         coe5z=-9.d0/40.d0/(sqrt(2.d0*pi)*rs**3)*(1.d0/2.d0*(1.d0+z)*
     $        dpol(rs*(2/(1.d0+z))**(1.d0/3.d0))-1.d0/2.d0*(1.d0-z)*
     $        dpol(rs*(2/(1.d0-z))**(1.d0/3.d0))-rs/6.d0*
     $        ((1.d0+z)/2.d0)**(2.d0/3.d0)*dpold(rs*(2/(1.d0+z))
     $        **(1.d0/3.d0))+rs/6.d0*((1.d0-z)/2.d0)**(2.d0/3.d0)
     $        *dpold(rs*(2/(1.d0-z))**(1.d0/3.d0))-2.d0*z*d3anti)

      end if

      call ecPW(rs,z,ec,ecd,ecz)

      a1=4.d0*b0**6*coe3+b0**8*coe5
      a1rs=24.d0*adib*b0**5*coe3+4.d0*b0**6*coe3rs+8.d0*adib*b0**7*
     $     coe5+b0**8*coe5rs
      a1z=4.d0*b0**6*coe3z+b0**8*coe5z

      a2=4.d0*b0**6*coe2+b0**8*coe4+6.d0*b0**4*ec
      a2rs=24.d0*adib*b0**5*coe2+4.d0*b0**6*coe2rs+8.d0*adib*b0**7*
     $     coe4+b0**8*coe4rs+24.d0*adib*b0**3*ec+6.d0*b0**4*ecd
      a2z=4.d0*b0**6*coe2z+b0**8*coe4z+6.d0*b0**4*ecz

      a3=b0**8*coe3
      a3rs=8.d0*adib*b0**7*coe3+b0**8*coe3rs
      a3z=b0**8*coe3z

      a4=b0**6*(b0**2*coe2+4.d0*ec)
      a4rs=8.d0*adib*b0**7*coe2+b0**8*coe2rs+24.d0*adib*b0**5*ec+
     $     4.d0*b0**6*ecd
      a4z=b0**6*(b0**2*coe2z+4.d0*ecz)

      a5=b0**8*ec
      a5rs=8.d0*adib*b0**7*ec+b0**8*ecd
      a5z=b0**8*ecz

      x=mu*sqrt(rs)/phi

      eclr=(phi**3*Qrpa(x)+a1*mu**3+a2*mu**4+a3*mu**5+
     $     a4*mu**6+a5*mu**8)/((1.d0+b0**2*mu**2)**4)

      eclrrs=-4.d0/(1.d0+b0**2*mu**2)*2.d0*adib*b0*mu**2*eclr+
     $     1.d0/((1.d0+b0**2*mu**2)**4)*(phi**2*mu/(2.d0*sqrt(rs))
     $     *Qrpad(x)+
     $     a1rs*mu**3+a2rs*mu**4+a3rs*mu**5+a4rs*mu**6+a5rs*mu**8)


      if(z.eq.1.d0) then
         vclrup=eclr-rs/3.d0*eclrrs
         vclrdown=0.d0
      elseif(z.eq.-1.d0) then
         vclrup=0.d0
         vclrdown=eclr-rs/3.d0*eclrrs
      else

         eclrz=(phi**2*((1.d0+z)**(-1.d0/3.d0)-(1.d0-z)**(-1.d0/3.d0))
     $        *Qrpa(x)-phi*Qrpad(x)*mu*sqrt(rs)*((1.d0+z)**(-1.d0/3.d0)
     $        -(1.d0-z)**(-1.d0/3.d0))/3.d0+
     $        a1z*mu**3+a2z*mu**4+a3z*mu**5+
     $        a4z*mu**6+a5z*mu**8)/((1.d0+b0**2*mu**2)**4)

         vclrup=eclr-rs/3.d0*eclrrs-(z-1.d0)*eclrz
         vclrdown=eclr-rs/3.d0*eclrrs-(z+1.d0)*eclrz
      end if
      return
      end

C*****************************************************************************
      double precision function g0f(x)
C*****************************************************************************
ccc on-top pair-distribution function
ccc Gori-Giorgi and Perdew, PRB 64, 155102 (2001)
ccc x -> rs
      implicit none
      double precision C0f,D0f,E0f,F0f,x
      C0f             = 0.0819306d0
      D0f             = 0.752411d0
      E0f             = -0.0127713d0
      F0f             = 0.00185898d0
      g0f=(1.d0-(0.7317d0-D0f)*x+C0f*x**2+E0f*x**3+
     $     F0f*x**4)*exp(-abs(D0f)*x)/2.d0
      return
      end

C*****************************************************************************
      double precision function g0d(rs)
C*****************************************************************************
ccc derivative of on-top pair-distribution function
ccc Gori-Giorgi and Perdew, PRB 64, 155102 (2001)
      implicit none
      double precision Bg0,Cg0,Dg0,Eg0,Fg0,rs
      Cg0             = 0.0819306d0
      Fg0             = 0.752411d0
      Dg0             = -0.0127713d0
      Eg0             = 0.00185898d0
      Bg0             =0.7317d0-Fg0
      g0d=(-Bg0+2*Cg0*rs+3*Dg0*rs**2+4*Eg0*rs**3)/2.d0*exp(-Fg0*rs)
     -   - (Fg0*(1 - Bg0*rs + Cg0*rs**2 + Dg0*rs**3 + Eg0*rs**4))/
     -   2.d0*exp(-Fg0*rs)
      return
      end

C*****************************************************************************
      double precision function dpol(rs)
C*****************************************************************************
      implicit none
      double precision cf,rs,p2p,p3p
#include "pi.h"
!     pi=dacos(-1.d0)
      cf=(9.d0*pi/4.d0)**(1.d0/3.d0)
      p2p    = 0.04d0
      p3p    = 0.4319d0
      dpol=2.d0**(5.d0/3.d0)/5.d0*cf**2/rs**2*(1.d0+(p3p-0.454555d0)*rs)
     $     /(1.d0+p3p*rs+p2p*rs**2)
      return
      end

      double precision function dpold(rs)
      implicit none
      double precision cf,rs,p2p,p3p
#include "pi.h"
!     pi=dacos(-1.d0)
      cf=(9.d0*pi/4.d0)**(1.d0/3.d0)
      p2p    = 0.04d0
      p3p    = 0.4319d0
      dpold=2.d0**(5.d0/3.d0)/5.d0*cf**2*
     - (-2. + (0.454555 - 4.*p3p)*rs +
     -    (-4.*p2p +
     -       (0.90911 - 2.*p3p)*p3p)*rs**2
     -      + p2p*(1.363665 - 3.*p3p)*
     -     rs**3)/
     -  (rs**3*(1. + p3p*rs + p2p*rs**2)**2)
      return
      end

C*****************************************************************************
      double precision function Qrpa(x)
C*****************************************************************************
      implicit none
      double precision a2,b2,c2,d2,x,Acoul
#include "pi.h"
!     pi=dacos(-1.d0)
      Acoul=2.d0*(log(2.d0)-1.d0)/pi**2
      a2              = 5.84605d0
      c2              = 3.91744d0
      d2              = 3.44851d0
      b2=d2-3.d0/(2.d0*pi*Acoul)*(4.d0/(9.d0*pi))**(1.d0/3.d0)
      Qrpa=Acoul*log((1.d0+a2*x+b2*x**2+c2*x**3)/(1.d0+a2*x+d2*x**2))
      return
      end

C*****************************************************************************
      double precision function Qrpad(x)
C*****************************************************************************
      implicit none
      double precision a2,b2,c2,d2,x,Acoul
#include "pi.h"
!     pi=dacos(-1.d0)
      Acoul=2.d0*(log(2.d0)-1.d0)/pi**2
      a2              = 5.84605d0
      c2              = 3.91744d0
      d2              = 3.44851d0
      b2=d2-3.d0/(2.d0*pi*Acoul)*(4.d0/(9.d0*pi))**(1.d0/3.d0)
      Qrpad=Acoul*((x*(b2*(2.d0 + a2*x) +
     -      c2*x*(3.d0 + 2.d0*a2*x) +
     -      d2*(-2.d0 - a2*x + c2*x**3)))/
     -  ((1.d0 + a2*x + d2*x**2)*
     -    (1.d0 + a2*x + b2*x**2 + c2*x**3)))
      return
      end

C*****************************************************************************
      subroutine ecPW(x,y,ec,ecd,ecz)
C*****************************************************************************
c correlation energy and its derivative w.r.t. rs and z at mu=infinity
c Perdew & Wang PRB 45, 13244 (1992)
c in Hartree; ec=ec(rs,zeta)
c x -> rs; y -> zeta
ccc ecd is d/drs ec
ccc ecz is d/dz ec
      implicit none
      double precision f02,ff,x,y,ec,ecd,ec0,ec0d,ec1,ec1d,
     $     aaa,G,Gd,alfac,alfacd,ecz
#include "pi.h"
!     pi=dacos(-1.d0)

      f02=4.d0/(9.d0*(2.d0**(1.d0/3.d0)-1.d0))

      ff=((1.d0+y)**(4.d0/3.d0)+(1.d0-y)**(4.d0/3.d0)-
     $     2.d0)/(2.d0**(4.d0/3.d0)-2.d0)

      aaa=(1.d0-log(2.d0))/pi**2
      call  GPW(x,aaa,0.21370d0,7.5957d0,3.5876d0,
     $     1.6382d0,0.49294d0,G,Gd)
      ec0 =G
      ec0d=Gd

      aaa=aaa*0.5d0
      call GPW(x,aaa,0.20548d0,14.1189d0,6.1977d0,
     $     3.3662d0,0.62517d0,G,Gd)
      ec1 =G
      ec1d=Gd
      call GPW(x,0.016887d0,0.11125d0,10.357d0,3.6231d0,
     $     0.88026d0,0.49671d0,G,Gd)
      alfac =-G
      alfacd=-Gd

      ec =ec0 +alfac*ff/f02*(1.d0-y**4)+(ec1-ec0)*ff*y**4
      ecd=ec0d+alfacd*ff/f02*(1.d0-y**4)+(ec1d-ec0d)*
     $     ff*y**4
      ecz=alfac*(-4.d0*y**3)*ff/f02+alfac*(1.d0-y**4)/f02*
     $     4.d0/3.d0*((1.d0+y)**(1.d0/3.d0)-(1.d0-y)**(1.d0/3.d0))/
     $     (2.d0**(4.d0/3.d0)-2.d0)+(ec1-ec0)*(4.d0*y**3*ff+
     $     4.d0/3.d0*((1.d0+y)**(1.d0/3.d0)-(1.d0-y)**(1.d0/3.d0))/
     $     (2.d0**(4.d0/3.d0)-2.d0)*y**4)

      return
      end

C*****************************************************************************
      subroutine GPW(x,Ac,alfa1,beta1,beta2,beta3,beta4,G,Gd)
C*****************************************************************************
ccc Gd is d/drs G
      implicit none
      double precision G,Gd,Ac,alfa1,beta1,beta2,beta3,beta4,x
      G=-2.d0*Ac*(1.d0+alfa1*x)*dlog(1.d0+1.d0/(2.d0*
     $     Ac*(beta1*x**0.5d0+
     $     beta2*x+beta3*x**1.5d0+beta4*x**2)))
      Gd=(1.d0+alfa1*x)*(beta2+beta1/(2.d0*sqrt(x))+3.d0*beta3*
     $     sqrt(x)/2.d0+2.d0*beta4*x)/((beta1*sqrt(x)+beta2*x+
     $     beta3*x**(3.d0/2.d0)+beta4*x**2)**2*(1.d0+1.d0/
     $     (2.d0*Ac*(beta1*sqrt(x)+beta2*x+beta3*x**(3.d0/2.d0)+
     $     beta4*x**2))))-2.d0*Ac*alfa1*dlog(1.d0+1.d0/(2.d0*Ac*
     $     (beta1*sqrt(x)+beta2*x+beta3*x**(3.d0/2.d0)+
     $     beta4*x**2)))
      return
      end
C*****************************************************************************
      double precision function g0s(rs)
C*****************************************************************************
C     g"(0,rs,z=1) from Eq. 32 of
C       Paziani, Moroni, Gori-Giorgi and Bachelet, PRB 73, 155111 (2006)
C
C     Created: 26-08-11, J. Toulouse
C*****************************************************************************
      implicit none
      double precision rs
      double precision rs2, f53, alpha2
      parameter(f53 = 1.6666666666666667d0)
      parameter(alpha2 = 0.2715053589826032d0)
      rs2=rs*rs
      g0s=(2.d0**f53)*(1.d0-0.02267d0*rs)/((5.d0*alpha2*rs2)
     >    *(1.d0+0.4319d0*rs+0.04d0*rs2))
      end
C*****************************************************************************
      subroutine HS(z,k,H)
C
C     Smoothening formula for the SRCMULO and SRCPBELO functionals 
C     Cancels the discontinuety arising from the max() function.
C
C     INPUT:   
C             a,b :   max(a,b)
C             k   :   
C     OUTPUT:
C             H  
C
C*****************************************************************************
#include "dftcom.h"
      double precision a,b,z,h,k

      H = 1/(1+k*exp(-heaviside_pvalue*z))

      return
      end

@
