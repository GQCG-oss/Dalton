#define SRDFT_DEBUG 31
!
!...   Copyright (c) 2014 by the authors of Dalton (see below).
!...   All Rights Reserved.
!...
!...   The source code in this file is part of
!...   "Dalton, a molecular electronic structure program,
!...    Release DALTON2014 (2014), see http://daltonprogram.org"
!...
!...   This source code is provided under a written licence and may be
!...   used, copied, transmitted, or stored only in accord with that
!...   written licence.
!...
!...   In particular, no part of the source code or compiled modules may
!...   be distributed outside the research group of the licence holder.
!...   This means also that persons (e.g. post-docs) leaving the research
!...   group of the licence holder may not take any part of Dalton,
!...   including modified files, with him/her, unless that person has
!...   obtained his/her own licence.
!...
!...   For further information, including how to get a licence, see:
!...      http://daltonprogram.org
!
!


C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE SRDFT1JT(ND_SIM,EXCMAT,DMAT,DOLND,CORX,CORY,CORZ,
     &                  WEIGHT,NBUF,GSO,NCNT,DMAGAOSR,DOGGA,
     &                  DOERG,DOGRD,DOATR,RESULTS,WORK,LWORK,IPRINT_in)
C*****************************************************************************
C     Calculate DFT energy and potential contributions for
C     SR-DFT hybrid methods
C
C     Based on the routine SRDFT1 of J. K. Pedersen
C
C    Input: ND_SIM: number of input density matrices and output potential matrices
C                  DOERG   true: energy and Vxc potential matrix
C                  DOGRD   true: molecular gradient
C                  DOATR   true: electronic Hessian, non-linear Exc second derivative terms
C                  TRIPLET true: triplet operators
C                  DMAT(1) = charge density matrix
C                  DMAT(2) = 1-index transformed charge density matrix (DOATR)
C                  DMAT(3) = spin density matrix (DFT_SPINDNS)
C                  DMAT(4) = 1-index transformed spin density matrix (DFT_SPINDNS and DOATR)
C            (if SRHYBR then different ordering of DMAT matrices)
C            (Note that the order of DMATs also fits for gradient calculations, DOATR false:
C             for energy and gradien calculations DMAT(2) will be the DVAO matrix needed
C             for Coulomb and exchange Fock matrices and not needed for SRDFT.)
C
C                  EXCMAT(1) = charge density potential matrix
C                  EXCMAT(2) = spin density potential matrix (DFT_SPINDNS)
C
C     Created : 15-02-05, J. Toulouse
C     Modified: 17-08-09, J. Toulouse, add spin density
C     Modified: Feb. 2016 E. Hedegaard add spin gradient
C*****************************************************************************
#include "implicit.h"
#include "priunit.h"
#include "mxcent.h"
#include "dummy.h"
! infpar.h : MYNUM, NODTOT
#include "maxorb.h"
#include "gnrinf.h"
#include "infpar.h"
#include "infinp.h"
#include "inforb.h"
#include "infvar.h"
#include "inftap.h"
#include "nuclei.h"
#include "dftinf.h"
#include "dftcom.h"
#include "chrnos.h"

      PARAMETER (D0 = 0.0D0, DP5 = 0.5D0, D1 = 1.0D0, D2 = 2.0D0)

      LOGICAL   DOLND,DOGGA,DOERG,DOGRD,DOATR,FROMVX

      REAL*8    EXCMAT(NBAST,NBAST,*), DMAT(N2BASX,*),
     &          CORX(NBUF),CORY(NBUF),CORZ(NBUF),WEIGHT(NBUF),
     &          GSO(NBAST*NTYPSO),NCNT(NBAST),
     &          DMAGAOSR(NBAST,2),
     &          COR(3),RESULTS(11),WORK(LWORK)

      CHARACTER*17 QUADNAME

      INTEGER, SAVE :: NTOT_DFTGRID_save = -1

      REAL*8 RHO(4), RHG(3,4)
C     ... RHO(1) = RHOC = rho_a + rho_b
C     ... RHO(2) = RHOS = rho_a - rho_b
C     ... RHO(3) = RHOA = rho_a
C     ... RHO(4) = RHOB = rho_b
C     ... RHG(1:3,1) = RHGC(1:3) = grad ( rho_a + rho_b ) = grad ( rho_c )
C     ... RHG(1:3,2) = RHGS(1:3) = grad ( rho_a - rho_b ) = grad ( rho_s )
C     ... RHG(1:3,3) = RHGA(1:3) = grad ( rho_a )
C     ... RHG(1:3,4) = RHGB(1:3) = grad ( rho_b )

!     these are not initialized to zero!
      real*8   Ex,  d1Ex(5),  d2Ex(15)
      ! d1Ex(1:5) =   d1Exdrhoc, d1Exdrhos, d1Exdgrdcc, d1Exdgrdss, d1Exdgrdcs

      real*8   Ec,  d1Ec(5),  d2Ec(15)
      ! d1Ec(1:5) =   d1Ecdrhoc, d1Ecdrhos, d1Ecdgrdcc, d1Ecdgrdss, d1Ecdgrdcs

      real*8   Exc, d1Exc(5), d2Exc(15)
      ! d1Exc(1:5) =  d1Excdrhoc, d1Excdrhos, d1Excdgrdcc, d1Excdgrdss, d1Excdgrdcs

#if SRDFT_DEBUG > 10
      real*8    :: print_thr
      print_thr = 0.0d0
#endif

      IPRINT = MAX(IPRINT_in,SRDFT_DEBUG)

!     Debug
      IF (IPRINT .GE. 5) THEN
      WRITE(LUPRI,*) 'SRDFT1JT: entering, ND_SIM = ',ND_SIM
      WRITE(LUPRI,*) 'SRDFT1JT: MYNUM, NODTOT = ',MYNUM,NODTOT
      WRITE(LUPRI,*) 'SRDFT1JT: LUPRI,IPRINT  =',LUPRI, IPRINT
      WRITE(LUPRI,*) 'SRDFT1JT: CHIVAL =',CHIVAL
      WRITE(LUPRI,*) 'SRDFT1JT: HFXFAC =',HFXFAC
      WRITE(LUPRI,*) 'SRDFT1JT: DOERG,DOATR,DOGRD,DOGGA  =',
     &   DOERG,DOATR,DOGRD,DOGGA
      WRITE(LUPRI,*) 'SRDFT1JT: ERFEXP(0:2)=',ERFEXP(0:2)
      WRITE(LUPRI,*) 'SRDFT1JT: DOSRX_PBERI=',DOSRX_PBERI
      WRITE(LUPRI,*) 'SRDFT1JT: DFT_SPINDNS=',DFT_SPINDNS
      flush(lupri)
      IF (IPRINT .GE. 12) THEN
      WRITE(LUPRI,*) 'D_TOT_AO matrix:'
      call output(DMAT(1,1),1,nbast,1,nbast,nbast,nbast,-1,lupri)
      IF (DOATR) THEN
         WRITE(LUPRI,*) 'DX_TOT_AO matrix for DOATR true:'
         call output(DMAT(1,2),1,nbast,1,nbast,nbast,nbast,-1,lupri)
      END IF
      IF (DFT_SPINDNS) THEN
         WRITE(LUPRI,*) 'D_SPIN_AO matrix:'
         call output(DMAT(1,3),1,nbast,1,nbast,nbast,nbast,-1,lupri)
         IF (DOATR) THEN
            WRITE(LUPRI,*) 'DX_SPIN_AO matrix for DOATR:'
            call output(DMAT(1,4),1,nbast,1,nbast,nbast,nbast,-1,lupri)
         END IF
      END IF
      END IF ! iprint .ge. 12
      flush(lupri)
      END IF ! iprint .ge. 5

!     Is the requested calculation implemented ?

      IF (ND_SIM .NE. 1) THEN
         WRITE(LUPRI,*) 'SRDFT1: illegal ND_SIM ',ND_SIM
         CALL QUIT('SRDFT1jt: illegal ND_SIM value')
      END IF

      IF (DOGRD) THEN
         CALL QUIT(
     &   'SRDFT1JT: molecular gradient (DOGRD) not implemented yet')
      END IF

      IF (DOLND) THEN
         CALL QUIT(
     &   'SRDFT1JT: London orbitals (DOLND) not implemented yet')
      END IF

C     Initializations -------------------------------------------------------

      RHG(1:3,1:4) = 0.0d0 ! so initialized for LDA

      ! edh the arrays are also zeroed in SRDFTEXCJT
      d1Ex(1:5)  = 0.0d0
      d1Ec(1:5)  = 0.0d0
      !---------------

!     (Integrated) exchange and correlation energies
      ExInt  = D0
      EcInt  = D0

C     DFT grid (NTOT_DFTGRID is the total number of grid points)
      IF (.NOT.DFTGRID_DONE_OLD .OR. NTOT_DFTGRID_save .LE. 0) THEN
         CALL MAKE_DFTGRID(WORK,LWORK,NTOT_DFTGRID,1,.FALSE.)
         CALL CONDFT
         NTOT_DFTGRID_save = NTOT_DFTGRID
         DFTGRID_DONE_OLD = .TRUE.
      ELSE
         NTOT_DFTGRID = NTOT_DFTGRID_save
         ! because wrong NTOT_DFTGRID has been transferred from master in SRDFT_PAR_NODE
      END IF

C     Electron number
      ELCTRN = D0

C     Integrated spin density
      SPINDEN = D0

C     Thresholds for screening
C     THRELCTRN makes sure that error in no. of electrons
C     from grid integration less than DFTHR
      THRELCTOT = 1.0D-7
      THRELCTRN = D0
      THRESRHO  = 1.0D-8
      THRDRHO   = D0
      DFTHR0    = D0
      DFTHRI    = D0
      DFTHRL    = D0

C     Skipped grid points and nb of electrons
      NSKIP1 = 0
      ELCTRSKIP = D0
C
C     Counter for how many times RHO(2) > RHO(1)
      N_RS_GT_RT = 0

C     For quadrature integration
C
C     Make quadname: Can take 9999 procs
C
      IF (MYNUM .EQ. 0) THEN
         QUADNAME = 'DALTON.QUAD'
      ELSE
         QUADNAME = 'DALTON.QUAD.n'//chrnos(mynum/1000)
     &     //chrnos((mynum-(mynum/1000)*1000)/100)
     &     //chrnos((mynum-(mynum/100)*100)/10)
     &     //chrnos(mynum-(mynum/10)*10)
      END IF
C
      LUQUAD = -1
      CALL GPOPEN(LUQUAD,QUADNAME,'OLD','SEQUENTIAL',
     &     'UNFORMATTED',IDUMMY,LDUMMY)
C
      IF (MYNUM .EQ. 0) THEN
         NPNTS_PER_NODE = NTOT_DFTGRID
         my_first_point = 1
         my_last_point  = NTOT_DFTGRID
      ELSE
         NPNTS_PER_NODE = (NTOT_DFTGRID-1)/NODTOT + 1
         my_first_point = NPNTS_PER_NODE*(MYNUM-1) + 1
         my_last_point  = MIN(NPNTS_PER_NODE*MYNUM, NTOT_DFTGRID)
      END IF
      if (iprint .ge. 5) then
         write(lupri,*)
     &      'MYNUM,NPNTS_PER_NODE,my_first_point,my_last_point',
     &       MYNUM,NPNTS_PER_NODE,my_first_point,my_last_point
         flush(lupri)
      end if
      NPNTS = 0
  200 CONTINUE
      READ(LUQUAD) NPOINT
      if (iprint .ge. 5) then
         write(lupri,*) 'NPOINT from LUQUAD',NPOINT
         IPNT = 1
         if (npoint.gt.0)
     &   WRITE (LUPRI,'(A,I8,3F15.8,1P,D15.8)') 'Grid point',
     &      IPNT,CORX(IPNT),CORY(IPNT),CORZ(IPNT),WEIGHT(IPNT)
      end if

      IF (NPOINT.GT.0) THEN
         NPNT1 = NPNTS + 1       ! first integration point from this record
         NPNTS = NPNTS + NPOINT  ! last  integration point from this record
         IPNT_ST  = max(NPNT1,my_first_point) + 1 - NPNT1
         IPNT_END = min(NPNTS,my_last_point) + 1 - NPNT1
         if (iprint .ge. 5) then
            write(lupri,*)
     &      'MYNUM,IPNT_ST,IPNT_END', MYNUM,IPNT_ST,IPNT_END
            flush(lupri)
         end if
         IF (IPNT_ST .GT. IPNT_END) THEN
            if (iprint .ge. 5) write(lupri,*) 'Skipping this record'
            READ (LUQUAD) ! skip this record
            GO TO 200
         END IF
         CALL REAQUA_OLD(CORX,CORY,CORZ,WEIGHT,LUQUAD,NPOINT)

C   Loop over grid points -----------------------------------------------

      DO 300 IPNT = IPNT_ST, IPNT_END

C     Quadrature weight
      WGHT  = WEIGHT(IPNT)
      WGHTX = (1.0D0-HFXFAC)*WGHT
      WGHTC = WGHT

C     Get AOs
      THRINT = DFTHRI/WGHT
      COR(1) = CORX(IPNT)
      COR(2) = CORY(IPNT)
      COR(3) = CORZ(IPNT)

!     print for every 1000th grid point if iprint .gt. 10
      IF (IPRINT .GT. 10 .AND. MOD(IPNT,1000) .EQ. 1) THEN
         IPRINT_x = iprint
      ELSE
         IPRINT_x = 0
      END IF

      CALL GETSOS(GSO,NCNT,COR,WORK,LWORK,NBAST,DOLND,DOGGA,
     &            THRINT,IPRINT_x)

C     Density
      CALL GETRHO_OLD(DMAT(1,1),GSO(KSO0),RHO(1),rhoc13,
     &       DMAGAOSR(1,1),THRINT,IPRINT_x)

C     Contribution to electron number (N_alpha + N_beta)
      DELCTRN = WGHT*RHO(1)

      IF (iprint_x .gt. 10) then
C        Print grid information
         WRITE (LUPRI,'(A,I8,3F15.8,1P,D15.8)') 'Grid point',
     &      IPNT,CORX(IPNT),CORY(IPNT),CORZ(IPNT),WEIGHT(IPNT)
         WRITE (LUPRI,*) 'RHOC, DELCTRN, ELCTRN',
     &      RHO(1),DELCTRN,ELCTRN
      END IF

C     Screening
      IF (ABS(DELCTRN).LE.THRELCTRN .OR.
     &          RHO(1).LE.THRESRHO) THEN

         IF (iprint_x .gt. 10) then
            write(lupri,*) 'Skipping this point'
         END IF
         NSKIP1 = NSKIP1 + 1
         ELCTRSKIP = ELCTRSKIP + DELCTRN
         THRELCTRN = (THRELCTOT-ELCTRSKIP)/100
         GO TO 300
C        ... skip this point, go to next grid point
      END IF

C     Spin density rho_s ( in RHO(2) )
      IF (DFT_SPINDNS) THEN
C        DMAT(1,3) is the spin density matrix
         CALL GETRHO_OLD(DMAT(1,3),GSO(KSO0),RHO(2),RHOS13,
     &                   DMAGAOSR(1,2),THRINT,IPRINT)

         IF (DFT_LOCALSPIN) THEN
C        In our local spin model we can get unphysical densities
C        because we allow DS > DV in some regions.
            IF (RHO(2) .GT. RHO(1)) THEN
                RHO(2) = RHO(1)
                N_RS_GT_RT = N_RS_GT_RT + 1
            END IF
         END IF
C        Contribution to spin density (N_alpha - N_beta)
         SPINDEN = SPINDEN + WGHT*RHO(2)
      ELSE
        RHO(2) = 0.0D0
      END IF
      RHO(3) = 0.5d0 * ( RHO(1) + RHO(2) ) ! rho_a
      RHO(4) = 0.5d0 * ( RHO(1) - RHO(2) ) ! rho_b

C     Gradient of density
      IF (DOGGA) THEN
C       GSO(KSO1)*DMAGAOSR
        CALL DGEMV('T',NBAST,3,D2,GSO(KSO1),NBAST,DMAGAOSR(1,1),
     &     1,D0,RHG(1,1),1)
C
        IF (DFT_SPINDNS) THEN
           CALL DGEMV('T',NBAST,3,D2,GSO(KSO1),NBAST,DMAGAOSR(1,2),
     &        1,D0,RHG(1,2),1)
        ELSE
           RHG(1,2) = 0.0D0 ! RHGS is zero
           RHG(2,2) = 0.0D0
           RHG(3,2) = 0.0D0
        ENDIF
        DO I = 1,3
           RHG(I,3) = 0.5d0 * ( RHG(I,1) + RHG(I,2) ) ! RHGA
           RHG(I,4) = 0.5d0 * ( RHG(I,1) - RHG(I,2) ) ! RHGB
        END DO
      ENDIF
C
C     Number of electrons
      ELCTRN = ELCTRN + DELCTRN

      IF (DOERG) THEN
C
C     Exchange and correlation energies and derivatives
      NORDER = 1  ! first-order derivatives
C
      CALL SRDFTEXCJT(RHO,RHG,CHIVAL,NORDER,ERFEXP,
     >                Ex,d1Ex,d2Ex,Ec,d1Ec,d2Ec,VLAMBDA)
C     Summation with quadrature weigths
      ExInt     = ExInt + WGHTX*Ex
      EcInt     = EcInt + WGHTC*Ec

      end if

C      Sum of exchange and correlation
       d1Exc(1:5) = WGHTX*d1Ex(1:5) + WGHTC*d1Ec(1:5)

       IF (iprint_x .gt. 10) then
          write(lupri,*)'rhoc, rhcg ',rho(1),rhg(1:3,1)
          write(lupri,*)'rhos, rhsg ',rho(2),rhg(1:3,2)
          write(lupri,*)'rhoa, rhag ',rho(3),rhg(1:3,3)
          write(lupri,*)'rhob, rhbg ',rho(4),rhg(1:3,4)
          write(lupri,*)'Ex, ExInt',Ex,ExInt
          write(lupri,*)'Ec, EcInt',Ec,EcInt
          write(lupri,*)'WGHTX, WGHTC  ', WGHTX, WGHTC
          write(lupri,*)'d1Exdrhoc  ...', d1Ex(1:5)
          write(lupri,*)'d1Ecdrhoc  ...', d1Ec(1:5)
          write(lupri,*)'d1Excdrhoc ...', d1Exc(1:5)
       end if

C      Exchange-correlation contribution to Kohn-Sham matrix (charge and spin components)
       FROMVX = .FALSE.
       if (domcsrdft .and. docisrdft) then  !  only true for start-CI  (cf. routine OPST)
       ! Ignore spin in start CI ...  FIXME TODO
           CALL DFTKSM(EXCMAT,GSO(KSO0),GSO(KSO1),RHG(1,1),
     &                 d1Exc(1)  ,d1Exc(5)    ,DOGGA,FROMVX,DFTHRL)
!                      d1Excdrhoc,d1Excdgrdcc,DOGGA,FROMVX,DFTHRL)
       else if (domcsrdft .and. .not. docisrdft) then
          if (dogga .and. dft_spindns) then ! special treatment if gga + spin
          call quit('hjaaj: d1Excdgrdcs not implemented yet')
              CALL DFTKSMGGASPIN(EXCMAT,GSO(KSO0),GSO(KSO1),RHG,
     &             d1Exc,DFTHRL)
!    &             d1Excdrhoc,d1Excdgrdcc,d1Excdrhos,d1Excdgrdss,
!    &             d1Excdgrdcgrds,DFTHRL)
          else                              ! GGA without spin density or LDA
             CALL DFTKSM(EXCMAT,GSO(KSO0),GSO(KSO1),RHG(1,1),
     &                d1Exc(1)  ,d1Exc(5)    ,DOGGA,FROMVX,DFTHRL)
!    &                d1Excdrhoc,d1Excdgrdcc,DOGGA,FROMVX,DFTHRL)
             if (dft_spindns .and. .not. dogga) then ! i.e. LDA with spin density
                 CALL DFTKSM(EXCMAT(1,1,2),GSO(KSO0),GSO(KSO1),RHG(1,2),
     &                 d1Exc(2)  ,0.0d0,DOGGA,FROMVX,DFTHRL)
!    &                 d1Excdrhos,0.0d0,DOGGA,FROMVX,DFTHRL)
             end if
          end if
       else ! if hfsrdft
          IF (DFT_SPINDNS) CALL QUIT('no HFsrDFT with open shells')
             CALL DFTKSM(EXCMAT,GSO(KSO0),GSO(KSO1),RHG(1,1),
     &            d1Exc(1)  ,d1Exc(5)    ,DOGGA,FROMVX,DFTHRL)
!    &            d1Excdrhoc,d1Excdgrdcc,DOGGA,FROMVX,DFTHRL)
       end if

       ENDIF  !DOERG

C      Hessian transformation for second-order terms
       IF (DOATR) THEN
C        matrix 1 is DTAO
C        matrix 2 is DXTAO or DTTAO (DX*: 1-index transformed, DT*: transition density)
C        matrix 3 is DSAO
C        matrix 4 is DXSAO or DTSAO
         JDXTAO = 2
         JDXSAO = 4

#if SRDFT_DEBUG > 41
       print_thr = 1000.0d0
       do k = 1,2
         do i = 1, nbast
           do j = 1, i - 1
             if (abs(excmat(j,i,k)) > print_thr) then
                write(lupri,*)'edh 0 k, j, i', k, i, j, excmat(j,i,k)
             endif
           end do
         end do
       end do
#endif

! SRDFTLTRJT: SR short-range DFT density functional theory LTR linear transformation JT Julien Toulouse
        CALL SRDFTLTRJT(JWOPSY,DMAT(1,JDXTAO),DMAT(1,JDXSAO),EXCMAT,
     &                 WGHTX,WGHTC, GSO(KSO0),GSO(KSO1),
     &                 CHIVAL,VLAMBDA,ERFEXP,RHO,RHG,DMAGAOSR,DOGGA)

       ENDIF

#if SRDFT_DEBUG > 41
       print_thr = 50000.0d0
       do k = 1,2
         do i = 1, nbast
           do j = 1, i - 1
             if (abs(excmat(j,i,k)) > print_thr) then
                write(lupri,*)'edh 1 k, j, i', k, i, j, excmat(j,i,k)
             endif
           end do
         end do
       end do
#endif

C
  300    CONTINUE
C End of loop over grid points ------------------------------------------------
C
         GO TO 200
      ELSE IF (NPOINT .EQ.0 ) THEN
         GO TO 200
      END IF  !NPOINT.GT.0

C Termination --------------------------------------------------------------

#if SRDFT_DEBUG > 21
       print_thr = 10.0d0
       write(lupri,*) 'print_thr', print_thr
       do k = 1,2
         do i = 1, nbast
           do j = 1, i - 1
             if (abs(excmat(j,i,k)) > print_thr) then
                write(lupri,*)'edh 2 k, j, i', k, i, j, excmat(j,i,k)
             endif
           end do
         end do
       end do
#endif
      CALL GPCLOSE(LUQUAD,'KEEP')

      RESULTS(1) = ELCTRN
      RESULTS(2) = ELCTRSKIP
      RESULTS(3) = SPINDEN
      RESULTS(4) = ExInt
      RESULTS(5) = EcInt
      RESULTS(6) = N_RS_GT_RT
      ! LSRHYBR
      RESULTS(7:11) = 0.0D0

      RETURN
      END

C****************************************************************************
      SUBROUTINE SRDFTEXCJT(RHO,RHG, CHIVAL,NORDER,ERFEXP,
     >           Ex,d1Ex,d2Ex,Ec,d1Ec,d2Ec,VLAMBDA)
c*****************************************************************************
C    Driver for short-range DFT exchange and correlation
C    energies and derivatives
C
C    Based on the routine SRDFTEXC of J. K. Pedersen
C
C    Created : 15-02-05, J. Toulouse
C    Modified: 17-08-09, J. Toulouse, add spin density
C    Modified: 15-08-16, E. Hedegaard, add spin density gradient
C*****************************************************************************
#include "implicit.h"
#include "priunit.h"
#include "mxcent.h"
#include "maxorb.h"
#include "inforb.h"
#include "infinp.h"
#include "dftinf.h"
#include "dftcom.h"

      real*8  rho(4),rhg(3,4),CHIVAL,VLAMBDA ! input
      real*8  grd2(6) ! local array for variables derived from grad(rho(k)) in RHG(1:3,k)
!     grd2(1:6) = (grdcc, grdss, grdcs, grdaa, grdbb, grdab)
      integer NORDER
      logical ERFEXP(0:2)

      real*8   Ex, d1Ex(5), d2Ex(15)
      real*8   Ec, d1Ec(5), d2Ec(15)

C The new terms (edh: mu_new required??)
      real*8   mu !, mu_new

      save icall
      data icall/0/
C     functionals
      external ESRX_PBEHSEERF,  ESRX_PBETCSERF, ESRX_PBERIERF
      external ESRX_PBEGWSERF
      external ESRC_PBETCSJERF, ESRC_PBETCSERF, ESRC_PBERIERF
      external ESRC_LYPRIERF
      external ESRC_PBEWIERF,   ESRC_PBEGWSERF, ESRC_PBELOERF
      external ESRC_PBEGWSERF_PW92
C     spin functionals
      external ESRX_LDAERFSPIN, ESRC_LDAERFSPIN
      external ESRX_PBEGWSERFSPIN, ESRC_PBEGWSERFSPIN
      external ESRC_MULOC_GGA, ESRC_MULOD_GGA, ESRC_MULOE_GGA
C     sr mdc func
      external ESRC_MD_LDAERF

      ! for debug prints (counter for grid points)
      integer inpt

c  Exchange  ------------------------------------------------------------

      Ex      = 0.0d0
      d1Ex(:) = 0.0d0
      d2Ex(:) = 0.0d0

      icall = icall + 1
      IF (ERFEXP(0)) THEN
         write (lupri,*)
     &   'WARNING srdftexcjt: erfexp true in call no. ',icall
         erfexp(1:2) = .false.
!        CALL QUIT('erfgau not implemented in SRDFTEXCJT')
      END IF

!     Calculate the six variables related to four forms of grad(rho)
!     (grdcc, grdss, grdcs, grdaa, grdbb, grdab)
      grd2(1) = rhg(1,1)**2 + rhg(2,1)**2 + rhg(3,1)**2  ! grdcc
      grd2(2) = rhg(1,2)**2 + rhg(2,2)**2 + rhg(3,2)**2  ! grdss
      grd2(3) = rhg(1,1)*rhg(1,2) + rhg(2,1)*rhg(2,2)    ! grdcs = grad(rhoc) . grad(rhos)
     &        + rhg(3,1)*rhg(3,2)
      grd2(4) = rhg(1,3)**2 + rhg(2,3)**2 + rhg(3,3)**2  ! grdaa
      grd2(5) = rhg(1,4)**2 + rhg(2,4)**2 + rhg(3,4)**2  ! grdbb
      grd2(6) = rhg(1,3)*rhg(1,4) + rhg(2,3)*rhg(2,4)    ! grdab = grad(rhoa) . grad(rhob)
     &        + rhg(3,3)*rhg(3,4)

!     LDA exchange functional (to fit with corresponding correlation
!     functional) - see explanation with DOSRC_LDA_PW92
      IF(DOSRX_LDA_PW92) THEN
        rho(2) = 0.0d0
        call DESRSPIN(ESRX_LDAERFSPIN,rho(1),rho(2),CHIVAL,DFT_SPINDNS,
     >                NORDER,Ex,d1Ex,d2Ex)
      ENDIF

!     short-range exchange PBE of HSE
      IF(DOSRX_PBEHSE) THEN
        IF(.not. DFT_SPINDNS) THEN
           call DESR(ESRX_PBEHSEERF,rho,grd2,CHIVAL,NORDER,
     >        Ex,d1Ex,d2Ex)
        ELSE
           call quit(' srx_pbehse not implemented for DFT_SPINDNS')
        ENDIF
      ENDIF !  (DOSRX_PBEHSE)

!     short-range exchange PBE of TCS
      IF(DOSRX_PBETCS) THEN
        call DESR(ESRX_PBETCSERF,rho,grd2,CHIVAL,NORDER,Ex,d1Ex,d2Ex)
      ENDIF

!     short-range exchange PBE of GWS ! JT 11-08-09
      IF(DOSRX_PBEGWS) THEN
        call DESR(ESRX_PBEGWSERF,rho,grd2,CHIVAL,NORDER,Ex,d1Ex,d2Ex)
      ENDIF

C  Manu 01-02-2006 begin
!     short-range exchange RI
      IF(DOSRX_PBERI) THEN
        call DESR(ESRX_PBERIERF,rho,grd2,CHIVAL,NORDER,Ex,d1Ex,d2Ex)
      ENDIF
C  Manu 01-02-2006 end

!     short-range spin-dependent exchange LDA ! JT 11-08-09
      IF(DOSRX_LDA_S) THEN
        call DESRSPIN(ESRX_LDAERFSPIN,rho(1),rho(2),
     >             CHIVAL,DFT_SPINDNS,NORDER,Ex,d1Ex,d2Ex)
      ENDIF
      IF(DOSRX_PBEGWS_S) THEN
        call DESRX_SPINGGA(ESRX_PBEGWSERFSPIN,rho,grd2,CHIVAL,
     >                     norder,Ex,d1Ex,d2Ex)
      ENDIF

C linear complement spin-dependent exchange LDA functional, Kamal SHARKAS 09-05-11
      IF(DOLAX_LDAS)  THEN
        call ELX_LDALAMSPIN (rho(1),rho(2),VLAMBDA,DFT_SPINDNS,Ex)
        ! d1Ex(2), d1Ex(3) here ...
        call DELSPIN(ESRX_LDAERFSPIN,rho(1),rho(2),VLAMBDA,DFT_SPINDNS,
     >               NORDER,d1Ex,d2Ex)
      ENDIF

C linear complement exchange PBE functional, Kamal SHARKAS 19-05-11
      IF(DOLAX_PBEGWS) THEN
        call ELAX_PBEGWS(rho,grd2,VLAMBDA,Ex)
        ! d1Ex(2), d1Ex(3) here ...
        call DELA(ESRX_PBEGWSERF,rho,grd2,VLAMBDA,NORDER,
     >            d1Ex,d2Ex)
      ENDIF


C  Correlation  ----------------------------------------------------------

      Ec      = 0.0d0
      d1Ec(:) = 0.0d0
      d2Ec(:) = 0.0d0

      IF(DOSRC_LDA_PW92) THEN
        ! DESRSPIN called with DFT_SPINDNS = false gives LDA functional
        ! for closed shell (but with J. Toulouse new LDA based on PW92)
        rho(2)   = 0.0d0
        call DESRSPIN(ESRC_LDAERFSPIN,rho(1),rho(2),CHIVAL,DFT_SPINDNS,
     >                NORDER,Ec,d1Ec,d2Ec)
      ENDIF
!     short-range correlation PBE of TCS
      IF(DOSRC_PBETCS) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_PBETCSERF,rho,grd2,CHIVAL,NORDER,
     >            Ec,d1Ec,d2Ec)
      ENDIF

!     short-range correlation PBE of TCSJ
      IF(DOSRC_PBETCSJ) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_PBETCSJERF,rho,grd2,CHIVAL,NORDER,
     >            Ec,d1Ec,d2Ec)
      ENDIF

!     short-range correlation PBE of GWS
      IF(DOSRC_PBEGWS) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_PBEGWSERF,rho,grd2,CHIVAL,NORDER,
     >            Ec,d1Ec,d2Ec)
      ENDIF

!     Modified short-range correlation PBE of GWS
      IF(DOSRC_PBEGWS_PW92) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_PBEGWSERF_PW92,rho,grd2,CHIVAL,NORDER,
     >            Ec,d1Ec,d2Ec)
      ENDIF

!     rational interpolation
      IF(DOSRC_PBERI) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_PBERIERF,rho,grd2,CHIVAL,NORDER,
     >             Ec,d1Ec,d2Ec)
      ENDIF

!     rational interpolation LYP
      IF(DOSRC_LYPRI) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_LYPRIERF,rho,grd2,CHIVAL,NORDER,Ec,d1Ec,d2Ec)
      ENDIF
!     PBE local energy formula
      IF(DOSRC_PBELO) THEN
        call DESR(ESRC_PBELOERF,rho,grd2,CHIVAL,NORDER,Ec,d1Ec,d2Ec)
      ENDIF
!     weighted interpolation
      IF(DOSRC_PBEWI) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_PBEWIERF,rho,grd2,CHIVAL,NORDER,Ec,d1Ec,d2Ec)
      ENDIF

!     short-range spin-dependent correlation LDA ! JT 18-08-09
      IF(DOSRC_LDA_S) THEN
        ! d1Ec(2), d1Ec(3) here ...
        call DESRSPIN(ESRC_LDAERFSPIN,rho(1),rho(2),
     >             CHIVAL,DFT_SPINDNS,NORDER,Ec,d1Ec,d2Ec)
      ENDIF
      IF(DOSRC_PBEGWS_S) THEN
        ! PBEGWS_S is of type 3 (no grds and no grds.grdc dependency)
        call DESRC_SPINGGA(ESRC_PBEGWSERFSPIN,3,rho,grd2,CHIVAL,
     >                   norder,Ec,d1Ec,d2Ec)
      ENDIF
C Kamal SHARKAS 20-05-11 beg
C linear Complement spin-dependent (NON-Scaled) correlation LDA functional
       IF(DOLANSC_LDAS) THEN
        call ELC_LDALAMSPIN (rho(1),rho(2),VLAMBDA,DFT_SPINDNS,Ec)
        ! d1Ec(2), d1Ec(3) here ...
        call DELSPINnSC(ESRC_LDAERFSPIN,rho(1),rho(2),VLAMBDA,
     >                DFT_SPINDNS,NORDER,d1Ec,d2Ec)
       ENDIF

C Complement (NON-Scaled) correlation PBE functional
      IF(DOLANSC_PBEGWS) THEN
        call ELAC_PBEGWS(rho,grd2,VLAMBDA,Ec)
        ! d1Ec(3), d1Ec(3) here ...
        call DELANSC(ESRC_PBEGWSERF,rho,grd2,VLAMBDA,NORDER,d1Ec,d2Ec)
      ENDIF

C Complement Scaled correlation PBE functional
      IF(DOLASC_PBEGWS) THEN

        call ELASC_PBEGWS(rho,grd2,VLAMBDA,Ec)
        ! d1Ec(3), d1Ec(3) here ...
        call DELASC(ESRC_PBEGWSERF,rho,grd2,VLAMBDA,NORDER,d1Ec,d2Ec)

      ENDIF
C Kamal SHARKAS 20-05-11 end

!     short-range spin-dependent correlation LDA with multideterminant reference (for OEP) ! JT 26-08-11
!     ... or for RSDHf calculations (Manu 06-12-2012)
      IF(DOSRC_MD_LDA) THEN
!CASS        Write(LUPRI,*)'La nouvelle fonctionnelle'
        ! d1Ec(3), d1Ec(3) here ...
        call DESRSPIN(ESRC_MD_LDAERF,rho(1),rho(2),
     >             CHIVAL,DFT_SPINDNS,NORDER,Ec,d1Ec,d2Ec)
      ENDIF
!CASS      Write(LUPRI,*)'EC=',Ec

!     Short-range LDA functional with local CHIVAL parameter ! MNP 13-09-11
      IF(DOSRC_MULOC_GGA) THEN
C      IF (SRCMULOFAC) THEN
C         xfac = XMULFAC_READIN
C      ELSE
C         xfac = 1.0d0/4.0d0
C      END IF
C      mu = sqrt(grd2(1))/rho(1)
C      mu = xfac*mu
C      mu_new = max(mu,CHIVAL)
!      print *,'xfac,SRCMULOFAC,mu_new ==>', xfac, SRCMULOFAC,mu_new
        call ESRC_MULOC_GGA(rho,grd2,CHIVAL,Ec)
        call DESR(ESRC_MULOC_GGA,rho,grd2,CHIVAL,NORDER,
     >             Ec, d1Ec, d2Ec)
      ENDIF

!     Short-range LDA functional with local CHIVAL parameter ! MNP 13-09-11
      IF(DOSRC_MULOD_GGA) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_MULOD_GGA,rho,grd2,CHIVAL,NORDER,Ec,d1Ec,d2Ec)
      ENDIF
!     Short-range LDA functional with local CHIVAL parameter ! MNP 13-09-11
      IF(DOSRC_MULOE_GGA) THEN
        ! d1Ec(3), d1Ec(3) here ...
        call DESR(ESRC_MULOE_GGA,rho,grd2,CHIVAL,NORDER,Ec,d1Ec,d2Ec)
      ENDIF

      RETURN
      END

C**************************************************************************
      SUBROUTINE SRDFTLTRJT(KSYMOP,DTXMAT,DSXMAT,EXCMAT,
     &                      WGHTX,WGHTC,GAO,GAO1,
     &                      CHIVAL,VLAMBDA,ERFEXP,RHO,RHG, DGAO,DOGGA)
C**************************************************************************
C     Generate the 1-index transformed DFT Hessian
C     needed in second-order optimization for short-range DFT hybrids.
C
C     Based on the routine SRDFTLTR of J. K. Pedersen
C
C     Created : 15-02-05, J. Toulouse
C     Modified: 17-08-09, J. Toulouse,  add spin density
C     Modified: 16-02-16, E. Hedegaard, add spin gradient
C***************************************************************************
         implicit none
#include "priunit.h"
#include "mxcent.h"
#include "maxorb.h"
#include "inforb.h"
#include "infinp.h"
#include "nuclei.h"
#include "dftinf.h"
#include "dftcom.h"

!     input
      integer KSYMOP
      logical DOGGA,ERFEXP(0:2)
      real*8   RHO(4), RHG(3,4)
      real*8   CHIVAL,VLAMBDA
      real*8   DTXMAT(NBAST,NBAST),DSXMAT(NBAST,NBAST)
      real*8   GAO(NBAST),GAO1(NBAST,3), DGAO(NBAST,2)
      real*8   WGHTX,WGHTC
!     output
      real*8   EXCMAT(NBAST,NBAST,2)

!     local
      integer I, J, ISYM, JSYM, JEND, JSTR, ISTR, IEND
      integer NORDER

      real*8   ddot

      real*8   grdnrm, ZNV(2), BR(2), B0(2), B3(3,2), BMAX
      real*8   AR(2), AB(2), AX, AY, AZ, RX(2), RY(2), RZ(2)

      real*8   FAC0R, FAC0S, FACR, FACS
      real*8   FRR, FRZ, FZZ, FZ0
      real*8   FRS, FSS, FSZ, FSZ_S, FRZ_S, FZZ_S, FZ0_S, FZZ_SS
      real*8   G0, GX, GY, GZ

!     XC energies, and derivatives
      real*8   Ex, Ec, d1Ex(5), d1Ec(5), d2Ex(15), d2Ec(15)
!     real*8   d1Exdrhoc, d1Exdrhos, d1Exdgrdcc, d1Exdgrdss, d1Exgrdcs !d1Ex(1:5)
!     real*8   d1Ecdrhoc, d1Ecdrhos, d1Ecdgrdcc, d1Ecdgrdss, d1Ecgrdcs !d1Ec(1:5)

!     real*8   d2Exdrhocdrhoc, d2Exdrhocdrhos, d2Exdrhosdrhos
!     real*8   d2Exdrhocdgrdc, d2Exdrhosdgrdc, d2Exdgrdcdgrdc
!     real*8   d2Exdrhocdgrds, d2Exdrhosdgrds, d2Exdgrdcdgrds
!     real*8   d2Exdgrdsdgrds, etc ! d2Ex(15)

!     real*8   d2Ecdrhocdrhoc, d2Ecdrhocdrhos, d2Ecdrhosdrhos
!     real*8   d2Ecdrhocdgrdc, d2Ecdrhosdgrdc, d2Ecdgrdcdgrdc
!     real*8   d2Ecdrhocdgrds, d2Ecdrhosdgrds, d2Ecdgrdcdgrds
!     real*8   d2Ecdgrdsdgrds, etc ! d2Ec(15)

      ! For small values of rho to avoid NaN
      do i = 1,4
         if (abs(rho(i)) .lt. 1.d-30) rho(i) = 1.d-30
      end do

      ! DGAO(1,1) = DTXMAT*GAO; DTXMAT is 1-index transformed or transition total (charge) density matrix
      CALL DGEMV('N',NBAST,NBAST,1.0d0,
     &           DTXMAT,NBAST,GAO,1,0.0d0,DGAO(1,1),1)

      B0(1) = DDOT(NBAST,DGAO(1,1),1,GAO,1)
      BMAX = ABS(B0(1))
      IF (DOGGA) THEN
C        B3(1:3,1) = GAO1'*DGAO(1,1)
         CALL DGEMV('T',NBAST,3,1.0d0,GAO1,NBAST,
     &         DGAO(1,1),1,0.0d0,B3(1,1),1)
C        DGAO(1,1)= DTXMAT'*GAO !!! HJAAJ: is this necessary ? We have D*XMAT symmetrized!
         CALL DGEMV('T',NBAST,NBAST,1.0d0,DTXMAT,NBAST,
     &         GAO,1,0.0d0,DGAO(1,1),1)
C        B3(1:3,1) = B3(1:3,1) + GAO1(1:NBAST,1:3)'*DGAO((1:NBAST, 1)
         CALL DGEMV('T',NBAST,3,1.0d0,GAO1,NBAST,
     &         DGAO(1,1),1,1.0d0,B3(1,1),1)
         BMAX = MAX(BMAX, ABS(B3(1,1)),ABS(B3(2,1)),ABS(B3(3,1)))
      END IF

      IF (DFT_SPINDNS) THEN
         ! DGAO(1,2) = DSXMAT*GAO; DSXMAT is 1-index transformed or transition spin density matrix
         CALL DGEMV('N',NBAST,NBAST,1.0d0,
     &              DSXMAT,NBAST,GAO,1,0.0d0,DGAO(1,2),1)
         B0(2) = DDOT(NBAST,DGAO(1,2),1,GAO,1)
         BMAX = MAX( BMAX,ABS(B0(2)) )
         IF (DOGGA) THEN
C           B3(2) = GAO1'*DGAO(1,2)
            CALL DGEMV('T',NBAST,3,1.0d0,GAO1,NBAST,
     &         DGAO(1,2),1,0.0d0,B3(1,2),1)
C           DGAO(1,2) = DSXMAT'*GAO !!! HJAAJ: is this necessary ? We have D*XMAT symmetrized!
            CALL DGEMV('T',NBAST,NBAST,1.0d0,DSXMAT,NBAST,
     &         GAO,1,0.0d0,DGAO(1,2),1)
C           B3(1:3,2) = B3(1:3,2) + GAO1(1:NBAST,1:3)T*DGAO((1:NBAST, 2)
            CALL DGEMV('T',NBAST,3,1.0d0,GAO1,NBAST,
     &         DGAO(1,2),1,1.0d0,B3(1,2),1)
            BMAX = MAX(BMAX, ABS(B3(1,2)),ABS(B3(2,2)),ABS(B3(3,2)))
         END IF
      END IF
#if SRDFT_DEBUG > 5
      write(lupri,*)'Debug output of B3 matrix. BMAX =',BMAX
      call output(b3,3,2,1,3,1,2,3,2,1,lupri)
#endif
C
      IF (BMAX.GT.DFTHRL) THEN
C

C Exchange and correlation derivatives ------------------------------------

      NORDER = 2  ! zero-order, first-order and second-order derivatives
      CALL SRDFTEXCJT(RHO,RHG,CHIVAL,NORDER,ERFEXP,
     >                Ex,d1Ex,d2Ex,Ec,d1Ec,d2Ec,VLAMBDA)

C Total contribution -------------------------------------------------------

         FRR = WGHTX*d2Ex(1)        + WGHTC*d2Ec(1)
!        FRR = WGHTX*d2Exdrhocdrhoc + WGHTC*d2Ecdrhocdrhoc
      IF (DFT_SPINDNS) THEN ! LDA and GGA terms
         FRS = WGHTX*d2Ex(2)        + WGHTC*d2Ec(2)
!        FRS = WGHTX*d2Exdrhocdrhos + WGHTC*d2Ecdrhocdrhos
         FSS = WGHTX*d2Ex(3)        + WGHTC*d2Ec(3)
!        FSS = WGHTX*d2Exdrhosdrhos + WGHTC*d2Ecdrhosdrhos
      END IF
      IF (DOGGA) THEN
         grdnrm = sqrt(rhg(1,1)**2 + rhg(2,1)**2 + rhg(3,1)**2)
         IF (grdnrm > 1.0D-30) THEN
            ZNV(1) = 1.0d0/grdnrm
         ELSE
            ZNV(1) = 0.0D0
         END IF
         ! normalized grd[rhoc^(X,Y,Z)]
         RX(1) = ZNV(1)*RHG(1,1)
         RY(1) = ZNV(1)*RHG(2,1)
         RZ(1) = ZNV(1)*RHG(3,1)

         FZ0   = ZNV(1)*(WGHTX*d1Ex(3)   + WGHTC*d1Ec(3)  )
!        FZ0   = ZNV(1)*(WGHTX*d1Exdgrdc + WGHTC*d1Ecdgrdc)
         ! gradient
         FRZ   = WGHTX*d2Ex(4)        + WGHTC*d2Ec(4)
!        FRZ   = WGHTX*d2Exdrhocdgrdc + WGHTC*d2Ecdrhocdgrdc
         FZZ   = WGHTX*d2Ex(6)        + WGHTC*d2Ec(6)
!        FZZ   = WGHTX*d2Exdgrdcdgrdc + WGHTC*d2Ecdgrdcdgrdc

      IF (DFT_SPINDNS) THEN ! add GGA spin density terms
         ! spin
         grdnrm = sqrt(rhg(1,2)**2 + rhg(2,2)**2 + rhg(3,2)**2)
         IF (grdnrm > 1.0D-30) THEN
            ZNV(2) = 1.0d0/grdnrm
         ELSE
            ZNV(2) = 0.0D0
         END IF
         ! normalized grd[rhos^(X,Y,Z)]
         RX(2) = ZNV(2)*RHG(1,2)
         RY(2) = ZNV(2)*RHG(2,2)
         RZ(2) = ZNV(2)*RHG(3,2)

   TODO new d1E(4) etc
         FZ0_S = ZNV(2)*(WGHTX*d1Ex(4)   + WGHTC*d1Ec(4)  )
!        FZ0_S = ZNV(2)*(WGHTX*d1Exdgrds + WGHTC*d1Ecdgrds)
         FSZ   = WGHTX*d2Ex(5)        + WGHTC*d2Ec(5)
!        FSZ   = WGHTX*d2Exdrhosdgrdc + WGHTC*d2Ecdrhosdgrdc
         ! spin-gradient
         FRZ_S = WGHTX*d2Ex(7)        + WGHTC*d2Ec(7)
!        FRZ_S = WGHTX*d2Exdrhocdgrds + WGHTC*d2Ecdrhocdgrds
         FSZ_S = WGHTX*d2Ex(8)        + WGHTC*d2Ec(8)
!        FSZ_S = WGHTX*d2Exdrhosdgrds + WGHTC*d2Ecdrhosdgrds
         FZZ_S = WGHTX*d2Ex(9)        + WGHTC*d2Ec(9)
!        FZZ_S = WGHTX*d2Exdgrdcdgrds + WGHTC*d2Ecdgrdcdgrds
         FZZ_SS= WGHTX*d2Ex(10)       + WGHTC*d2Ec(10)
!        FZZ_SS= WGHTX*d2Exdgrdsdgrds + WGHTC*d2Ecdgrdsdgrds

      END IF ! DOGGA .and. DFT_SPINDNS
      END IF ! DOGGA

#if defined xxxSRDFT_DEBUG
! ipnt is not defined here any more ..
          if (ipnt .eq. 1) then
           !if (abs(FSS) .gt. 0.d0 .or. abs(FRS) .gt. 0.d0) then
              write(lupri,*) 'hjaaj: rho',rho(1:4)
              write(lupri,*) 'hjaaj: ZNV',ZNV(1:2)
              write(lupri,*) 'hjaaj: B0',B0(1:2)
              write(lupri,*) 'hjaaj: Ex, Ec',Ex, Ec
              write(lupri,*) 'hjaaj: d1Ex  ',d1Ex(:)
              write(lupri,*) 'hjaaj: d1Ec  ',d1Ec(:)
              write(lupri,*) 'hjaaj: d2Ex(:)',d2Ex(:)
              write(lupri,*) 'hjaaj: d2Ec(:)',d2Ec(:)

              write(lupri,*) 'hjaaj: FRR, FRZ, FZZ,',FRR, FRZ, FZZ
              write(lupri,*) 'hjaaj: FZ0, FZ0_S',FZ0, FZ0_S
              write(lupri,*) 'hjaaj: FSZ_S,FRZ_S,FZZ_S,FZZ_SS',
     &                               FSZ_S,FRZ_S,FZZ_S,FZZ_SS
           !end if
          end if
#endif


C Linear transformation -----------------------------------------------------

!        IF (DOHFSRDFT) THEN   !hjaaj July 2010: this was a
!        misunderstanding of the code in SRDFTLTR which had  IF
!        (.NOT.SRHYBR .OR. DHFSRDFT) ; for normal MC-srDFT SRHYBR would
!        have been false, but in this code this part was skipped until
!        now if DOMCSRDFT

            ! It is used that FSR = FRS, FSZ = FZS, FSZ_S = FZS_S
            if (dogga .and. dft_spindns) then
               BR(1) = B3(1,1)*RX(1) + B3(2,1)*RY(1) + B3(3,1)*RZ(1)
               BR(2) = B3(1,2)*RX(2) + B3(2,2)*RY(2) + B3(3,2)*RZ(2)
               FAC0R = FRR*B0(1) + FRZ*BR(1) + FRS*B0(2) + FRZ_S*BR(2)
               FAC0S = FRS*B0(1) + FSS*B0(2) + FSZ*BR(1) + FSZ_S*BR(2)
               FACR  = FRZ*B0(1) + FZZ*BR(1) + FZZ_S*BR(2) +  FSZ*B0(2)
               FACS  = FSZ_S*B0(2) + FRZ_S*B0(1) +
     &                 FZZ_S*BR(1) + FZZ_SS*BR(2)
            else if (dogga .and. .not. dft_spindns) then
               BR(1) = B3(1,1)*RX(1) + B3(2,1)*RY(1) + B3(3,1)*RZ(1)
               FAC0R = FRR*B0(1) + FRZ*BR(1)
               FACR = FRZ*B0(1) + FZZ*BR(1)
            else if (dft_spindns .and. .not. dogga) then
               FAC0R = FRR*B0(1) + FRS*B0(2)
               FAC0S = FRS*B0(1) + FSS*B0(2) ! as FSR = FRS
            else
               FAC0R = FRR*B0(1)
            end if
            IF (NSYM.EQ.1) THEN
               DO I = 1, NBAST
                  G0 = GAO(I)
                  IF (DOGGA) THEN
                     GX = GAO1(I,1)
                     GY = GAO1(I,2)
                     GZ = GAO1(I,3)
                  END IF
                  DO J = 1, I
                     EXCMAT(J,I,1) = EXCMAT(J,I,1)+FAC0R*G0*GAO(J)
                     if (dogga .and. dft_spindns) then
                        EXCMAT(J,I,2) = EXCMAT(J,I,2)+FAC0S*G0*GAO(J)

                        AX = GX*GAO(J) + G0*GAO1(J,1)
                        AY = GY*GAO(J) + G0*GAO1(J,2)
                        AZ = GZ*GAO(J) + G0*GAO1(J,3)
                        AR(1) = AX*RX(1) + AY*RY(1) + AZ*RZ(1)
                        AR(2) = AX*RX(2) + AY*RY(2) + AZ*RZ(2)
                        AB(1) = AX*B3(1,1) + AY*B3(2,1) + AZ*B3(3,1)
     &                          - AR(1)*BR(1)
                        AB(2) = AX*B3(1,2) + AY*B3(2,2) + AZ*B3(3,2)
     &                          - AR(2)*BR(2)
                        ! grad + spin-grad
                        EXCMAT(J,I,1) = EXCMAT(J,I,1)
     &                                + FACR*AR(1) + FZ0*AB(1)
                        EXCMAT(J,I,2) = EXCMAT(J,I,2)
     &                                + FACS*AR(2) + FZ0_S*AB(2)
                     else if (dft_spindns .and. .not. dogga) then
                        EXCMAT(J,I,2) = EXCMAT(J,I,2)+FAC0S*G0*GAO(J)
                     else if (dogga .and. .not. dft_spindns) then
                           AX = GX*GAO(J) + G0*GAO1(J,1)
                           AY = GY*GAO(J) + G0*GAO1(J,2)
                           AZ = GZ*GAO(J) + G0*GAO1(J,3)
                           AR(1) = AX*RX(1) + AY*RY(1) + AZ*RZ(1)
                           AB(1) = AX*B3(1,1) + AY*B3(2,1) + AZ*B3(3,1)
     &                        - AR(1)*BR(1)
                            EXCMAT(J,I,1) = EXCMAT(J,I,1)
     &                                    + FACR*AR(1)+FZ0*AB(1)
                     end if
                  END DO
               END DO
            ELSE
               DO ISYM = 1, NSYM
                  ISTR = IBAS(ISYM) + 1
                  IEND = IBAS(ISYM) + NBAS(ISYM)
                  JSYM = MULD2H(ISYM,KSYMOP)
                  IF (ISYM.GE.JSYM) THEN
                     JSTR = IBAS(JSYM) + 1
                     JEND = IBAS(JSYM) + NBAS(JSYM)
                     DO I = ISTR, IEND
                        G0 = GAO(I)
                        IF (DOGGA) THEN
                           GX = GAO1(I,1)
                           GY = GAO1(I,2)
                           GZ = GAO1(I,3)
                        END IF
                        DO J = JSTR, MIN(I,JEND)
                           EXCMAT(J,I,1) = EXCMAT(J,I,1)+FAC0R*G0*GAO(J)
                           if (dogga .and. dft_spindns) then
                              ! spin
                              EXCMAT(J,I,2) = EXCMAT(J,I,2) +
     &                                        FAC0S*G0*GAO(J)
                              ! grad + spin-grad
                              AX = GX*GAO(J) + G0*GAO1(J,1)
                              AY = GY*GAO(J) + G0*GAO1(J,2)
                              AZ = GZ*GAO(J) + G0*GAO1(J,3)
                              AR(1) = AX*RX(1)  + AY*RY(1) + AZ*RZ(1)
                              AR(2) = AX*RX(2)  + AY*RY(2) + AZ*RZ(2)
                              AB(1) = AX*B3(1,1) + AY*B3(2,1)
     &                              + AZ*B3(3,1) - AR(1)*BR(1)
                              AB(2) = AX*B3(1,2) + AY*B3(2,2)
     &                              + AZ*B3(3,2) - AR(2)*BR(2)
                              EXCMAT(J,I,1) = EXCMAT(J,I,1)
     &                                      + FACR*AR(1)+FZ0*AB(1)
                              EXCMAT(J,I,2) = EXCMAT(J,I,2)
     &                                      + FACS*AR(2) + FZ0_S*AB(2)
                           else if (dft_spindns .and. .not. dogga) then
                              EXCMAT(J,I,2) = EXCMAT(J,I,2)
     &                                      + FAC0S*G0*GAO(J)
                           else if (dogga) then
                              AX = GX*GAO(J) + G0*GAO1(J,1)
                              AY = GY*GAO(J) + G0*GAO1(J,2)
                              AZ = GZ*GAO(J) + G0*GAO1(J,3)
                              AR(1) = AX*RX(1) + AY*RY(1) + AZ*RZ(1)
                              AB(1) = AX*B3(1,1) + AY*B3(2,1)
     &                              + AZ*B3(3,1) - AR(1)*BR(1)
                              EXCMAT(J,I,1) = EXCMAT(J,I,1)
     &                                      + FACR*AR(1)+FZ0*AB(1)
                            end if
                        END DO
                     END DO
                  END IF
               END DO
            END IF
!        END IF   ! IF (DOHFSRDFT) THEN
      END IF   ! IF (BMAX.GT.DFTHRL) THEN
c
      RETURN
      END
! end of srdftjt.F
