      SUBROUTINE GET_FVVEC_QR(FVVEC1,FVVEC2,IDIM,NSIM,UDV,CMO,         &
     &                        ISYMT,ISYMV1,ISYMV2,ZYM1,ZYM2,WORK,LWORK)
!
! Purpose:
!     Computes electric field/potential vector generated by second
!     order perturbed density matrix.
!
! Input:
!   WORK   - Temporary memory array
!   LWORK  - Size of temporary memory array.
! Output:
!   FVVEC1 - Electric field/potential vector at NP/MM centers.
!   FVVEC2 - Electric field/potential vector at NP/MM centers.
!   IDIM   - Size of electric field/potential vector
!   NSIM   - Number of perturbed density matrices.
!
! Last updated: 22/03/2013 by Z. Rinkevicius.
!
      implicit none

#include "dummy.h"
#include "priunit.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"
!
      real(8) :: FVVEC1(*), FVVEC2(*), WORK(LWORK)
      real(8) :: UDV(NASHDI,NASHDI),CMO(*),ZYM1(*),ZYM2(*)
      integer :: lwork
!
      LOGICAL TOFILE,TRIMAT,EXP1VL
      integer :: INTREP(9*MXCENT), INTADR(9*MXCENT)
      CHARACTER*8 LABINT(9*MXCENT)
      real(8) :: RSAVORG(3)
      integer :: kfree, lfree
      integer :: i, j, ioff, joff, istart, idim, iblk
      integer :: nsim
      integer :: nocomp, kpatom
      integer :: isymt, isymv1, isymv2
      integer :: isimoff, kintao, kutr, ktlma, ktrmo, ktlmb
      real(8) :: f1val, f2val
      real(8) :: fact
!
      KFREE = 1
      LFREE = LWORK
!
      CALL DZERO(FVVEC1,IDIM*NSIM)
      CALL DZERO(FVVEC2,IDIM*NSIM)
!     Save origin coordinates
      RSAVORG(1) = DIPORG(1)
      RSAVORG(2) = DIPORG(2)
      RSAVORG(3) = DIPORG(3)
!     Compute electric field if needed
      IF (DONPPOL) THEN
!       Allocate integrals buffer
        CALL MEMGET('REAL',KINTAO,3*NNBASX,WORK,KFREE,LFREE)
!       Allocate temp. matrices used for integrals tranformations
        CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KTLMB,N2ORBX,WORK,KFREE,LFREE)
!       Set up integrals calculation parameters
        KPATOM = 0
        NOCOMP = 3
        TOFILE = .FALSE.
        TRIMAT = .TRUE.
        EXP1VL = .FALSE.
        RUNQM3 = .TRUE.
!       Loop over perturbed first order densities
        DO I=1,NSIM
           IOFF = (I-1)*IDIM
           ISIMOFF = (I-1)*N2ORBX+1
!          Loop over NP centers
           DO J=1,TNPATM
             JOFF = IOFF+(J-1)*3
             DIPORG(1) = NPCORD(1,J)
             DIPORG(2) = NPCORD(2,J)
             DIPORG(3) = NPCORD(3,J)
             CALL DZERO(WORK(KINTAO),3*NNBASX)
             CALL GET1IN(WORK(KINTAO),'NEFIELD',NOCOMP,WORK(KFREE),     &
     &                   LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,    &
     &                   TRIMAT,DUMMY,EXP1VL,DUMMY,0)
!            Compute X component of electric field
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
!            Transform integrals
             CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST, &
     &                 NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+1) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+1) = F2VAL
             ENDIF
!            Compute Y component of electric field
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
!            Transform integrals
             CALL UTHU(WORK(KINTAO+NNBASX),WORK(KTRMO),CMO,WORK(KFREE),&
     &                 NBAST,NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+2) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+2) = F2VAL
             ENDIF
!            Compute Z component of electric field
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
!            Transform integrals
             CALL UTHU(WORK(KINTAO+2*NNBASX),WORK(KTRMO),CMO,          &
     &                 WORK(KFREE),NBAST,NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+3) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+3) = F2VAL
             ENDIF
           END DO
        END DO
        RUNQM3 = .FALSE.
        CALL MEMREL('GET_FVVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
      IF (DONPCAP) THEN
        ISTART = 0
        IF (DONPPOL) ISTART = 3*TNPATM
!       Fix me MM region shift
!       Allocate integrals buffer
        CALL MEMGET('REAL',KINTAO,NNBASX,WORK,KFREE,LFREE)
!       Allocate temp. matrices used for integrals tranformations
        CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KTLMB,N2ORBX,WORK,KFREE,LFREE)
!       Set up integrals calculation parameters
        KPATOM = 0
        NOCOMP = 1
        TOFILE = .FALSE.
        TRIMAT = .TRUE.
        EXP1VL = .FALSE.
        RUNQM3 = .TRUE.
!       Loop over perturbed first order densities
        DO I=1,NSIM
           IOFF = (I-1)*IDIM
           ISIMOFF = (I-1)*N2ORBX+1
!          Loop over NP centers
           DO J=1,TNPATM
             JOFF = IOFF+ISTART+J
             DIPORG(1) = NPCORD(1,J)
             DIPORG(2) = NPCORD(2,J)
             DIPORG(3) = NPCORD(3,J)
             CALL DZERO(WORK(KINTAO),NNBASX)
             CALL GET1IN(WORK(KINTAO),'NPETES ',NOCOMP,WORK(KFREE),     &
     &                   LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,    &
     &                   TRIMAT,DUMMY,EXP1VL,DUMMY,0)
!            Zero temporary arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
!            Transform integrals
             CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST, &
     &                 NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF) = F2VAL
             ENDIF
           END DO
!          Set Lagrangian for charge equilibration
           DO IBLK=1,TNPBLK
              FVVEC1(IOFF+IDIM) = FVVEC1(IOFF+IDIM)+NPCHRG(IBLK)
              FVVEC2(IOFF+IDIM) = FVVEC2(IOFF+IDIM)+NPCHRG(IBLK)
           END DO
        END DO
        RUNQM3 = .FALSE.
        CALL MEMREL('GET_FVVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
!     Restore origin coordinates
      DIPORG(1) = RSAVORG(1)
      DIPORG(2) = RSAVORG(2)
      DIPORG(3) = RSAVORG(3)
!     Print final FV vector
      DO I=1,NSIM
         if (iprtlvl > 14 .and. .not. mqiter) then
            IOFF = (I-1)*IDIM+1
            write(lupri, '(/,2x,a,i0)') &
                '*** Computed FV vector start v1 2nd-order density ', i
            do j = 1, idim
               write(lupri, '(i8, f18.8)') j, fvvec1(IOFF-1+j)
            end do
            write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
            write(lupri, '(/,2x,a,i0)') &
                '*** Computed FV vector start v2 2nd-order density ', i
            do j = 1, idim
               write(lupri, '(i8, f18.8)') j, fvvec2(IOFF-1+j)
            end do
            write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
         end if
      END DO
!
      end subroutine

      SUBROUTINE GET_XYVEC_QR(FMQVEC1,FMQVEC2,CMO,IDIM,NSIM,FVEC,      &
     &                        ISYMT,ISYMV2,ZYM2,WORK,LWORK)
!
! Purpose:
!     Computes contribution to XY vector from induced dipoles moments
!     and charges.
!
! Input:
!   FMQVEC - Induced dipole moments and charges
!   CMO    - Molecular orbitals
!   WORK   - Temporary memory array
!   LWORK  - Size of temporary memory array
! Output:
!   FXYVEC - Contribution to XY vector from induced dipole moments and
!            charges
!   IDIM   - Size of electric field/potential vector
!   NSIM  - Number of perturbed density matrices
!
! Last updated: 22/03/2013 by Z. Rinkevicius.
!

      implicit none

#include "dummy.h"
#include "priunit.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"
!
      real(8) :: FMQVEC1(NSIM*IDIM), FMQVEC2(NSIM*IDIM)
      real(8) :: CMO(NORBT*NBAST), ZYM2(*)
      real(8) :: FVEC(NSIM*N2ORBX), WORK(LWORK)
      integer :: lwork
!
      LOGICAL TOFILE,TRIMAT,EXP1VL
      integer :: INTREP(9*MXCENT), INTADR(9*MXCENT)
      CHARACTER*8 LABINT(9*MXCENT)
      real(8) :: RSAVORG(3)
      integer :: kfree, lfree
      integer :: i, j, ioff, joff, istart, idim
      integer :: nsim
      integer :: nocomp, kpatom
      integer :: isymt, isymv2
      integer :: isimoff, kintao, kutr, ktlma, ktrmo
      real(8) :: f1val, f2val
      real(8) :: fact
!
      KFREE = 1
      LFREE = LWORK
!     Save origin coordinates
      RSAVORG(1) = DIPORG(1)
      RSAVORG(2) = DIPORG(2)
      RSAVORG(3) = DIPORG(3)
!     Induced dipole moment in NP region interaction with QM region
      IF (DONPPOL.AND.NOVDAMP) THEN
!        Electronic interaction part
         CALL MEMGET('REAL',KINTAO,3*NNBASX,WORK,KFREE,LFREE)
!        Allocate temp. matrices used for integrals tranformations
         CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
         CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)
         CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
!        Set integrals evaluation flags
         KPATOM = 0
         NOCOMP = 3
         TOFILE = .FALSE.
         TRIMAT = .TRUE.
         EXP1VL = .FALSE.
         RUNQM3 = .TRUE.
!        Compute contributions
         DO I=1,NSIM
            IOFF = (I-1)*IDIM
            ISIMOFF = (I-1)*N2ORBX+1
            DO J=1,TNPATM
              JOFF = IOFF+(J-1)*3
              DIPORG(1) = NPCORD(1,J)
              DIPORG(2) = NPCORD(2,J)
              DIPORG(3) = NPCORD(3,J)
              CALL DZERO(WORK(KINTAO),3*NNBASX)
              CALL GET1IN(WORK(KINTAO),'NEFIELD',NOCOMP,WORK(KFREE),    &
     &                    LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,   &
     &                    TRIMAT,DUMMY,EXP1VL,DUMMY,0)

!             X-component
              CALL DZERO(WORK(KTRMO),NNORBX)
              CALL DZERO(WORK(KUTR),N2ORBX)
!             Transform integrals
              CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST,&
     &                  NORBT)
              CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!             Determine MM region contribution
              F1VAL = -FMQVEC1(JOFF+1)
              F2VAL = -0.50D0*FMQVEC2(JOFF+1)
              CALL DZERO(WORK(KTLMA),N2ORBX)
              CALL OITH1(ISYMV2,ZYM2,WORK(KUTR),WORK(KTLMA),ISYMT)
              CALL DAXPY(N2ORBX,F1VAL,WORK(KTLMA),1,FVEC,1)
              CALL DAXPY(N2ORBX,F2VAL,WORK(KTLMA),1,FVEC,1)

!             Y-component
              CALL DZERO(WORK(KTRMO),NNORBX)
              CALL DZERO(WORK(KUTR),N2ORBX)
!             Transform integrals
              CALL UTHU(WORK(KINTAO+NNBASX),WORK(KTRMO),CMO,           &
     &                  WORK(KFREE),NBAST,NORBT)
              CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!             Determine MM region contribution
              F1VAL = -FMQVEC1(JOFF+2)
              F2VAL = -0.50D0*FMQVEC2(JOFF+2)
              CALL DZERO(WORK(KTLMA),N2ORBX)
              CALL OITH1(ISYMV2,ZYM2,WORK(KUTR),WORK(KTLMA),ISYMT)
              CALL DAXPY(N2ORBX,F1VAL,WORK(KTLMA),1,FVEC,1)
              CALL DAXPY(N2ORBX,F2VAL,WORK(KTLMA),1,FVEC,1)

!             Z-component
              CALL DZERO(WORK(KTRMO),NNORBX)
              CALL DZERO(WORK(KUTR),N2ORBX)
!             Transform integrals
              CALL UTHU(WORK(KINTAO+2*NNBASX),WORK(KTRMO),CMO,         &
     &                  WORK(KFREE),NBAST,NORBT)
              CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!             Determine MM region contribution
              F1VAL = -FMQVEC1(JOFF+3)
              F2VAL = -0.50D0*FMQVEC2(JOFF+3)
              CALL DZERO(WORK(KTLMA),N2ORBX)
              CALL OITH1(ISYMV2,ZYM2,WORK(KUTR),WORK(KTLMA),ISYMT)
              CALL DAXPY(N2ORBX,F1VAL,WORK(KTLMA),1,FVEC,1)
              CALL DAXPY(N2ORBX,F2VAL,WORK(KTLMA),1,FVEC,1)
            END DO
         END DO
         RUNQM3 = .FALSE.
         CALL MEMREL('GET_XYVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
!     Induced dipole moment in NP region interaction with QM region
      IF (DONPCAP.AND.NOVDAMP) THEN
         ISTART = 0
         IF (DONPPOL) ISTART = 3*TNPATM
!        Fix me MM region shift
!        Electronic interaction part
         CALL MEMGET('REAL',KINTAO,NNBASX,WORK,KFREE,LFREE)
!        Allocate temp. matrices used for integrals tranformations
         CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
         CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)
         CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
!        Set integrals evaluation flags
         KPATOM = 0
         NOCOMP = 1
         TOFILE = .FALSE.
         TRIMAT = .TRUE.
         EXP1VL = .FALSE.
         RUNQM3 = .TRUE.
!        Compute contributions
         DO I=1,NSIM
            IOFF = (I-1)*IDIM
            ISIMOFF = (I-1)*N2ORBX+1
            DO J=1,TNPATM
               JOFF = IOFF+ISTART+J
               DIPORG(1) = NPCORD(1,J)
               DIPORG(2) = NPCORD(2,J)
               DIPORG(3) = NPCORD(3,J)
               CALL DZERO(WORK(KINTAO),NNBASX)
               CALL GET1IN(WORK(KINTAO),'NPETES ',NOCOMP,WORK(KFREE),   &
     &                     LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,  &
     &                     TRIMAT,DUMMY,EXP1VL,DUMMY,0)

!             Zero integral buffers
              CALL DZERO(WORK(KTRMO),NNORBX)
              CALL DZERO(WORK(KUTR),N2ORBX)

!             Transform integrals
              CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST,&
     &                  NORBT)
              CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!             Determine MM region contribution
              F1VAL = FMQVEC1(JOFF)
              F2VAL = 0.50D0*FMQVEC2(JOFF)
              CALL DZERO(WORK(KTLMA),N2ORBX)
              CALL OITH1(ISYMV2,ZYM2,WORK(KUTR),WORK(KTLMA),ISYMT)
              CALL DAXPY(N2ORBX,F1VAL,WORK(KTLMA),1,FVEC,1)
              CALL DAXPY(N2ORBX,F2VAL,WORK(KTLMA),1,FVEC,1)
           END DO
         END DO
         RUNQM3 = .FALSE.
         CALL MEMREL('GET_XYVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
!     Restore origin coordinates
      DIPORG(1) = RSAVORG(1)
      DIPORG(2) = RSAVORG(2)
      DIPORG(3) = RSAVORG(3)
!
      end subroutine
