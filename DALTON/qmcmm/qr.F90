module qmcmm_qr

   implicit none

   public get_fvvec_qr
   public get_xyvec

   private

contains

      SUBROUTINE GET_FVVEC_QR(FVVEC1, &
                              FVVEC2, &
                              IDIM,   &
                              NSIM,   &
                              UDV,    &
                              CMO,    &
                              ISYMT,ISYMV1,ISYMV2,ZYM1,ZYM2, &
                              WORK,   &
                              LWORK)
!
! Purpose:
!     Computes electric field/potential vector generated by second
!     order perturbed density matrix.
!
! Input:
!   WORK   - Temporary memory array
!   LWORK  - Size of temporary memory array.
! Output:
!   FVVEC1 - Electric field/potential vector at NP/MM centers.
!   FVVEC2 - Electric field/potential vector at NP/MM centers.
!   IDIM   - Size of electric field/potential vector
!   NSIM   - Number of perturbed density matrices
!
! Last updated: 22/03/2013 by Z. Rinkevicius.
!

#include "dummy.h"
#include "priunit.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"
!
      real(8) :: FVVEC1(*), FVVEC2(*), WORK(LWORK)
      real(8) :: UDV(NASHDI,NASHDI),CMO(*),ZYM1(*),ZYM2(*)
      integer :: lwork
!
      LOGICAL TOFILE,TRIMAT,EXP1VL
      integer :: INTREP(9*MXCENT), INTADR(9*MXCENT)
      CHARACTER*8 LABINT(9*MXCENT)
      real(8) :: dipole_origin_save(3)
      integer :: kfree, lfree
      integer :: i, j, ioff, joff, istart, idim, iblk
      integer :: nsim
      integer :: nocomp, kpatom
      integer :: isymt, isymv1, isymv2
      integer :: isimoff, kintao, kutr, ktlma, ktrmo, ktlmb
      integer :: KUTRX, KURXAC
      real(8) :: f1val, f2val
      real(8) :: fact
      real(8) :: tac
      real(8), external :: slvtlm
      real(8), external :: slvqlm
!
      KFREE = 1
      LFREE = LWORK
!
      CALL DZERO(FVVEC1,IDIM*NSIM)
      CALL DZERO(FVVEC2,IDIM*NSIM)

!     Save origin coordinates
      dipole_origin_save(1) = DIPORG(1)
      dipole_origin_save(2) = DIPORG(2)
      dipole_origin_save(3) = DIPORG(3)
!     Compute electric field if needed
      IF (DONPPOL) THEN
!       Allocate integrals buffer
        CALL MEMGET('REAL',KINTAO,3*NNBASX,WORK,KFREE,LFREE)
!       Allocate temp. matrices used for integrals tranformations
        CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)

        CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KTLMB,N2ORBX,WORK,KFREE,LFREE)
!       Set up integrals calculation parameters
        KPATOM = 0
        NOCOMP = 3
        TOFILE = .FALSE.
        TRIMAT = .TRUE.
        EXP1VL = .FALSE.
        RUNQM3 = .TRUE.
!       Loop over perturbed first order densities
        DO I=1,NSIM
           IOFF = (I-1)*IDIM
           ISIMOFF = (I-1)*N2ORBX+1
!          Loop over NP centers
           DO J=1,TNPATM
             JOFF = IOFF+(J-1)*3
             DIPORG(1) = NPCORD(1,J)
             DIPORG(2) = NPCORD(2,J)
             DIPORG(3) = NPCORD(3,J)
             CALL DZERO(WORK(KINTAO),3*NNBASX)
             CALL GET1IN(WORK(KINTAO),'NEFIELD',NOCOMP,WORK(KFREE),     &
     &                   LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,    &
     &                   TRIMAT,DUMMY,EXP1VL,DUMMY,0)
!            Compute X component of electric field

             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)

!            Transform integrals
             CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST, &
     &                 NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+1) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+1) = F2VAL
             ENDIF
!            Compute Y component of electric field
!            zero temp. arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)

!            Transform integrals
             CALL UTHU(WORK(KINTAO+NNBASX),WORK(KTRMO),CMO,WORK(KFREE),&
     &                 NBAST,NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))

!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+2) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+2) = F2VAL
             ENDIF
!            Compute Z component of electric field

!            zero temp. arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)

!            Transform integrals
             CALL UTHU(WORK(KINTAO+2*NNBASX),WORK(KTRMO),CMO,          &
     &                 WORK(KFREE),NBAST,NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+3) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+3) = F2VAL
             ENDIF
           END DO
        END DO
        RUNQM3 = .FALSE.
        CALL MEMREL('GET_FVVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
      IF (DONPCAP) THEN
        ISTART = 0
        IF (DONPPOL) ISTART = 3*TNPATM
!       Fix me MM region shift
!       Allocate integrals buffer
        CALL MEMGET('REAL',KINTAO,NNBASX,WORK,KFREE,LFREE)
!       Allocate temp. matrices used for integrals tranformations
        CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KTLMB,N2ORBX,WORK,KFREE,LFREE)
!       Set up integrals calculation parameters
        KPATOM = 0
        NOCOMP = 1
        TOFILE = .FALSE.
        TRIMAT = .TRUE.
        EXP1VL = .FALSE.
        RUNQM3 = .TRUE.
!       Loop over perturbed first order densities
        DO I=1,NSIM
           IOFF = (I-1)*IDIM
           ISIMOFF = (I-1)*N2ORBX+1
!          Loop over NP centers
           DO J=1,TNPATM
             JOFF = IOFF+ISTART+J
             DIPORG(1) = NPCORD(1,J)
             DIPORG(2) = NPCORD(2,J)
             DIPORG(3) = NPCORD(3,J)
             CALL DZERO(WORK(KINTAO),NNBASX)
             CALL GET1IN(WORK(KINTAO),'NPETES ',NOCOMP,WORK(KFREE),     &
     &                   LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,    &
     &                   TRIMAT,DUMMY,EXP1VL,DUMMY,0)
!            Zero temporary arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)

!            Transform integrals
             CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST, &
     &                 NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF) = F2VAL
             ENDIF
           END DO

!          Set Lagrangian for charge equilibration
           DO IBLK=1,TNPBLK
              FVVEC1(IOFF+IDIM) = FVVEC1(IOFF+IDIM)+NPCHRG(IBLK)
              FVVEC2(IOFF+IDIM) = FVVEC2(IOFF+IDIM)+NPCHRG(IBLK)
           END DO
        END DO
        RUNQM3 = .FALSE.
        CALL MEMREL('GET_FVVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
!     Restore origin coordinates
      DIPORG(1) = dipole_origin_save(1)
      DIPORG(2) = dipole_origin_save(2)
      DIPORG(3) = dipole_origin_save(3)
!     Print final FV vector
      DO I=1,NSIM
         if (iprtlvl > 14 .and. .not. mqiter) then
            IOFF = (I-1)*IDIM+1
            write(lupri, '(/,2x,a,i0)') &
                '*** Computed FV vector start v1 2nd-order density ', i
            do j = 1, idim
               write(lupri, '(i8, f18.8)') j, fvvec1(IOFF-1+j)
            end do
            write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
            write(lupri, '(/,2x,a,i0)') &
                '*** Computed FV vector start v2 2nd-order density ', i
            do j = 1, idim
               write(lupri, '(i8, f18.8)') j, fvvec2(IOFF-1+j)
            end do
            write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
         end if
      END DO
!
      end subroutine

   subroutine get_xyvec(cmo,     &
                        idim,    &
                        nsim,    &
                        fvec,    &
                        work,    &
                        lwork,   &
                        fmqvec1, &
                        fmqvec2, &
                        isymt,   &
                        isymv2,  &
                        zym2)
!
! Purpose:
!     Computes contribution to XY vector from induced dipoles moments
!     and charges.
!
! Input:
!   FMQVEC - Induced dipole moments and charges
!   CMO    - Molecular orbitals
!   WORK   - Temporary memory array
!   LWORK  - Size of temporary memory array
! Output:
!   FVEC - Contribution to XY vector from induced dipole moments and
!            charges
!   IDIM   - Size of electric field/potential vector
!   NSIM  - Number of perturbed density matrices
!
! Last updated: 22/03/2013 by Z. Rinkevicius.
!

      real(8), intent(in)           :: cmo(*)
      integer, intent(in)           :: idim
      integer, intent(in)           :: nsim
      integer, intent(in)           :: lwork
      real(8), intent(in)           :: fvec(*)
      real(8), intent(out)          :: work(*)
      real(8), intent(in)           :: fmqvec1(*)
      real(8), intent(in), optional :: fmqvec2(*)
      integer, intent(in), optional :: isymt
      integer, intent(in), optional :: isymv2
      real(8), intent(in), optional :: zym2(*)

#include "dummy.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"

      real(8), allocatable :: utr(:)
      real(8), allocatable :: trmo(:)
      real(8), allocatable :: intao(:)
      real(8), allocatable :: tlma(:)

      logical tofile,trimat,exp1vl
      integer :: intrep(9*mxcent), intadr(9*mxcent)
      character*8 labint(9*mxcent)
      real(8) :: dipole_origin_save(3)
      integer :: i, j, ioff, joff, istart
      integer :: nocomp, kpatom
      integer :: isimoff
      real(8) :: fact

      ! save origin coordinates
      dipole_origin_save = diporg

      allocate(utr(n2orbx))
      allocate(trmo(nnorbx))
      allocate(intao(3*nnbasx))
      if (present(fmqvec2)) then
          allocate(tlma(n2orbx))
      end if

!     Induced dipole moment in NP region interaction with QM region
      IF (DONPPOL.AND.NOVDAMP) THEN
!        Set integrals evaluation flags
         KPATOM = 0
         NOCOMP = 3
         TOFILE = .FALSE.
         TRIMAT = .TRUE.
         EXP1VL = .FALSE.
         RUNQM3 = .TRUE.
!        Compute contributions
         DO I=1,NSIM
            IOFF = (I-1)*IDIM
            ISIMOFF = (I-1)*N2ORBX+1
            DO J=1,TNPATM
              JOFF = IOFF+(J-1)*3
              DIPORG = NPCORD(:, J)
              intao = 0.0d0
              CALL GET1IN(INTAO,'NEFIELD',NOCOMP,WORK,           &
     &                    lwork,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,   &
     &                    TRIMAT,DUMMY,EXP1VL,DUMMY,0)

!             X-component
              utr = 0.0d0
              trmo = 0.0d0

!             Transform integrals
              CALL UTHU(INTAO,TRMO,CMO,WORK,NBAST,NORBT)
              CALL DSPTSI(NORBT,TRMO,UTR)

!             Determine MM region contribution
              if (present(FMQVEC2)) then
                 tlma = 0.0d0
                 CALL OITH1(ISYMV2,ZYM2,UTR,TLMA,ISYMT)
                 fact = -FMQVEC1(JOFF+1)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
                 fact = -0.50D0*FMQVEC2(JOFF+1)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
              else
                 FACT = -fmqvec1(JOFF+1)
                 CALL DAXPY(N2ORBX,FACT,UTR,1,FVEC(ISIMOFF),1)
              end if

!             Y-component
              utr = 0.0d0
              trmo = 0.0d0

!             Transform integrals
              CALL UTHU(INTAO(NNBASX + 1),TRMO,CMO,           &
     &                  WORK,NBAST,NORBT)
              CALL DSPTSI(NORBT,TRMO,UTR)

!             Determine MM region contribution
              if (present(FMQVEC2)) then
                 tlma = 0.0d0
                 CALL OITH1(ISYMV2,ZYM2,UTR,TLMA,ISYMT)
                 fact = -FMQVEC1(JOFF+2)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
                 fact = -0.50D0*FMQVEC2(JOFF+2)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
              else
                 FACT = -fmqvec1(JOFF+2)
                 CALL DAXPY(N2ORBX,FACT,UTR,1,FVEC(ISIMOFF),1)
              end if

!             Z-component
              utr = 0.0d0
              trmo = 0.0d0

!             Transform integrals
              CALL UTHU(INTAO(2*NNBASX + 1),TRMO,CMO,         &
     &                  WORK,NBAST,NORBT)
              CALL DSPTSI(NORBT,TRMO,UTR)

!             Determine MM region contribution
              if (present(FMQVEC2)) then
                 tlma = 0.0d0
                 CALL OITH1(ISYMV2,ZYM2,UTR,TLMA,ISYMT)
                 fact = -FMQVEC1(JOFF+3)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
                 fact = -0.50D0*FMQVEC2(JOFF+3)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
              else
                 FACT = -fmqvec1(JOFF+3)
                 CALL DAXPY(N2ORBX,FACT,UTR,1,FVEC(ISIMOFF),1)
              end if
            END DO
         END DO
         RUNQM3 = .FALSE.
      END IF
!     Induced dipole moment in NP region interaction with QM region
      IF (DONPCAP.AND.NOVDAMP) THEN
         ISTART = 0
         IF (DONPPOL) ISTART = 3*TNPATM
!        Set integrals evaluation flags
         KPATOM = 0
         NOCOMP = 1
         TOFILE = .FALSE.
         TRIMAT = .TRUE.
         EXP1VL = .FALSE.
         RUNQM3 = .TRUE.
!        Compute contributions
         DO I=1,NSIM
            IOFF = (I-1)*IDIM
            ISIMOFF = (I-1)*N2ORBX+1
            DO J=1,TNPATM
               JOFF = IOFF+ISTART+J
               DIPORG(1) = NPCORD(1,J)
               DIPORG(2) = NPCORD(2,J)
               DIPORG(3) = NPCORD(3,J)
               intao = 0.0d0
               CALL GET1IN(INTAO,'NPETES ',NOCOMP,WORK,   &
     &                     lwork,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,  &
     &                     TRIMAT,DUMMY,EXP1VL,DUMMY,0)

!             Zero integral buffers
              utr = 0.0d0
              trmo = 0.0d0

!             Transform integrals
              CALL UTHU(INTAO,TRMO,CMO,WORK,NBAST,&
     &                  NORBT)
              CALL DSPTSI(NORBT,TRMO,UTR)

!             Determine MM region contribution
              if (present(FMQVEC2)) then
                 tlma = 0.0d0
                 CALL OITH1(ISYMV2,ZYM2,UTR,TLMA,ISYMT)
                 fact = FMQVEC1(JOFF)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
                 fact = 0.50D0*FMQVEC2(JOFF)
                 CALL DAXPY(N2ORBX,fact,TLMA,1,FVEC,1)
              else
                 FACT = fmqvec1(JOFF)
                 CALL DAXPY(N2ORBX,FACT,UTR,1,fvec(ISIMOFF),1)
              end if
           END DO
         END DO
         RUNQM3 = .FALSE.
      END IF

      if (allocated(utr)) deallocate(utr)
      if (allocated(trmo)) deallocate(trmo)
      if (allocated(intao)) deallocate(intao)
      if (allocated(tlma)) deallocate(tlma)

      ! restore origin coordinates
      diporg = dipole_origin_save

   end subroutine

end module
