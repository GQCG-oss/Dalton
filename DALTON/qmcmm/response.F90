module qmcmm_response

   implicit none

   public get_fvvec
   public get_xyvec

   private

contains

      subroutine get_fvvec(idim,   &
                           nsim,   &
                           udv,    &
                           cmo,    &
                           work,   &
                           lwork,  &
                           fvvec1, &
                           fvvec2, &
                           UDVTR,  &
                           BOVECS, &
                           isymt,  &
                           isymv1, &
                           isymv2, &
                           zym1,   &
                           zym2)
!
! Purpose:
!     Computes electric field/potential vector generated by first or second
!     order perturbed density matrix.
!
! Input:
!   WORK   - Temporary memory array
!   LWORK  - Size of temporary memory array.
! Output:
!   FVVEC1 - Electric field/potential vector at NP/MM centers.
!   FVVEC2 - Electric field/potential vector at NP/MM centers.
!   IDIM   - Size of electric field/potential vector
!   NSIM   - Number of perturbed density matrices
!
! Last updated: 22/03/2013 by Z. Rinkevicius.
!

#include "dummy.h"
#include "priunit.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"

      real(8) :: UDV(NASHDI, NASHDI)
      real(8) :: CMO(*)
      real(8) :: WORK(*)
      integer :: lwork
      real(8) :: fvvec1(*)
      real(8), optional :: FVVEC2(*)
      real(8), optional :: UDVTR(N2ASHX)
      real(8), optional :: BOVECS(*)
      integer, optional :: isymt
      integer, optional :: isymv1
      integer, optional :: isymv2
      real(8), optional :: ZYM1(*)
      real(8), optional :: ZYM2(*)
!
      LOGICAL TOFILE,TRIMAT,EXP1VL
      integer :: INTREP(9*MXCENT), INTADR(9*MXCENT)
      CHARACTER*8 LABINT(9*MXCENT)
      real(8) :: dipole_origin_save(3)
      integer :: kfree, lfree
      integer :: i, j, ioff, joff, istart, idim, iblk
      integer :: nsim
      integer :: nocomp, kpatom
      integer :: isimoff, kintao, kutr, ktlma, ktrmo, ktlmb
      integer :: KUTRX, KURXAC
      real(8) :: f1val, f2val
      real(8) :: fact
      real(8) :: tac
      real(8), external :: slvtlm
      real(8), external :: slvqlm
!
      KFREE = 1
      LFREE = LWORK
!
      CALL DZERO(FVVEC1,IDIM*NSIM)
      if (present(fvvec2)) then
         CALL DZERO(FVVEC2,IDIM*NSIM)
      end if

!     Save origin coordinates
      dipole_origin_save = DIPORG
!     Compute electric field if needed
      IF (DONPPOL) THEN
!       Allocate integrals buffer
        CALL MEMGET('REAL',KINTAO,3*NNBASX,WORK,KFREE,LFREE)
!       Allocate temp. matrices used for integrals tranformations
        CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)

        if (present(fvvec2)) then
           CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
           CALL MEMGET('REAL',KTLMB,N2ORBX,WORK,KFREE,LFREE)
        else
           CALL MEMGET('REAL',KUTRX,N2ORBX,WORK,KFREE,LFREE)
           CALL MEMGET('REAL',KURXAC,N2ASHX,WORK,KFREE,LFREE)
        end if

!       Set up integrals calculation parameters
        KPATOM = 0
        NOCOMP = 3
        TOFILE = .FALSE.
        TRIMAT = .TRUE.
        EXP1VL = .FALSE.
        RUNQM3 = .TRUE.
!       Loop over perturbed first order densities
        DO I=1,NSIM
           IOFF = (I-1)*IDIM
           ISIMOFF = (I-1)*N2ORBX+1
!          Loop over NP centers
           DO J=1,TNPATM
             JOFF = IOFF+(J-1)*3
             DIPORG(1) = NPCORD(1,J)
             DIPORG(2) = NPCORD(2,J)
             DIPORG(3) = NPCORD(3,J)
             CALL DZERO(WORK(KINTAO),3*NNBASX)
             CALL GET1IN(WORK(KINTAO),'NEFIELD',NOCOMP,WORK(KFREE),     &
     &                   LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,    &
     &                   TRIMAT,DUMMY,EXP1VL,DUMMY,0)
!            Compute X component of electric field

!            zero temp. arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
             if (.not. present(fvvec2)) then
                CALL DZERO(WORK(KUTRX),N2ORBX)
                CALL DZERO(WORK(KURXAC),N2ASHX)
             end if

!            Transform integrals
             CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST, NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))

             if (present(fvvec2)) then
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+1) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+1) = F2VAL
             ENDIF
             else
             CALL ONEXH1(BOVECS(ISIMOFF),WORK(KUTR),WORK(KUTRX))
!
             IF (NASHT.GT.0) CALL GETACQ(WORK(KUTRX),WORK(KURXAC))
             IF (TRPLET) THEN
                 fvvec1(JOFF+1) = SLVTLM(UDVTR,WORK(KURXAC),WORK(KUTRX), &
     &                                  TAC)
             ELSE
                 fvvec1(JOFF+1) = SLVQLM(UDV,WORK(KURXAC),WORK(KUTRX),   &
     &                                  TAC)
             ENDIF
             end if

!            Compute Y component of electric field
!            zero temp. arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
             if (.not. present(fvvec2)) then
                CALL DZERO(WORK(KUTRX),N2ORBX)
                CALL DZERO(WORK(KURXAC),N2ASHX)
             end if

!            Transform integrals
             CALL UTHU(WORK(KINTAO+NNBASX),WORK(KTRMO),CMO,WORK(KFREE),&
     &                 NBAST,NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))

             if (present(fvvec2)) then
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+2) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+2) = F2VAL
             ENDIF
             else
             CALL ONEXH1(BOVECS(ISIMOFF),WORK(KUTR),WORK(KUTRX))
!
             IF (NASHT.GT.0) CALL GETACQ(WORK(KUTRX),WORK(KURXAC))
             IF (TRPLET) THEN
                 fvvec1(JOFF+2) = SLVTLM(UDVTR,WORK(KURXAC),WORK(KUTRX), &
     &                                  TAC)
             ELSE
                 fvvec1(JOFF+2) = SLVQLM(UDV,WORK(KURXAC),WORK(KUTRX),   &
     &                                  TAC)
             ENDIF
             end if

!            Compute Z component of electric field

!            zero temp. arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
             if (.not. present(fvvec2)) then
                CALL DZERO(WORK(KUTRX),N2ORBX)
                CALL DZERO(WORK(KURXAC),N2ASHX)
             end if

!            Transform integrals
             CALL UTHU(WORK(KINTAO+2*NNBASX),WORK(KTRMO),CMO,          &
     &                 WORK(KFREE),NBAST,NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))

             if (present(fvvec2)) then
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF+3) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF+3) = F2VAL
             ENDIF
             else
             CALL ONEXH1(BOVECS(ISIMOFF),WORK(KUTR),WORK(KUTRX))
!
             IF (NASHT.GT.0) CALL GETACQ(WORK(KUTRX),WORK(KURXAC))
             IF (TRPLET) THEN
                 fvvec1(JOFF+3) = SLVTLM(UDVTR,WORK(KURXAC),WORK(KUTRX), &
     &                                  TAC)
             ELSE
                 fvvec1(JOFF+3) = SLVQLM(UDV,WORK(KURXAC),WORK(KUTRX),   &
     &                                  TAC)
             ENDIF
             end if

           END DO
        END DO
        RUNQM3 = .FALSE.
        CALL MEMREL('GET_FVVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
      IF (DONPCAP) THEN
        ISTART = 0
        IF (DONPPOL) ISTART = 3*TNPATM
!       Fix me MM region shift
!       Allocate integrals buffer
        CALL MEMGET('REAL',KINTAO,NNBASX,WORK,KFREE,LFREE)
!       Allocate temp. matrices used for integrals tranformations
        CALL MEMGET('REAL',KTRMO,NNORBX,WORK,KFREE,LFREE)
        CALL MEMGET('REAL',KUTR,N2ORBX,WORK,KFREE,LFREE)
        if (present(fvvec2)) then
           CALL MEMGET('REAL',KTLMA,N2ORBX,WORK,KFREE,LFREE)
           CALL MEMGET('REAL',KTLMB,N2ORBX,WORK,KFREE,LFREE)
        else
           CALL MEMGET('REAL',KUTRX,N2ORBX,WORK,KFREE,LFREE)
           CALL MEMGET('REAL',KURXAC,N2ASHX,WORK,KFREE,LFREE)
        end if
!       Set up integrals calculation parameters
        KPATOM = 0
        NOCOMP = 1
        TOFILE = .FALSE.
        TRIMAT = .TRUE.
        EXP1VL = .FALSE.
        RUNQM3 = .TRUE.
!       Loop over perturbed first order densities
        DO I=1,NSIM
           IOFF = (I-1)*IDIM
           ISIMOFF = (I-1)*N2ORBX+1
!          Loop over NP centers
           DO J=1,TNPATM
             JOFF = IOFF+ISTART+J
             DIPORG(1) = NPCORD(1,J)
             DIPORG(2) = NPCORD(2,J)
             DIPORG(3) = NPCORD(3,J)
             CALL DZERO(WORK(KINTAO),NNBASX)
             CALL GET1IN(WORK(KINTAO),'NPETES ',NOCOMP,WORK(KFREE),     &
     &                   LFREE,LABINT,INTREP,INTADR,J,TOFILE,KPATOM,    &
     &                   TRIMAT,DUMMY,EXP1VL,DUMMY,0)
!            Zero temporary arrays
             CALL DZERO(WORK(KTRMO),NNORBX)
             CALL DZERO(WORK(KUTR),N2ORBX)
             if (.not. present(fvvec2)) then
                CALL DZERO(WORK(KUTRX),N2ORBX)
                CALL DZERO(WORK(KURXAC),N2ASHX)
             end if

!            Transform integrals
             CALL UTHU(WORK(KINTAO),WORK(KTRMO),CMO,WORK(KFREE),NBAST, NORBT)
             CALL DSPTSI(NORBT,WORK(KTRMO),WORK(KUTR))

             if (present(fvvec2)) then
!            Determine electric field component size
             F1VAL = 0.0d0
             F2VAL = 0.0d0
             IF (ISYMT.EQ.ISYMV1) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL MELONE(WORK(KTLMA),1,UDV,1.0d0,F1VAL,200,             &
     &                      'QMNPQRO')
                FVVEC1(JOFF) = F1VAL
             END IF
             IF (ISYMT.EQ.MULD2H(ISYMV1,ISYMV2)) THEN
                CALL DZERO(WORK(KTLMA),N2ORBX)
                CALL DZERO(WORK(KTLMB),N2ORBX)
                CALL OITH1(ISYMV1,ZYM1,WORK(KUTR),WORK(KTLMA),ISYMT)
                CALL OITH1(ISYMV2,ZYM2,WORK(KTLMA),WORK(KTLMB),ISYMV2)
                CALL MELONE(WORK(KTLMB),1,UDV,1.0d0,F2VAL,200,             &
     &                      'QMNPQRO')
                FVVEC2(JOFF) = F2VAL
             ENDIF
             else
             CALL ONEXH1(BOVECS(ISIMOFF),WORK(KUTR),WORK(KUTRX))
!
             IF (NASHT.GT.0) CALL GETACQ(WORK(KUTRX),WORK(KURXAC))
             IF (TRPLET) THEN
                 fvvec1(JOFF) = SLVTLM(UDVTR,WORK(KURXAC),WORK(KUTRX),   &
     &                                TAC)
             ELSE
                 fvvec1(JOFF) = SLVQLM(UDV,WORK(KURXAC),WORK(KUTRX),     &
     &                                TAC)
             ENDIF
             end if

           END DO

!           Set Lagrangian for charge equilibration
            DO IBLK = 1, TNPBLK
               fvvec1(IOFF + IDIM) = fvvec1(IOFF + IDIM) + NPCHRG(IBLK)
            END DO
            if (present(fvvec2)) then
               DO IBLK = 1, TNPBLK
                  fvvec2(IOFF + IDIM) = fvvec2(IOFF + IDIM) + NPCHRG(IBLK)
               END DO
            end if
        END DO
        RUNQM3 = .FALSE.
        CALL MEMREL('GET_FVVEC_QR',WORK,1,1,KFREE,LFREE)
      END IF
!     Restore origin coordinates
      DIPORG = dipole_origin_save
!     Print final FV vector
      DO I=1,NSIM
         if (iprtlvl > 14 .and. .not. mqiter) then
            IOFF = (I-1)*IDIM+1
            write(lupri, '(/,2x,a,i0)') &
                '*** Computed FV vector start 1 ', i
            do j = 1, idim
               write(lupri, '(i8, f18.8)') j, fvvec1(IOFF + j - 1)
            end do
            write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
            if (present(fvvec2)) then
               write(lupri, '(/,2x,a,i0)') &
                   '*** Computed FV vector start 2 ', i
               do j = 1, idim
                  write(lupri, '(i8, f18.8)') j, fvvec2(IOFF + j - 1)
               end do
               write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
            end if
         end if
      END DO
!
      end subroutine

   subroutine get_xyvec(cmo,     &
                        idim,    &
                        nsim,    &
                        fvec,    &
                        work,    &
                        lwork,   &
                        fmqvec1, &
                        fmqvec2, &
                        isymt,   &
                        isymv2,  &
                        zym2)
!
! Purpose:
!     Computes contribution to XY vector from induced dipoles moments
!     and charges.
!
! Input:
!   FMQVEC - Induced dipole moments and charges
!   CMO    - Molecular orbitals
!   WORK   - Temporary memory array
!   LWORK  - Size of temporary memory array
! Output:
!   FVEC - Contribution to XY vector from induced dipole moments and
!            charges
!   IDIM   - Size of electric field/potential vector
!   NSIM  - Number of perturbed density matrices
!
! Last updated: 22/03/2013 by Z. Rinkevicius.
!

      real(8), intent(in)           :: cmo(*)
      integer, intent(in)           :: idim
      integer, intent(in)           :: nsim
      integer, intent(in)           :: lwork
      real(8), intent(in)           :: fvec(*)
      real(8), intent(out)          :: work(*)
      real(8), intent(in)           :: fmqvec1(*)
      real(8), intent(in), optional :: fmqvec2(*)
      integer, intent(in), optional :: isymt
      integer, intent(in), optional :: isymv2
      real(8), intent(in), optional :: zym2(*)

#include "dummy.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"

      logical :: tofile
      logical :: trimat
      logical :: exp1vl
      real(8) :: dipole_origin_save(3)
      integer :: i
      integer :: j
      integer :: ioff
      integer :: joff
      integer :: istart
      integer :: kpatom
      integer :: nocomp
      integer :: isimoff
      real(8) :: fact
      real(8) :: fact1
      real(8) :: fact2
      integer :: ixyz

      real(8), allocatable :: utr(:)
      real(8), allocatable :: trmo(:)
      real(8), allocatable :: intao(:)
      real(8), allocatable :: tlma(:)
      integer, allocatable :: intrep(:)
      integer, allocatable :: intadr(:)
      character(8), allocatable :: labint(:)

      ! save origin coordinates
      dipole_origin_save = diporg

      allocate(utr(n2orbx))
      allocate(trmo(nnorbx))
      allocate(intao(3*nnbasx))
      if (present(fmqvec2)) then
          allocate(tlma(n2orbx))
      end if
      allocate(intrep(9*mxcent))
      allocate(intadr(9*mxcent))
      allocate(labint(9*mxcent))

      kpatom = 0
      tofile = .false.
      trimat = .true.
      exp1vl = .false.
      runqm3 = .true.

      ! induced dipole moment in np region interaction with qm region
      if (donppol .and. novdamp) then
         nocomp = 3
         do i = 1, nsim
            ioff = (i - 1)*idim
            isimoff = (i - 1)*n2orbx + 1
            do j = 1, tnpatm
               joff = ioff + (j - 1)*3
               diporg = npcord(:, j)
               intao = 0.0d0
               call get1in(intao, 'NEFIELD', nocomp, work,                   &
                           lwork, labint, intrep, intadr, j, tofile, kpatom, &
                           trimat, dummy, exp1vl, dummy, 0)

               ! loop over x, y, z
               do ixyz = 1, 3

                  ! transform integrals
                  utr = 0.0d0
                  trmo = 0.0d0
                  call uthu(intao((ixyz - 1)*nnbasx + 1), trmo, cmo, work, nbast, norbt)
                  call dsptsi(norbt, trmo, utr)

                  ! determine mm region contribution
                  fact1 = -fmqvec1(joff + ixyz)
                  if (present(fmqvec2)) then
                     tlma = 0.0d0
                     call oith1(isymv2, zym2, utr, tlma, isymt)
                     call daxpy(n2orbx, fact1, tlma, 1, fvec, 1)
                     fact2 = -0.5d0*fmqvec2(joff + ixyz)
                     call daxpy(n2orbx, fact2, tlma, 1, fvec, 1)
                  else
                     call daxpy(n2orbx, fact1, utr, 1, fvec(isimoff), 1)
                  end if
               end do
            end do
         end do
      end if

      ! induced dipole moment in np region interaction with qm region
      if (donpcap .and. novdamp) then
         istart = 0
         if (donppol) istart = 3*tnpatm
         nocomp = 1
         do i = 1, nsim
            ioff = (i - 1)*idim
            isimoff = (i - 1)*n2orbx + 1
            do j = 1, tnpatm
               joff = ioff + istart + j
               diporg = npcord(:, j)
               intao = 0.0d0
               call get1in(intao, 'NPETES ', nocomp, work,                   &
                           lwork, labint, intrep, intadr, j, tofile, kpatom, &
                           trimat, dummy, exp1vl, dummy, 0)

               ! transform integrals
               utr = 0.0d0
               trmo = 0.0d0
               call uthu(intao, trmo, cmo, work, nbast, norbt)
               call dsptsi(norbt, trmo, utr)

               ! determine mm region contribution
               fact1 = fmqvec1(joff)
               if (present(fmqvec2)) then
                  tlma = 0.0d0
                  call oith1(isymv2, zym2, utr, tlma, isymt)
                  call daxpy(n2orbx, fact1, tlma, 1, fvec, 1)
                  fact2 = 0.5d0*fmqvec2(joff)
                  call daxpy(n2orbx, fact2, tlma, 1, fvec, 1)
               else
                  call daxpy(n2orbx, fact1, utr, 1, fvec(isimoff), 1)
               end if
            end do
         end do
      end if

      if (allocated(utr))    deallocate(utr)
      if (allocated(trmo))   deallocate(trmo)
      if (allocated(intao))  deallocate(intao)
      if (allocated(tlma))   deallocate(tlma)
      if (allocated(intrep)) deallocate(intrep)
      if (allocated(intadr)) deallocate(intadr)
      if (allocated(labint)) deallocate(labint)

      ! restore origin coordinates
      diporg = dipole_origin_save

   end subroutine

end module
