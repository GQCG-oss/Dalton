module qmcmm_response

   implicit none

   public get_fvvec
   public get_xyvec

   private

contains

   ! computes electric field/potential vector generated by first or second
   ! order perturbed density matrix
   subroutine get_fvvec(idim,   &
                        nsim,   &
                        udv,    &
                        cmo,    &
                        work,   &
                        lwork,  &
                        fvvec1, &
                        fvvec2, &
                        udvtr,  &
                        bovecs, &
                        isymt,  &
                        isymv1, &
                        isymv2, &
                        zym1,   &
                        zym2)

      ! size of electric field/potential vector
      integer, intent(in)              :: idim
      ! number of perturbed density matrices
      integer, intent(in)              :: nsim
      real(8), intent(in)              :: udv(nashdi, nashdi)
      real(8), intent(in)              :: cmo(*)
      real(8), intent(inout)           :: work(*)
      integer, intent(in)              :: lwork
      ! electric field/potential vector at np/mm centers
      real(8), intent(inout)           :: fvvec1(*)
      real(8), intent(inout), optional :: fvvec2(*)
      real(8), intent(in),    optional :: udvtr(n2ashx)
      real(8), intent(in),    optional :: bovecs(*)
      integer, intent(in),    optional :: isymt
      integer, intent(in),    optional :: isymv1
      integer, intent(in),    optional :: isymv2
      real(8), intent(in),    optional :: zym1(*)
      real(8), intent(in),    optional :: zym2(*)

#include "dummy.h"
#include "priunit.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"

      logical :: tofile
      logical :: trimat
      logical :: exp1vl
      real(8) :: dipole_origin_save(3)
      integer :: i
      integer :: j
      integer :: ioff
      integer :: joff
      integer :: istart
      integer :: iblk
      integer :: nocomp
      integer :: kpatom
      integer :: isimoff
      integer :: ixyz
      real(8) :: f1val, f2val
      real(8) :: fact
      real(8) :: tac

      real(8), external :: slvtlm
      real(8), external :: slvqlm

      real(8), allocatable :: intao(:)
      real(8), allocatable :: trmo(:)
      real(8), allocatable :: utr(:)
      real(8), allocatable :: tlma(:)
      real(8), allocatable :: tlmb(:)
      real(8), allocatable :: utrx(:)
      real(8), allocatable :: urxac(:)
      integer, allocatable :: intrep(:)
      integer, allocatable :: intadr(:)
      character(8), allocatable :: labint(:)

      ! save origin coordinates
      dipole_origin_save = diporg

      call dzero(fvvec1, idim*nsim)
      if (present(fvvec2)) then
         call dzero(fvvec2, idim*nsim)
      end if

      allocate(intao(3*nnbasx))
      allocate(trmo(nnorbx))
      allocate(utr(n2orbx))
      if (present(fvvec2)) then
         allocate(tlma(n2orbx))
         allocate(tlmb(n2orbx))
      else
         allocate(utrx(n2orbx))
         allocate(urxac(n2ashx))
      end if
      allocate(intrep(9*mxcent))
      allocate(intadr(9*mxcent))
      allocate(labint(9*mxcent))

      kpatom = 0
      tofile = .false.
      trimat = .true.
      exp1vl = .false.
      runqm3 = .true.

      ! compute electric field if needed
      if (donppol) then

         nocomp = 3

         ! loop over perturbed densities
         do i = 1, nsim
            ioff = (i-1)*idim
            isimoff = (i-1)*n2orbx+1

            ! loop over np centers
            do j = 1, tnpatm
               joff = ioff+(j-1)*3
               diporg = npcord(:, j)

               intao = 0.0d0
               call get1in(intao,'NEFIELD',nocomp,work,     &
                           lwork,labint,intrep,intadr,j,tofile,kpatom,    &
                           trimat,dummy,exp1vl,dummy,0)

               do ixyz = 1, 3

                  trmo = 0.0d0
                  utr = 0.0d0
                  if (.not. present(fvvec2)) then
                     utrx = 0.0d0
                     urxac = 0.0d0
                  end if

                  ! transform integrals
                  call uthu(intao((ixyz-1)*nnbasx + 1),trmo,cmo,work,nbast,norbt)
                  call dsptsi(norbt,trmo,utr)

                  if (present(fvvec2)) then
                     ! determine electric field component size
                     f1val = 0.0d0
                     f2val = 0.0d0
                     if (isymt.eq.isymv1) then
                        tlma = 0.0d0
                        call oith1(isymv1,zym1,utr,tlma,isymt)
                        call melone(tlma,1,udv,1.0d0,f1val,200,'qmnpqro')
                        fvvec1(joff+ixyz) = f1val
                     end if
                     if (isymt.eq.muld2h(isymv1,isymv2)) then
                        tlma = 0.0d0
                        tlmb = 0.0d0
                        call oith1(isymv1,zym1,utr,tlma,isymt)
                        call oith1(isymv2,zym2,tlma,tlmb,isymv2)
                        call melone(tlmb,1,udv,1.0d0,f2val,200,'qmnpqro')
                        fvvec2(joff+ixyz) = f2val
                     endif
                  else
                     call onexh1(bovecs(isimoff),utr,utrx)
                     if (nasht.gt.0) call getacq(utrx,urxac)
                     if (trplet) then
                         fvvec1(joff+ixyz) = slvtlm(udvtr,urxac,utrx,tac)
                     else
                         fvvec1(joff+ixyz) = slvqlm(udv,urxac,utrx,tac)
                     endif
                  end if
               end do
            end do
         end do
      end if

      if (donpcap) then

         istart = 0
         if (donppol) istart = 3*tnpatm

         nocomp = 1

         ! loop over perturbed first order densities
         do i = 1, nsim
            ioff = (i-1)*idim
            isimoff = (i-1)*n2orbx+1

            ! loop over np centers
            do j = 1, tnpatm
               joff = ioff+istart+j
               diporg = npcord(:, j)

               intao = 0.0d0
               call get1in(intao,'NPETES ',nocomp,work,     &
                           lwork,labint,intrep,intadr,j,tofile,kpatom,    &
                           trimat,dummy,exp1vl,dummy,0)

               trmo = 0.0d0
               utr = 0.0d0
               if (.not. present(fvvec2)) then
                  utrx = 0.0d0
                  urxac = 0.0d0
               end if

               ! transform integrals
               call uthu(intao,trmo,cmo,work,nbast, norbt)
               call dsptsi(norbt,trmo,utr)

               if (present(fvvec2)) then
                  f1val = 0.0d0
                  f2val = 0.0d0
                  if (isymt.eq.isymv1) then
                     tlma = 0.0d0
                     call oith1(isymv1,zym1,utr,tlma,isymt)
                     call melone(tlma,1,udv,1.0d0,f1val,200,'qmnpqro')
                     fvvec1(joff) = f1val
                  end if
                  if (isymt.eq.muld2h(isymv1,isymv2)) then
                     tlma = 0.0d0
                     tlmb = 0.0d0
                     call oith1(isymv1,zym1,utr,tlma,isymt)
                     call oith1(isymv2,zym2,tlma,tlmb,isymv2)
                     call melone(tlmb,1,udv,1.0d0,f2val,200,'qmnpqro')
                     fvvec2(joff) = f2val
                  endif
               else
                  call onexh1(bovecs(isimoff),utr,utrx)
                  if (nasht.gt.0) call getacq(utrx,urxac)
                  if (trplet) then
                      fvvec1(joff) = slvtlm(udvtr,urxac,utrx,tac)
                  else
                      fvvec1(joff) = slvqlm(udv,urxac,utrx,tac)
                  endif
               end if
            end do

            ! set lagrangian for charge equilibration
            do iblk = 1, tnpblk
               fvvec1(ioff + idim) = fvvec1(ioff + idim) + npchrg(iblk)
            end do
            if (present(fvvec2)) then
               do iblk = 1, tnpblk
                  fvvec2(ioff + idim) = fvvec2(ioff + idim) + npchrg(iblk)
               end do
            end if
         end do
      end if

      ! print final fv vector
      do i = 1, nsim
         if (iprtlvl > 14 .and. .not. mqiter) then
            ioff = (i - 1)*idim + 1
            write(lupri, '(/,2x,a,i0)') &
                '*** Computed FV vector start 1 ', i
            do j = 1, idim
               write(lupri, '(i8, f18.8)') j, fvvec1(IOFF + j - 1)
            end do
            write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
            if (present(fvvec2)) then
               write(lupri, '(/,2x,a,i0)') &
                   '*** Computed FV vector start 2 ', i
               do j = 1, idim
                  write(lupri, '(i8, f18.8)') j, fvvec2(IOFF + j - 1)
               end do
               write(lupri, '(/,2x,a)') '*** Computed FV vector end ***'
            end if
         end if
      end do

      if (allocated(intao))  deallocate(intao)
      if (allocated(trmo))   deallocate(trmo)
      if (allocated(utr))    deallocate(utr)
      if (allocated(tlma))   deallocate(tlma)
      if (allocated(tlmb))   deallocate(tlmb)
      if (allocated(utrx))   deallocate(utrx)
      if (allocated(urxac))  deallocate(urxac)
      if (allocated(intrep)) deallocate(intrep)
      if (allocated(intadr)) deallocate(intadr)
      if (allocated(labint)) deallocate(labint)

      runqm3 = .false.

      ! restore origin coordinates
      diporg = dipole_origin_save

   end subroutine


   ! computes contribution to xy vector from induced dipoles moments and charge
   subroutine get_xyvec(cmo,     &
                        idim,    &
                        nsim,    &
                        fvec,    &
                        work,    &
                        lwork,   &
                        fmqvec1, &
                        fmqvec2, &
                        isymt,   &
                        isymv2,  &
                        zym2)

      ! molecular orbital coefficients
      real(8), intent(in)           :: cmo(*)
      ! size of electric field/potential vector
      integer, intent(in)           :: idim
      ! number of perturbed density matrice
      integer, intent(in)           :: nsim
      integer, intent(in)           :: lwork
      real(8), intent(inout)        :: fvec(*)
      real(8), intent(inout)        :: work(*)
      ! induced dipole moments and charges
      real(8), intent(in)           :: fmqvec1(*)
      real(8), intent(in), optional :: fmqvec2(*)
      integer, intent(in), optional :: isymt
      integer, intent(in), optional :: isymv2
      real(8), intent(in), optional :: zym2(*)

#include "dummy.h"
#include "qmnpmm.h"
#include "inforb.h"
#include "infdim.h"
#include "mxcent.h"
#include "iratdef.h"
#include "nuclei.h"
#include "orgcom.h"
#include "qm3.h"
#include "infrsp.h"

      logical :: tofile
      logical :: trimat
      logical :: exp1vl
      real(8) :: dipole_origin_save(3)
      integer :: i
      integer :: j
      integer :: ioff
      integer :: joff
      integer :: istart
      integer :: kpatom
      integer :: nocomp
      integer :: isimoff
      real(8) :: fact
      real(8) :: fact1
      real(8) :: fact2
      integer :: ixyz

      real(8), allocatable :: utr(:)
      real(8), allocatable :: trmo(:)
      real(8), allocatable :: intao(:)
      real(8), allocatable :: tlma(:)
      integer, allocatable :: intrep(:)
      integer, allocatable :: intadr(:)
      character(8), allocatable :: labint(:)

      ! save origin coordinates
      dipole_origin_save = diporg

      allocate(utr(n2orbx))
      allocate(trmo(nnorbx))
      allocate(intao(3*nnbasx))
      if (present(fmqvec2)) then
          allocate(tlma(n2orbx))
      end if
      allocate(intrep(9*mxcent))
      allocate(intadr(9*mxcent))
      allocate(labint(9*mxcent))

      kpatom = 0
      tofile = .false.
      trimat = .true.
      exp1vl = .false.
      runqm3 = .true.

      ! induced dipole moment in np region interaction with qm region
      if (donppol .and. novdamp) then
         nocomp = 3
         do i = 1, nsim
            ioff = (i - 1)*idim
            isimoff = (i - 1)*n2orbx + 1
            do j = 1, tnpatm
               joff = ioff + (j - 1)*3
               diporg = npcord(:, j)
               intao = 0.0d0
               call get1in(intao, 'NEFIELD', nocomp, work,                   &
                           lwork, labint, intrep, intadr, j, tofile, kpatom, &
                           trimat, dummy, exp1vl, dummy, 0)

               ! loop over x, y, z
               do ixyz = 1, 3

                  ! transform integrals
                  utr = 0.0d0
                  trmo = 0.0d0
                  call uthu(intao((ixyz - 1)*nnbasx + 1), trmo, cmo, work, nbast, norbt)
                  call dsptsi(norbt, trmo, utr)

                  ! determine mm region contribution
                  fact1 = -fmqvec1(joff + ixyz)
                  if (present(fmqvec2)) then
                     tlma = 0.0d0
                     call oith1(isymv2, zym2, utr, tlma, isymt)
                     call daxpy(n2orbx, fact1, tlma, 1, fvec, 1)
                     fact2 = -0.5d0*fmqvec2(joff + ixyz)
                     call daxpy(n2orbx, fact2, tlma, 1, fvec, 1)
                  else
                     call daxpy(n2orbx, fact1, utr, 1, fvec(isimoff), 1)
                  end if
               end do
            end do
         end do
      end if

      ! induced dipole moment in np region interaction with qm region
      if (donpcap .and. novdamp) then
         istart = 0
         if (donppol) istart = 3*tnpatm
         nocomp = 1
         do i = 1, nsim
            ioff = (i - 1)*idim
            isimoff = (i - 1)*n2orbx + 1
            do j = 1, tnpatm
               joff = ioff + istart + j
               diporg = npcord(:, j)
               intao = 0.0d0
               call get1in(intao, 'NPETES ', nocomp, work,                   &
                           lwork, labint, intrep, intadr, j, tofile, kpatom, &
                           trimat, dummy, exp1vl, dummy, 0)

               ! transform integrals
               utr = 0.0d0
               trmo = 0.0d0
               call uthu(intao, trmo, cmo, work, nbast, norbt)
               call dsptsi(norbt, trmo, utr)

               ! determine mm region contribution
               fact1 = fmqvec1(joff)
               if (present(fmqvec2)) then
                  tlma = 0.0d0
                  call oith1(isymv2, zym2, utr, tlma, isymt)
                  call daxpy(n2orbx, fact1, tlma, 1, fvec, 1)
                  fact2 = 0.5d0*fmqvec2(joff)
                  call daxpy(n2orbx, fact2, tlma, 1, fvec, 1)
               else
                  call daxpy(n2orbx, fact1, utr, 1, fvec(isimoff), 1)
               end if
            end do
         end do
      end if

      if (allocated(utr))    deallocate(utr)
      if (allocated(trmo))   deallocate(trmo)
      if (allocated(intao))  deallocate(intao)
      if (allocated(tlma))   deallocate(tlma)
      if (allocated(intrep)) deallocate(intrep)
      if (allocated(intadr)) deallocate(intadr)
      if (allocated(labint)) deallocate(labint)

      ! restore origin coordinates
      diporg = dipole_origin_save

   end subroutine

end module
