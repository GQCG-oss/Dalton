!
!...   Copyright (c) 2011 by the authors of Dalton (see below).
!...   All Rights Reserved.
!...
!...   The source code in this file is part of
!...   "Dalton, a molecular electronic structure program,
!...    Release DALTON2011 (2011), see http://daltonprogram.org"
!...
!...   This source code is provided under a written licence and may be
!...   used, copied, transmitted, or stored only in accord with that
!...   written licence.
!...
!...   In particular, no part of the source code or compiled modules may
!...   be distributed outside the research group of the licence holder.
!...   This means also that persons (e.g. post-docs) leaving the research
!...   group of the licence holder may not take any part of Dalton,
!...   including modified files, with him/her, unless that person has
!...   obtained his/her own licence.
!...
!...   For further information, including how to get a licence, see:
!...      http://daltonprogram.org
!
***********************************************************************

      subroutine davidson_ci_driver(block_list,par_dist_block_list,
     &                              proclist,grouplist,fh_array,rcctos,
     &                              nblock,iprnt,vec1,vec2,c2)
*
* CI optimization in defined GAS spaces
*
*
* Jeppe Olsen, Winter of 1995
*
#ifdef VAR_MPI
      use dalton_mpi
      use file_io_model
      use par_mcci_io
#endif
      use file_type_module
      use lucita_energy_types
      IMPLICIT REAL*8(A-H,O-Z)
#include "mxpdim.inc"
#include "wrkspc.inc"
#include "clunit.inc"
#include "cstate.inc"
#include "crun.inc"
#include "glbbas.inc"
#include "cgas.inc"
#ifdef VAR_MPI
#include "maxorb.h"
#include "infpar.h"
#include "mpif.h"
      DIMENSION my_STATUS(MPI_STATUS_SIZE)
      INTEGER(KIND=MPI_OFFSET_KIND) ITEST_OFF
#endif
#include "parluci.h"
      real(8), intent(inout) :: vec1(*)
      real(8), intent(inout) :: vec2(*)
      real(8), intent(inout) :: c2(*)
      integer, intent(in)    :: proclist(luci_nmproc)
      integer, intent(in)    :: grouplist(luci_nmproc)
      integer, intent(inout) :: fh_array(nr_files)
!     general information needed in parallel runs
      integer, intent(in)    :: par_dist_block_list(nblock)
      integer, intent(in)    :: block_list(nblock)
      integer, intent(in)    :: rcctos(nblock)
!-----------------------------------------------------------------------
      integer(8)             :: cvec_file_size
!-----------------------------------------------------------------------

      NTEST = 0
      NTEST = MAX(NTEST,IPRNT)

      WRITE(LUWRT,'(a,i14)') 
     &     '  @@ Number of determinants/combinations: ',
     &           l_combi

      LBLK = - 1
      IF(ICISTR.EQ.1) LBLK = l_combi

!     restart cross check (experimental; should work with ifort/gfortran >= 4.5)
      if(irestr .eq. 0 .and.  LUCI_MYPROC .eq. LUCI_MASTER )then
        cvec_file_size = 0
        inquire(unit=luc, size=cvec_file_size)
        if(cvec_file_size .gt. 0) irestr = 1
      end if

#ifdef VAR_MPI
      IF(LUCI_NMPROC .GT. 1)THEN

!       update - might have changed because of the above (experimental) cross check
        call dalton_mpi_bcast(irestr,LUCI_MASTER,MPI_COMM_WORLD)

        call izero(file_info%iluxlist(1,2),file_info%max_list_length)
!       copy restart vector to MPI-file format
        IF(IRESTR .eq. 1)THEN
          WRITE(LUWRT,'(A)')
     &    '  restart file LUCITA_CVECS.x will be transformed'//
     &    ' to MPIs file-i/o format ...'
          IF( LUCI_MYPROC .eq. LUCI_MASTER ) CALL REWINE(LUC,-1)
          call mcci_cp_vcd_mpi_2_seq_io_interface(VEC1,LUC,ILU1,
     &                                            MY_LU1_OFF,
     &                                            file_info%
     &                                            iluxlist(1,2),
     &                                            par_dist_block_list,
     &                                            block_list,
     &                                            MPI_COMM_WORLD,
     &                                            NUM_BLOCKS2,NROOT,1,1)
          CALL REWINE(LUC,LBLK)
          WRITE(LUWRT,'(A)') '  ... done! '
        END IF

      end if ! (LUCI_NMPROC .GT. 1) THEN
#endif

!     transfer control to optimization routine
!     ----------------------------------------
      CALL CIEIG5(IRESTR,VEC1,VEC2,C2,LUDIA,
     &            LUC,LUHC,LUSC1,LUSC2,LUSC3,LUSC34,LUSC35,LUSC41,
     &            l_combi,NROOT,MXCIV,MAXIT,LUCIVI,
     &            IPRNT,WORK(KSBEVC),0,WORK(KH0),WORK(KSBIDT),
     &            MXP1,MXP2,MXQ,WORK(KH0SCR),ECORE,ICISTR,LBLK,IDIAG,
     &            THRES_E,THRES_E_aux,INIDEG,LBLOCK,IROOTHOMING,NCISPC,
     &            ICSPC,block_list,par_dist_block_list,RCCTOS,
     &            PROCLIST,GROUPLIST
#ifdef VAR_MPI
     &           ,file_info%iluxlist(1,2), file_info%iluxlist(1,3),
     &            file_info%iluxlist(1,5), file_info%iluxlist(1,6),
     &            file_info%iluxlist(1,7), file_info%iluxlist(1,8),
     &            file_info%iluxlist(1,9), file_info%ilublist
#endif
     &            )
 
#ifdef VAR_MPI
!     check for restart without CI
      IF(MAXIT .lt. 0) goto 777

      IF(LUCI_NMPROC .GT. 1)THEN
!       close (and re-open) parallel files that are no longer needed
!       which will free disk space for copyig back the vectors...
        call close_file_io_model(nr_files-1,2,fh_array)
!       re-open
        call setup_file_io_model(mynew_comm,nr_files-2,fh_array,2,
     &                           my_groupn,newcomm_proc,
     &                           'parci',luwrt)
!       transfer file handles to common block /LUCIAPFILE/ (in parluci.h)
        ILU2 = fh_array( 3)
        IDIA = fh_array( 4)
        ILUC = fh_array( 5)
        ILU3 = fh_array( 6)
        ILU4 = fh_array( 7)
        ILU5 = fh_array( 8)
        ILU6 = fh_array( 9)
        ILU7 = fh_array(10)

!       copy c-vectors from nodes and master back to the master
        CALL REWINE(LUC,-1)

        call mcci_cp_vcd_mpi_2_seq_io_interface(VEC1,LUC,ILU1,
     &                                          MY_LU1_OFF,
     &                                          file_info%iluxlist(1,2),
     &                                          par_dist_block_list,
     &                                          block_list,
     &                                          MPI_COMM_WORLD,
     &                                          NUM_BLOCKS2,NROOT,1,2)
#ifdef LUCI_DEBUG
        CALL REWINE(LUC,LBLK)
        IF(LUCI_MYPROC.EQ.LUCI_MASTER) THEN
          DO IVEC = 1, NROOT
            WRITE(LUWRT,*) '  final solution vector ==> ',IVEC
            CALL WRTVCD(VEC1,LUC,0,LBLK)
          END DO
        END IF
        CALL REWINE(LUC,LBLK)
#endif

      END IF ! (LUCI_NMPROC .GT. 1) THEN
#endif

!     eliminate scratch units
!     -----------------------
 777  close(unit=LUSC2, status='DELETE')
      close(unit=LUSC3, status='DELETE')
      close(unit=LUSC34,status='DELETE')
      close(unit=LUSC35,status='DELETE')
      close(unit=LUSC36,status='DELETE')
      close(unit=LUSC37,status='DELETE')
      close(unit=LUSC38,status='DELETE')
      close(unit=LUSC40,status='DELETE')
      close(unit=LU91,  status='DELETE')
      close(unit=LUSC41,status='DELETE')
 
      END
***********************************************************************

      SUBROUTINE CIEIG5(IRESTR,VEC1,VEC2,C2,LUDIA,LU1,LU2,LU3,
     &                  LU4,LU5,LU6,LU7,LU41,NDIM,NROOTSL,MAXVEC,
     &                  MXCIIT,LUINCI,IPRT,PEIGVC,NPRDET,H0,IPNTR,
     &                  NP1,NP2,NQ,H0SCR,EIGSHF,ICISTR,LBLK,IDIAG,
     &                  THRES_E,THRES_E_aux,INIDEG,
     &                  MXLNG,IROOTHOMING,NSPC,ISPC,IBLOCKAR,
     &                  IBLKDSTND,RCCTOS,IPROCLIST,IGROUPLIST
#ifdef VAR_MPI
     &                  ,LU1LIST,LU2LIST,LU3LIST,LU4LIST,LU5LIST,
     &                  LU6LIST,LU7LIST,LUCLIST
#endif
     &                  )

!
! Master routine for CI diagonalization
!
      IMPLICIT REAL*8(A-H,O-Z)
      INTEGER*8 KLXLBT, KLXLEBT, KLXI1BT, KLXIBT
!               for addressing of WORK
#ifdef VAR_MPI
#include "maxorb.h"
#include "infpar.h"
#include "mpif.h"
      DIMENSION my_STATUS(MPI_STATUS_SIZE)
      DIMENSION LU1LIST(*), LU2LIST(*), LU3LIST(*)
      DIMENSION LU4LIST(*), LU5LIST(*), LUCLIST(*)
      DIMENSION LU7LIST(*), LU6LIST(*)
#endif
#include "priunit.h"
#include "parluci.h"
#include "files.inc"
#include "mxpdim.inc"
! Definition of c and sigma
#include "cands.inc"
! NACOB used
#include "orbinp.inc"
#include "cicisp.inc"
#include "strbas.inc"
#include "cstate.inc"
#include "strinp.inc"
#include "stinf.inc"
#include "csm.inc"
#include "wrkspc.inc"
#include "gasstr.inc"
#include "cgas.inc"
! NSMOB used
#include "lucinp.inc"
#include "cprnt.inc"
#include "glbbas.inc"
#include "oper.inc"
      LOGICAL CA
C
C
      DIMENSION VEC1(*),VEC2(*),C2(*)
      PARAMETER( LLWRK = 100000)
      integer, allocatable  :: iscr1(:)
      real(8), allocatable  :: scr1(:)
*. Output from Subspace dagonalization
      DIMENSION H0(*),IPNTR(*),H0SCR(*),PEIGVC(*)
*.
      INTEGER   RCCTOS(*)

!     use dynamic instead of static allocation (+ common block)
      allocate(iscr1(llwrk))
      allocate(scr1(llwrk))
*
      IF( IPRT.GT. 1 )  WRITE(luwrt,'(/A)')
     &'          *** information from ci diagonalization  ***'
!     NTEST = 9999 ! NTEST=0
      NTEST = 0
C
C               ====================================
C  1 :               INITIAL VARIATIONAL SUBSPACE
C               ====================================
C
      IF( IRESTR .EQ. 0 ) THEN
        IF(NPRDET .EQ. 0 ) THEN
C         ==================================================
C          Initial guess from lowest elements of CI diagonal
C         ==================================================
C
C         in order treat degeneracies, the lowest 4 * NROOTSL
C         elements are obtained
C
          NFINDM = MIN(NDIM,4*NROOTSL)
C
          IF (LUCI_NMPROC .GT. 1) THEN
#ifdef VAR_MPI
              CALL FNDMND_PAR(LUDIA,LBLK,VEC1,NFINDM,NFINDA,
     &                    ISCR1(1+2*NFINDM),SCR1(1+2*NFINDM),ISCR1,
     &                    SCR1,IBLOCKAR,IBLKDSTND,NUM_BLOCKS2,IPRT)
#endif
          ELSE
             CALL FNDMND(LUDIA,LBLK,VEC1,NFINDM,NFINDA,
     &            ISCR1(1+2*NFINDM),SCR1(1+2*NFINDM),ISCR1,SCR1,IPRT)
          END IF
          CALL REWINE(LU1,-1)
          IBASE = 1
          TEST = 1.0D-10
          DO 100 IROOTSI = 1, NROOTSL
*. Number of degenerate elements
            NDEG = 1
            XVAL = SCR1(IBASE)
   90       CONTINUE
            IF(IBASE-1+NDEG+1.LE.NFINDA) THEN
              IF (ABS(SCR1(IBASE-1+NDEG+1)-XVAL).LE.TEST) THEN
                NDEG = NDEG + 1
                GOTO 90
              END IF
            END IF
*
            IF (INIDEG.EQ.0.AND.NDEG.GT.1) THEN
!             WRITE(luwrt,*) ' WARNING WARNING WARNING WARNING ! '
!             WRITE(luwrt,*) ' DEGENERATE INITIAL VECTORS FOR CI '
              NDEG = 1
            END IF

*. Initial guess in compressed form in SCR1
            SCALE = 1.0D0/SQRT(DFLOAT(NDEG))
            DO 250 II = 1,NDEG
*. Anti symmetric combination
              IF(INIDEG.EQ.-1) THEN
                SCR1(II) = (-1.0D0)**II * SCALE
*. Symmetric combination
              ELSE IF (INIDEG.EQ.1.OR.INIDEG.EQ.0) THEN
                SCR1(II) =  SCALE
              END IF
  250       CONTINUE
            IF(IDIAG.EQ.2) THEN
              JPACK = 1
            ELSE
              JPACK = 0
            END IF
            IF (LUCI_NMPROC .GT. 1) THEN
#ifdef VAR_MPI
               CALL WRSVCD_PAR(LU1,LBLK,VEC1,ISCR1(IBASE),SCR1,NDEG,
     &                      IBLOCKAR,IBLKDSTND,NUM_BLOCKS2,JPACK,
     &                      IROOTSI,LU1LIST)
#endif
            ELSE
               CALL WRSVCD(LU1,LBLK,VEC1,ISCR1(IBASE),SCR1,NDEG,NDIM,
     &                  LUDIA,JPACK)
            END IF
            IBASE = IBASE + NDEG
  100     CONTINUE
        ELSE
* =====================================
*. Initial approximations are in PEIGVC
* =====================================
          CALL REWINE(LU1,-1)
          IF(IDIAG.EQ.2) THEN
            JPACK = 1
          ELSE
            JPACK = 0
          END IF
          DO 1984 IROOTSI = 1, NROOTSL
            CALL WRSVCD(LU1,LBLK,VEC1,IPNTR,
     &           PEIGVC((IROOTSI-1)*NPRDET+1),NPRDET,NDIM,LUDIA,JPACK)
 1984     CONTINUE
        END IF
      END IF

!     release scratch memory
      deallocate(iscr1)

!
!     initialize arrays
      do i = 1, nrootsl
        eroot(i)          = 0.0d0
        root_residual(i)  = 0.0d0
        root_converged(i) = i
      end do
      nfinal_vec = nrootsl
!
!     check for initial CI vector generation only
      IF(MXCIIT .lt. 0) goto 999

!     =================
!      Diagonalization
!     =================
!

      CALL QENTER('CIEIG')
! Inverse iteration modified Davidson with 2 vectors in core
      write(luwrt,*) ' THRES_E is ',THRES_E
!     THRES_E = 1.0d-12
!     write(luwrt,*) ' bla bla THRES_E reset...'
      IF(IPRT .GE. 5 ) THEN
         WRITE(luwrt,'(A,I3)')
     &   '  Number of roots to be converged..  ',NROOTSL
         WRITE(luwrt,'(A,I3)')
     &   '  Largest allowed number of vectors..',MAXVEC
         WRITE(luwrt,'(A,I3)')
     &   '  Allowed number of CI iterations  ..',MXCIIT
      END IF

*     allocations for SCR1
      KRNRM  = 1
      KEIG   = KRNRM + MXCIIT*NROOTSL
      KFIN   = KEIG  + MXCIIT*NROOTSL
      KAPROJ = KFIN + NROOTSL
      KAVEC  = KAPROJ + MAXVEC*(MAXVEC+1)/2
      KWORK  = KAVEC + MAXVEC ** 2
      KLFREE = KWORK + MAXVEC*(MAXVEC+1)
      IF( IPRT .GE. 5 ) THEN
         WRITE(luwrt,*) ' KRNRM KEIG KFIN KAPROJ KAVEC KWORK KLFREE '
         WRITE(luwrt,'(6I8)')KRNRM,KEIG,KFIN,KAPROJ,KAVEC,KWORK,KLFREE
      END IF
      IF( KLFREE-1 .GT. LLWRK) THEN
         WRITE(luwrt,'(A,2I5)' )
     &   ' Not enough memory in CIEIG5 : neeeded and available ',
     &     KLFREE-1, LLWRK
         WRITE(luwrt,'(A,2I5)' )
     &   ' Increase parameter LLWRK in CIEIG5 to   ', KLFREE-1
         call quit( ' insufficient memory in cieig5 ' )
       END IF
*
      IF (LUCI_NMPROC .GT. 1) THEN
#ifdef VAR_MPI
C
C     partition CI vector with max. batch length using LBLOCK
C
      IDUM = 0
      CALL MEMMAN(IDUM,IDUM,'MARK  ',IDUM,'CIEIG5')
C
      IATP = 1
      IBTP = 2
C     Arrays for partitioning of rhs/lhs vector (symmetric because the
C     Hamiltonian is totally symmetric)
      NTTS = MXNTTS
      CALL MEMMAN(KLXLBT,   NTTS,'ADDL  ' ,1,'CLBT  ')
      CALL MEMMAN(KLXLEBT,  NTTS,'ADDL  ' ,1,'CLEBT ')
      CALL MEMMAN(KLXI1BT,  NTTS,'ADDL  ' ,1,'CI1BT ')
      CALL MEMMAN(KLXIBT, 8*NTTS,'ADDL  ' ,1,'CIBT  ')

      call Z_BLKFO_partitioning_parallel(icspc,icsm,iatp,ibtp,
     &                                   WORK(KLXLBT),WORK(KLXLEBT),
     &                                   WORK(KLXI1BT),WORK(KLXIBT),
     &                                   nbatch_par,nblock_par,
     &                                   IBLKDSTND)
 
       CALL MICDV6_PAR(VEC1,VEC2,C2,SCR1(KRNRM),SCR1(KEIG),nfinal_vec,
     &                 EROOT,root_converged,root_residual,
     &                 MXCIIT,NDIM,NROOTSL,
     &                 MAXVEC,NROOTSL,SCR1(KAPROJ),SCR1(KAVEC),
     &                 SCR1(KWORK),IPRT,NPRDET,H0,IPNTR,NP1,NP2,NQ,
     &                 H0SCR,LBLK,EIGSHF,THRES_E,IROOTHOMING,
     &                 luwrt,IBLOCKAR,IBLKDSTND,
     &                 RCCTOS,
     &                 LU1LIST,LU2LIST,LU3LIST,LU4LIST,LU5LIST,
     &                 LU6LIST,LU7LIST,LUCLIST,NBATCH_par,
     &                 WORK(KLXLBT),WORK(KLXLEBT),WORK(KLXI1BT),
     &                 WORK(KLXIBT),IPROCLIST,IGROUPLIST)

#endif
      ELSE ! (LUCI_NMPROC .GT. 1) THEN
       CALL MICDV6(VEC1,VEC2,C2,LU1,LU2,SCR1(KRNRM),SCR1(KEIG),
     &             nfinal_vec,EROOT,root_converged,root_residual,
     &             MXCIIT,NDIM,LU3,LU4,LU5,LU6,LU7,
     &             LUDIA,NROOTSL,
     &             MAXVEC,NROOTSL,SCR1(KAPROJ),SCR1(KAVEC),
     &             SCR1(KWORK) ,IPRT,NPRDET,H0,IPNTR,NP1,NP2,NQ,
     &             H0SCR,-1,EIGSHF,THRES_E,IROOTHOMING,luwrt)
      END IF ! (LUCI_NMPROC .GT. 1) THEN

#ifdef VAR_MPI
      IF (LUCI_NMPROC .GT. 1) THEN
C       eliminate local memory
        IDUM = 0
        CALL MEMMAN(KDUM ,IDUM,'FLUSM ',2,'CIEIG5')
      END IF ! (LUCI_NMPROC .GT. 1) THEN
#endif

      CALL QEXIT('CIEIG')

!     release scratch memory
 999  deallocate(scr1)

      END
***********************************************************************
