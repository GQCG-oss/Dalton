module polarizable_embedding

#ifdef VAR_MPI
    use mpi
#endif

    implicit none

    private

    intrinsic :: allocated, present, max, size, cpu_time

    public :: pe_dalton_input, pe_read_potential, pe_master
    public :: pe_save_density, pe_intmol_twoints, pe_repulsion
#ifdef VAR_MPI
    public :: pe_mpi
#endif

    ! precision
    integer, parameter :: dp = selected_real_kind(15, 200)

    ! options
    logical, public, save :: peqm = .false.
    logical, save :: pe_iter = .false.
    logical, save :: pe_border = .false.
    logical, save :: pe_damp = .false.
    logical, save :: pe_gspol = .false.
    logical, save :: pe_nomb = .false.
    logical, save :: pe_gauss = .false.
    logical, public, save :: pe_mep = .false.
    logical, public, save :: pe_twoint = .false.
    logical, public, save :: pe_repuls = .false.
    logical, public, save :: pe_savden = .false.
    logical, public, save :: pe_fd = .false.
    logical, save :: pe_timing = .false.

    ! calculation type
    logical, save :: fock = .false.
    logical, save :: energy = .false.
    logical, save :: response = .false.
    logical, save :: mep = .false.

    ! temporary solution for work array thing
    real(dp), dimension(:), pointer :: work

    ! MPI stuff
    integer, save :: myid, ncores, ierr
    logical, save :: initialized = .false.
    integer, dimension(:), save, allocatable :: npoldists, ndists, displs

    ! logical unit from dalton
    integer, save :: luout = 0

    ! constants, thresholds and stuff
    ! 1 bohr = 0.5291772108 Aa (codata 2002)
    real(dp), parameter :: aa2au = 1.8897261249935897d0
    real(dp), parameter :: zero = 1.0d-6
    integer, save :: scfcycle = 0
    real(dp), save :: thriter = 1.0d-8
    real(dp), save :: damp = 2.1304d0
    real(dp), save :: gauss = 0.44d0
    real(dp), save :: Rmin = 2.2d0
    character(len=6), save :: border_type = 'REDIST'
    logical, save :: chol = .true.

    ! C. E. Dykstra, J. Comp. Chem., 9 (1988), 476
    ! C^(n)_ij coefficients for calculating T(k) tensor elements
    integer, dimension(:,:,:), allocatable, save :: Cnij

    ! variables used for timings
    real(dp) :: t1, t2

    ! polarizable embedding potential info
    ! ------------------------------------

    ! number of sites
    integer, dimension(:), allocatable, public, save :: nsites
    ! number of polarizable sites
    integer, save :: npols = 0
    ! exclusion list length
    integer, save :: lexlst = 0
    
    ! specifies what type of parameters are present
    ! lmul(0): monopoles, lmul(1): dipoles etc.
    logical, dimension(0:5), public, save :: lmul = .false.
    ! lpol(1): (an)isotropic dipole-dipole polarizabilities
    logical, dimension(1), public, save :: lpol = .false.
    ! lhypol(1): dipole-dipole-dipole polarizabilities/1st hyperpolarizability
!    logical, dimension(1), public, save :: lhypol

    ! nuclear charges, coordinates, elements and exclusion lists
    ! nuclear charges
    real(dp), dimension(:,:), allocatable, save :: Zs
    ! coordinates
    real(dp), dimension(:,:), allocatable, save :: Rs
    ! elements
    character(len=2), dimension(:,:), allocatable, save :: elems
    ! exclusion list
    integer, dimension(:,:), allocatable, save :: exlists

    ! energy contributions
    ! electrostatic
    real(dp), dimension(:,:), allocatable, public, save :: Ees
    ! polarization
    real(dp), dimension(:,:), allocatable, public, save :: Epol

    ! multipole moments
    ! order of the highest order multipole moment
    integer, save :: mulorder = -1
    ! monopoles
    real(dp), dimension(:,:), allocatable, save :: M0s
    ! dipoles
    real(dp), dimension(:,:), allocatable, save :: M1s
    ! quadrupoles
    real(dp), dimension(:,:), allocatable, save :: M2s
    ! octopoles
    real(dp), dimension(:,:), allocatable, save :: M3s
    ! hexadecapoles
    real(dp), dimension(:,:), allocatable, save :: M4s
    ! ditriacontapoles
    real(dp), dimension(:,:), allocatable, save :: M5s

    ! (hyper)polarizabilities
    ! order of highest order polarizability
    integer, save :: polorder = -1
    ! dipole-dipole polarizabilities
    real(dp), dimension(:,:), allocatable, save :: P1s
    ! .true. if P1 > 0 else .false.
    logical, dimension(:), allocatable, save :: zeroalphas


    ! QM core fragment info
    ! ---------------------

    ! number of density matrices
    integer :: ndens = 0
    ! size of packed matrix in AO basis
    integer, save :: nnbas = 0
    ! number of nuclei in qm region
    integer, save :: qmnucs = 0
    ! nuclear charges
    real(dp), dimension(:,:), allocatable, save :: Zm
    ! nuclear coordinates
    real(dp), dimension(:,:), allocatable, save :: Rm


    ! frozen density fragment info
    ! ----------------------------

    ! number of frozen densities
    integer, public, save :: nfds = 0
    ! number of nuclei in current frozen density
    integer, public, save :: fdnucs = 0
    ! nuclear charges
    real(dp), dimension(:,:), allocatable, save :: Zfd
    ! nuclear coordinates
    real(dp), dimension(:,:), allocatable, save :: Rfd


    ! MEP stuff
    ! ---------
    ! number of grid points
    integer, dimension(:), allocatable, save :: npoints
    ! point distribution
    integer, dimension(:), save, allocatable :: nmepdists
    ! grid points
    real(dp), dimension(:,:), allocatable, save :: mepgrid

! TODO:
! electric field damping in iterative solver
! damping of electric field from QM system
! check for positive definiteness of the response matrix?
! write results after redistributing parameters
! better solution for lmul and lpol
! use allocate/deallocate where possible?
! insert quit if symmetry or QM3, QMMM etc.
! find better solution for electric field calculation from frozen densities
! higher order polarizabilities
! write list of publications which should be cited
! write output related to FDs
! remove double zeroing and unecessary zeroing
! nonlinear response properties
! magnetic properties
! cutoffs and damping
! memory management (dalton work, pointer, allocate)
! add error catching
! parallelization (openMP, MPI, CUDA/openCL?)

contains

!------------------------------------------------------------------------------

subroutine pe_dalton_input(word, luinp, lupri)

    character(len=7), intent(inout) :: word
    integer, intent(in) :: luinp
    integer, intent(in) :: lupri

    character(len=7) :: option
    character(len=2) :: aaorau

    luout = lupri

    do
        read(luinp,'(a7)') option
        call chcase(option)

        ! do a Polarizable Embedding calculation
        if (trim(option(2:)) == 'PEQM') then
            peqm = .true.
        ! iterative solver for induced dipoles
        else if (trim(option(2:)) == 'ITERAT') then
            read(luinp,*) option
            backspace(luinp)
            if (option(1:1) /= '.' .and. option(1:1) /= '*'&
               &.and. option(1:1) /= '!') then
                read(luinp,*) thriter
            end if
            pe_iter = .true.
        ! handling sites near quantum-classical border
        else if (trim(option(2:)) == 'BORDER') then
            read(luinp,*) option
            backspace(luinp)
            if (option(1:1) /= '.' .and. option(1:1) /= '*'&
               &.and. option(1:1) /= '!') then
                read(luinp,*) border_type, Rmin, aaorau
                call chcase(border_type)
                if (border_type /= 'REMOVE' .or. border_type /= 'REDIST') then
                    stop 'Error: unknown handling of border sites!'
                end if
                call chcase(aaorau)
                if (aaorau == 'AA') Rmin = Rmin * aa2au
            end if
            pe_border = .true.
        ! induced dipole - induced dipole damping
        else if (trim(option(2:)) == 'DAMP') then
            read(luinp,*) option
            backspace(luinp)
            if (option(1:1) /= '.' .and. option(1:1) /= '*'&
               &.and. option(1:1) /= '!') then
                read(luinp,*) damp
            end if
            pe_damp = .true.
        ! neglect dynamic response from environment
        else if (trim(option(2:)) == 'GSPOL') then
            pe_gspol = .true.
        ! neglect many-body interactions
        else if (trim(option(2:)) == 'NOMB') then
            pe_nomb = .true.
        ! use Gaussian broadened multipoles and FD nuclear charges
        else if (trim(option(2:)) == 'GAUSS') then
            read(luinp,*) option
            backspace(luinp)
            if (option(1:1) /= '.' .and. option(1:1) /= '*'&
               &.and. option(1:1) /= '!') then
                read(luinp,*) gauss
            end if
            pe_gauss = .true.
        ! calculate intermolecular two-electron integrals
        else if (trim(option(2:)) == 'TWOINT') then
            read(luinp,*) fdnucs
            pe_twoint = .true.
        ! save density matrix
        else if (trim(option(2:)) == 'SAVDEN') then
            pe_savden = .true.
        ! get fock matrix for repulsion potential
        else if (trim(option(2:)) == 'REPULS') then
            pe_repuls = .true.
        ! electrostatics from frozen densities
        else if (trim(option(2:)) == 'FD') then
            ! number of frozen densities
            read(luinp,*) nfds
            pe_fd = .true.
        ! evaluate molecular electrostatic potential 
        else if (trim(option(2:)) == 'MEP') then
            pe_mep = .true.
        else if (option(1:1) == '*') then
            word = option
            exit
        else if (option(1:1) == '!' .or. option(1:1) == '#') then
            cycle
        end if
    end do

    if (pe_mep .and. peqm) stop 'PEQM and MEP are not compatible'
    if (pe_nomb .and. pe_iter) stop 'NOMB and ITERATIVE are not compatible'
    if (peqm .and. pe_savden) stop 'PEQM and SAVDEN are not compatible'
    if (peqm .and. pe_twoint) stop 'PEQM and TWOINT are not compatible'

end subroutine pe_dalton_input

!------------------------------------------------------------------------------

subroutine pe_read_potential(coords, charges)

    real(dp), dimension(:), intent(in), optional :: charges
    real(dp), dimension(:,:), intent(in), optional :: coords

    integer :: i, j, k, s
    integer :: lupot, lumep, nlines
    integer :: nidx, idx, jdx, kdx, ldx
    integer, dimension(:), allocatable :: idxs
    real(dp) :: rclose
    real(dp), dimension(21) :: temp
    character(len=2) :: auoraa
    character(len=80) :: word
    logical :: lexist

#ifdef VAR_MPI
    call mpi_comm_rank(MPI_COMM_WORLD, myid, ierr)
    call mpi_comm_size(MPI_COMM_WORLD, ncores, ierr)
#else
    myid = 0
    ncores = 1
#endif

    allocate(nsites(-1:ncores-1))
    nsites = 0

    if (present(coords) .and. present(charges)) then
        qmnucs = size(charges)
        allocate(Rm(3,qmnucs), Zm(1,qmnucs))
        Rm = coords
        Zm(1,:) = charges
    else if (present(coords) .and. .not. present(charges)) then
        print *, 'ERROR: nuclear charges of the QM system are missing.'
        stop
    else if (.not. present(coords) .and. present(charges)) then
        print *, 'ERROR: nuclear coordinates of the QM system are missing.'
    end if

    if (pe_mep) then
        allocate(npoints(-1:ncores-1))
        npoints = 0
        inquire(file='MEP.INP', exist=lexist)
        if (lexist) then
            call openfile('MEP.INP', lumep, 'old', 'formatted')
        else
            stop 'MEP.INP not found!'
        end if
        read(lumep,*) npoints(0)
        read(lumep,*) auoraa
        allocate(mepgrid(3,npoints(0)))
        do i = 1, npoints(0)
            read(lumep,*) (mepgrid(j,i), j = 1, 3)
        end do
        close(lumep)
        if (auoraa == 'AA') then
            mepgrid  = mepgrid * aa2au
        end if
    end if

    inquire(file='POTENTIAL.INP', exist=lexist)
    if (lexist) then
        call openfile('POTENTIAL.INP', lupot, 'old', 'formatted')
    else
        if (pe_savden) then
            return
        else if (pe_fd) then
            goto 101
        else if (pe_mep) then
            goto 101
        else
            stop 'POTENTIAL.INP not found!'
        end if
    end if

    do
        read(lupot,*,end=100) word

        if (trim(word) == 'coordinates') then
            read(lupot,*) nsites(0)
            read(lupot,*) auoraa
            allocate(elems(1,nsites(0)), Zs(1,nsites(0)), Rs(3,nsites(0)))
            do i = 1, nsites(0)
                read(lupot,*) elems(1,i), (Rs(j,i), j = 1, 3)
                Zs(1,i) = elem2charge(elems(1,i))
            end do
        else if (trim(word) == 'monopoles') then
            lmul(0) = .true.
            if (mulorder < 0) mulorder = 0
            allocate(M0s(1,nsites(0)))
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, temp(1)
                M0s(1,s) = temp(1)
            end do
        else if (trim(word) == 'dipoles') then
            lmul(1) = .true.
            if (mulorder < 1) mulorder = 1
            allocate(M1s(3,nsites(0)))
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, (temp(j), j = 1, 3)
                M1s(:,s) = temp(1:3)
            end do
        else if (trim(word) == 'quadrupoles') then
            lmul(2) = .true.
            if (mulorder < 2) mulorder = 2
            allocate(M2s(6,nsites(0)))
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, (temp(j), j = 1, 6)
                M2s(:,s) = temp(1:6)
            end do
        else if (trim(word) == 'octopoles') then
            lmul(3) = .true.
            if (mulorder < 3) mulorder = 3
            allocate(M3s(10,nsites(0)))
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, (temp(j), j = 1, 10)
                M3s(:,s) = temp(1:10)
            end do
        else if (trim(word) == 'hexadecapoles') then
            lmul(4) = .true.
            if (mulorder < 4) mulorder = 4
            allocate(M4s(15,nsites(0)))
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, (temp(j), j = 1, 15)
                M4s(:,s) = temp(1:15)
            end do
        else if (trim(word) == 'ditriacontapoles') then
            lmul(5) = .true.
            if (mulorder < 5) mulorder = 5
            allocate(M5s(21,nsites(0)))
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, (temp(j), j = 1, 21)
                M5s(:,s) = temp(1:21)
            end do
        else if (trim(word) == 'isoalphas') then
            lpol(1) = .true.
            if (.not. allocated(P1s)) then
                allocate(P1s(6,nsites(0)))
                P1s = 0.0d0
            end if
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, temp(1)
                P1s(1,s) = temp(1)
                P1s(4,s) = temp(1)
                P1s(6,s) = temp(1)
            end do
        else if (trim(word) == 'alphas') then
            lpol(1) = .true.
            if (.not. allocated(P1s)) then
                allocate(P1s(6,nsites(0)))
                P1s = 0.0d0
            end if
            read(lupot,*) nlines
            do i = 1, nlines
                read(lupot,*) s, (temp(j), j = 1, 6)
                P1s(:,s) = temp(1:6)
            end do
        else if (trim(word) == 'exlists') then
            read(lupot,*) lexlst
            allocate(exlists(lexlst,nsites(0)))
            do i = 1, nsites(0)
                read(lupot,*) (exlists(j,i), j = 1, lexlst)
            end do
        else if (word(1:1) == '!' .or. word(1:1) == '#') then
            cycle
        end if
    end do

100 continue

    close(lupot)

    ! if coordinates are in AA then convert to AU
    if (auoraa == 'AA') then
        Rs = Rs * aa2au
    end if

101 write(luout,'(//2x,a)') 'Polarizable Embedding potential'
    write(luout,'(2x,a)')   '-------------------------------'
    if (nsites(0) > 0) then
        write(luout,'(/4x,a,i6)') 'Number of classical sites: ', nsites(0)
    end if
    if (mulorder == 5) then
        write(luout,'(4x,a)') 'Multipole moments upto 5th order.'
    else if (mulorder == 4) then
        write(luout,'(4x,a)') 'Multipole moments upto 4th order.'
    else if (mulorder == 3) then
        write(luout,'(4x,a)') 'Multipole moments upto 3rd order.'
    else if (mulorder == 2) then
        write(luout,'(4x,a)') 'Multipole moments upto 2nd order.'
    else if (mulorder == 1) then
        write(luout,'(4x,a)') 'Multipole moments upto 1st order.'
    else if (mulorder == 0) then
        write(luout,'(4x,a)') 'Multipole moments upto 0th order.'
    end if
    if (lpol(1)) then
        write(luout,'(4x,a)') '(An)isotropic dipole-dipole polarizabilities.'
        if (pe_damp) then
            write(luout,'(4x,a,f8.4)') 'Induced dipole-induced dipole&
                                       & interactions will be damped using&
                                       & damping coefficient:', damp
        end if
        if (pe_gspol) then
            write(luout,'(4x,a)') 'Dynamic response from environment will be&
                                  & neglected during response calculation.'
        end if
        if (pe_nomb) then
            write(luout,'(4x,a)') 'Many-body interactions will be neglected.'
        end if
        if (pe_iter) then
            write(luout,'(4x,a)') 'Iterative solver for induced dipoles will&
                                  & be used'
            write(luout,'(4x,a,es7.1)') 'with convergence threshold: ', thriter
        else
            write(luout,'(4x,a)') 'Direct solver for induced dipoles will be&
                                  & used.'
        end if
    end if
    if (pe_fd) then
        write(luout,'(4x,a,i4)') 'Number of frozen densities:', nfds
        if (pe_gauss) then
            write(luout,'(4x,a,f4.2)') 'Using Gaussian charges with broadening: ', gauss
        end if
    end if

   ! default exclusion list (everything polarizes everything)
    if (.not. allocated(exlists)) then
        lexlst = 1
        allocate(exlists(lexlst,nsites(0)))
        do i = 1, nsites(0)
            exlists(1,i) = i
        end do
    end if

    ! handling sites near quantum-classical border
    ! -----------------------------------------------
    if (pe_border) then
        ! first locate all sites within given threshold of QM nuclei
        allocate(idxs(nsites(0)))
        idxs = 0; nidx = 0
        do i = 1, qmnucs
            do j = 1, nsites(0)
                lexist = .false.
                do k = 1, nidx
                    if (j == idxs(k)) then
                        lexist = .true.
                        exit
                    end if
                end do
                if (lexist) cycle
                if (nrm2(Rm(:,i) - Rs(:,j)) <= Rmin) then
                    nidx = nidx + 1
                    idxs(nidx) = j
                end if
            end do
        end do

        if (border_type == 'REMOVE') then
            do i = 1, nidx
                write(luout,'(4x,a,i6,a)') 'Removing parameters on site:',&
                                           & idxs(i), elems(1,idxs(i))
                if (lmul(0)) then
                    M0s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(1)) then
                    M1s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(2)) then
                    M2s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(3)) then
                    M3s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(4)) then
                    M4s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(5)) then
                    M5s(:,idxs(i)) = 0.0d0
                endif
                if (lpol(1)) then
                    P1s(:,idxs(i)) = 0.0d0
                end if
            end do
        else if (border_type == 'REDIST') then
            do i = 1, nidx
                rclose = 1.0d10
                do j = 1, nsites(0)
                    lexist = .false.
                    do k = 1, nidx
                        if (j == idxs(k)) then
                            lexist = .true.
                            exit
                        end if
                    end do
                    if (lexist) cycle
                    if (nrm2(Rs(:,idxs(i)) - Rs(:,j)) <= rclose) then
                        rclose = nrm2(Rs(:,idxs(i)) - Rs(:,j))
                        idx = j
                    end if
                end do
                if (lmul(0)) then
                    M0s(:,idx) = M0s(:,idx) + M0s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(1)) then
                    M1s(:,idx) = M1s(:,idx) + M1s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(2)) then
                    M2s(:,idx) = M2s(:,idx) + M2s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(3)) then
                    M3s(:,idx) = M3s(:,idx) + M3s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(4)) then
                    M4s(:,idx) = M4s(:,idx) + M4s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(5)) then
                    M5s(:,idx) = M5s(:,idx) + M5s(:,idxs(i)) / 3.0d0
                endif
                if (lpol(1)) then
                    P1s(:,idx) = P1s(:,idx) + P1s(:,idxs(i)) / 3.0d0
                end if

                rclose = 1.0d10
                do j = 1, nsites(0)
                    if (j == idx) cycle
                    lexist = .false.
                    do k = 1, nidx
                        if (j == idxs(k)) then
                            lexist = .true.
                            exit
                        end if
                    end do
                    if (lexist) cycle
                    if (nrm2(Rs(:,idxs(i)) - Rs(:,j)) <= rclose) then
                        rclose = nrm2(Rs(:,idxs(i)) - Rs(:,j))
                        jdx = j
                    end if
                end do
                if (lmul(0)) then
                    M0s(:,jdx) = M0s(:,jdx) + M0s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(1)) then
                    M1s(:,jdx) = M1s(:,jdx) + M1s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(2)) then
                    M2s(:,jdx) = M2s(:,jdx) + M2s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(3)) then
                    M3s(:,jdx) = M3s(:,jdx) + M3s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(4)) then
                    M4s(:,jdx) = M4s(:,jdx) + M4s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(5)) then
                    M5s(:,jdx) = M5s(:,jdx) + M5s(:,idxs(i)) / 3.0d0
                endif
                if (lpol(1)) then
                    P1s(:,jdx) = P1s(:,jdx) + P1s(:,idxs(i)) / 3.0d0
                end if

                rclose = 1.0d10
                do j = 1, nsites(0)
                    if (j == idx .or. j == jdx) cycle
                    lexist = .false.
                    do k = 1, nidx
                        if (j == idxs(k)) then
                            lexist = .true.
                            exit
                        end if
                    end do
                    if (lexist) cycle
                    if (nrm2(Rs(:,idxs(i)) - Rs(:,j)) <= rclose) then
                        rclose = nrm2(Rs(:,idxs(i)) - Rs(:,j))
                        kdx = j
                    end if
                end do
                if (lmul(0)) then
                    M0s(:,kdx) = M0s(:,kdx) + M0s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(1)) then
                    M1s(:,kdx) = M1s(:,kdx) + M1s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(2)) then
                    M2s(:,kdx) = M2s(:,kdx) + M2s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(3)) then
                    M3s(:,kdx) = M3s(:,kdx) + M3s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(4)) then
                    M4s(:,kdx) = M4s(:,kdx) + M4s(:,idxs(i)) / 3.0d0
                endif
                if (lmul(5)) then
                    M5s(:,kdx) = M5s(:,kdx) + M5s(:,idxs(i)) / 3.0d0
                endif
                if (lpol(1)) then
                    P1s(:,kdx) = P1s(:,kdx) + P1s(:,idxs(i)) / 3.0d0
                end if

                if (lmul(0)) then
                    M0s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(1)) then
                    M1s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(2)) then
                    M2s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(3)) then
                    M3s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(4)) then
                    M4s(:,idxs(i)) = 0.0d0
                endif
                if (lmul(5)) then
                    M5s(:,idxs(i)) = 0.0d0
                endif
                if (lpol(1)) then
                    P1s(:,idxs(i)) = 0.0d0
                end if

                write(luout,'(4x,a,i6)') 'Redistributing parameters on site:', idxs(i)
                write(luout,'(6x,a,3i6)') 'to neighbouring sites:', idx, jdx, kdx
            end do
        end if
    end if

    ! number of polarizabilities different from zero
    if (lpol(1)) then
        allocate(zeroalphas(nsites(0)))
        do i = 1, nsites(0)
            if (abs(maxval(P1s(:,i))) <= zero) then
                zeroalphas(i) = .true.
            else
                zeroalphas(i) = .false.
                npols = npols + 1
            end if
        end do
    end if
    print *, npols

end subroutine pe_read_potential

!------------------------------------------------------------------------------

subroutine pe_master(runtype, denmats, fckmats, nmats, Epe, dalwrk)

    character(*), intent(in) :: runtype
    integer, intent(in) :: nmats
    real(dp), dimension(:), intent(in) :: denmats
    real(dp), dimension(:), intent(out), optional :: fckmats
    real(dp), dimension(:), intent(out), optional :: Epe
    real(dp), dimension(:), target, intent(inout) :: dalwrk

#ifdef VAR_MPI
    call mpi_comm_rank(MPI_COMM_WORLD, myid, ierr)
    call mpi_comm_size(MPI_COMM_WORLD, ncores, ierr)
#else
    myid = 0
    ncores = 1
#endif

    work => dalwrk

    ! determine what to calculate and do consistency check
    if (runtype == 'fock') then
        fock = .true.
        energy = .false.
        response = .false.
        mep = .false.
        scfcycle = scfcycle + 1
        if (.not. present(fckmats)) then
            stop 'Output matrices are missing from input!'
        else if (.not. present(Epe)) then
            stop 'The energy variable is missing from input!'
        end if
    else if (runtype == 'energy') then
        fock = .false.
        energy = .true.
        response = .false.
        mep = .false.
    else if (runtype == 'response') then
        if (pe_gspol) return
        if (npols < 1) return
        if (.not. lpol(1)) return
        fock = .false.
        energy = .false.
        response = .true.
        mep = .false.
        if (.not. present(fckmats)) then
            stop 'Output matrices are missing from input!'
        end if
    else if (runtype == 'mep') then
        fock = .false.
        energy = .false.
        response = .false.
        mep = .true.
    else
        stop 'Could not determine calculation type.'
    end if

    ndens = nmats
    nnbas = size(denmats) / ndens

#ifdef VAR_MPI
    if (myid == 0 .and. ncores > 1) then
        call mpi_bcast(44, 1, MPI_INTEGER, myid, MPI_COMM_WORLD, ierr)
        if (fock) then
            call mpi_bcast(1, 1, MPI_INTEGER, myid, MPI_COMM_WORLD, ierr)
        else if (energy) then
            call mpi_bcast(2, 1, MPI_INTEGER, myid, MPI_COMM_WORLD, ierr)
        else if (response) then
            call mpi_bcast(3, 1, MPI_INTEGER, myid, MPI_COMM_WORLD, ierr)
        else if (mep) then
            call mpi_bcast(4, 1, MPI_INTEGER, myid, MPI_COMM_WORLD, ierr)
        end if

        call mpi_bcast(nnbas, 1, MPI_INTEGER, myid, MPI_COMM_WORLD, ierr)
        call mpi_bcast(ndens, 1, MPI_INTEGER, myid, MPI_COMM_WORLD, ierr)
        call mpi_bcast(denmats, nnbas*ndens, MPI_REAL8,&
                      &myid, MPI_COMM_WORLD, ierr)

        if (.not. initialized) then
            call pe_sync()
        end if
    end if
#endif

    if (fock) then
        call pe_fock(denmats, fckmats, Epe)
    else if (energy) then
        call pe_fock(denmats)
    else if (response) then
        call pe_polarization(denmats, fckmats)
    else if (mep) then
        if (ndens > 1) stop 'Not implemented for more than 1 density matrix'
        call pe_compmep(denmats)
    end if

#ifdef VAR_MPI
    if (myid == 0 .and. ncores > 1) then
        if (fock .or. response) then
            call mpi_reduce(MPI_IN_PLACE, fckmats, ndens*nnbas, MPI_REAL8,&
                           &MPI_SUM, 0, MPI_COMM_WORLD, ierr)
        end if
    end if
#endif

    nullify(work)

end subroutine pe_master

!------------------------------------------------------------------------------

#ifdef VAR_MPI
subroutine pe_mpi(dalwrk, runtype)

    real(dp), dimension(:), target, intent(inout) :: dalwrk
    integer :: runtype

    integer :: i
    integer :: nwrk

    call mpi_comm_rank(MPI_COMM_WORLD, myid, ierr)
    call mpi_comm_size(MPI_COMM_WORLD, ncores, ierr)

    work => dalwrk

    nwrk = size(work)

    if (runtype == 1) then
        fock = .true.
        energy = .false.
        response = .false.
        mep = .false.
    else if (runtype == 2) then
        fock = .false.
        energy = .true.
        response = .false.
        mep = .false.
    else if (runtype == 3) then
        fock = .false.
        energy = .false.
        response = .true.
        mep = .false.
    else if (runtype == 4) then
        fock = .false.
        energy = .false.
        response = .false.
        mep = .true.
    end if

    call mpi_bcast(nnbas, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
    call mpi_bcast(ndens, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
    call mpi_bcast(work(1), nnbas*ndens, MPI_REAL8, 0, MPI_COMM_WORLD, ierr)

    if (.not. initialized) then
        call pe_sync()
    end if

    if (fock) then
        call pe_fock(work(1:ndens*nnbas), work(ndens*nnbas+1:2*ndens*nnbas),&
                    &work(2*ndens*nnbas+1:2*ndens*nnbas+ndens))
    else if (energy) then
        call pe_fock(work(1:ndens*nnbas))
    else if (response) then
        call pe_polarization(work(1:ndens*nnbas),&
                            &work(ndens*nnbas+1:2*ndens*nnbas))
    else if (mep) then
        call pe_compmep(work(1:ndens*nnbas))
    end if

    if (fock .or. response) then
        call mpi_reduce(work(ndens*nnbas+1), 0, ndens*nnbas, MPI_REAL8,&
                       &MPI_SUM, 0, MPI_COMM_WORLD, ierr)
    end if

    nullify(work)

end subroutine pe_mpi

!------------------------------------------------------------------------------

subroutine pe_sync()

    integer :: i
    integer :: ndist, nrest

    allocate(ndists(0:ncores-1))

    if (myid == 0) then
        ndist = nsites(0) / ncores
        ndists = ndist
        if (ncores * ndist < nsites(0)) then
            nrest = nsites(0) - ncores * ndist
            do i = 0, nrest-1
                ndists(i) = ndists(i) + 1
            end do
        end if
        do i = 1, ncores-1
            nsites(i) = sum(ndists(0:i))
        end do
        nsites(0) = ndists(0)
    else if (myid /= 0) then
        allocate(nsites(-1:ncores-1))
    end if

    call mpi_bcast(ndists, ncores, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
    call mpi_bcast(nsites, ncores+1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)

    call mpi_bcast(qmnucs, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)

    if (myid /= 0) allocate(Zm(1,qmnucs))
    call mpi_bcast(Zm, qmnucs, MPI_REAL8, 0, MPI_COMM_WORLD, ierr)

    if (myid /= 0) allocate(Rm(3,qmnucs))
    call mpi_bcast(Rm, 3*qmnucs, MPI_REAL8, 0, MPI_COMM_WORLD, ierr)

    if (myid == 0) then
        allocate(displs(0:ncores-1))
        displs(0) = 0
        do i = 1, ncores-1
            displs(i) = displs(i-1) + 3 * ndists(i-1)
        end do
    else if (myid /= 0) then
        allocate(Rs(3,sum(ndists)))
    end if

    call mpi_bcast(Rs, 3*nsites(ncores-1), MPI_REAL8, 0, MPI_COMM_WORLD, ierr)

    call mpi_bcast(lpol, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)

    if (lpol(1)) then
        allocate(npoldists(0:ncores-1))
        if (myid == 0) then
            ndist = npols / ncores
            npoldists = ndist
            if (ncores * ndist < npols) then
                nrest = npols - ncores * ndist
                do i = 0, nrest-1
                    npoldists(i) = npoldists(i) + 1
                end do
            end if
        end if
        call mpi_bcast(npoldists, ncores, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
        call mpi_bcast(npols, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
        call mpi_bcast(lexlst, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
        if (myid /= 0) allocate(exlists(lexlst,nsites(ncores-1)))
        call mpi_bcast(exlists, lexlst*nsites(ncores-1), MPI_INTEGER,& 
                      &0, MPI_COMM_WORLD, ierr)
        if (myid /= 0) allocate(zeroalphas(nsites(ncores-1)))
        call mpi_bcast(zeroalphas, nsites(ncores-1), MPI_LOGICAL,&
                      &0, MPI_COMM_WORLD, ierr)
        call mpi_bcast(pe_nomb, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
        call mpi_bcast(pe_iter, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
        call mpi_bcast(pe_damp, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
        call mpi_bcast(damp, 1, MPI_REAL8, 0, MPI_COMM_WORLD, ierr)
        if (pe_iter) then
            if (myid /= 0) allocate(P1s(6,nsites(ncores-1)))
            call mpi_bcast(P1s, 6*nsites(ncores-1), MPI_REAL8,&
                          &0, MPI_COMM_WORLD, ierr)
        end if
    end if

    call mpi_bcast(mulorder, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
    call mpi_bcast(lmul, 6, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)

    if (lmul(0)) then
        if (myid == 0) then
            displs(0) = 0
            do i = 1, ncores-1
                displs(i) = displs(i-1) + ndists(i-1)
            end do
            call mpi_scatterv(M0s, ndists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            allocate(M0s(1,ndists(myid)))
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &M0s, ndists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        end if
    end if

    if (lmul(1)) then
        if (myid == 0) then
            displs(0) = 0
            do i = 1, ncores-1
                displs(i) = displs(i-1) + 3 * ndists(i-1)
            end do
            call mpi_scatterv(M1s, 3*ndists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            allocate(M1s(3,ndists(myid)))
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &M1s, 3*ndists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        end if
    end if

    if (lmul(2)) then
        if (myid == 0) then
            displs(0) = 0
            do i = 1, ncores-1
                displs(i) = displs(i-1) + 6 * ndists(i-1)
            end do
            call mpi_scatterv(M2s, 6*ndists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            allocate(M2s(6,ndists(myid)))
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &M2s, 6*ndists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        end if
    end if

    if (lmul(3)) then
        if (myid == 0) then
            displs(0) = 0
            do i = 1, ncores-1
                displs(i) = displs(i-1) + 10 * ndists(i-1)
            end do
            call mpi_scatterv(M3s, 10*ndists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            allocate(M3s(10,ndists(myid)))
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &M3s, 10*ndists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        end if
    end if

    if (lmul(4)) then
        if (myid == 0) then
            displs(0) = 0
            do i = 1, ncores-1
                displs(i) = displs(i-1) + 15 * ndists(i-1)
            end do
            call mpi_scatterv(M4s, 15*ndists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            allocate(M4s(15,ndists(myid)))
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &M4s, 15*ndists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        end if
    end if

    if (lmul(5)) then
        if (myid == 0) then
            displs(0) = 0
            do i = 1, ncores-1
                displs(i) = displs(i-1) + 21 * ndists(i-1)
            end do
            call mpi_scatterv(M5s, 21*ndists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            allocate(M5s(21,ndists(myid)))
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &M5s, 21*ndists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        end if
    end if

     if (mep) then
        allocate(nmepdists(0:ncores-1))
        if (myid == 0) then
            ndist = npoints(0) / ncores
            nmepdists = ndist
            if (ncores * ndist < npoints(0)) then
                nrest = npoints(0) - ncores * ndist
                do i = 0, nrest-1
                    nmepdists(i) = nmepdists(i) + 1
                end do
            end if
            do i = 1, ncores-1
                npoints(i) = sum(nmepdists(0:i))
            end do
            npoints(0) = nmepdists(0)
        else if (myid /= 0) then
            allocate(npoints(-1:ncores-1))
        end if
        call mpi_bcast(nmepdists, ncores, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
        call mpi_bcast(npoints, ncores+1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
        if (myid == 0) then
            displs(0) = 0
            do i = 1, ncores-1
                displs(i) = displs(i-1) + 3 * nmepdists(i-1)
            end do
            call mpi_scatterv(mepgrid, 3*nmepdists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            allocate(mepgrid(3,nmepdists(myid)))
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &mepgrid, 3*nmepdists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)

        end if
    end if

   initialized = .true.

end subroutine pe_sync
#endif

!------------------------------------------------------------------------------

subroutine pe_compmep(denmats)

    real(dp), dimension(:), intent(in) :: denmats

    integer :: lu
    integer :: point
    integer :: i, j, k
    integer :: ndist, nrest
    real(dp), dimension(3) :: Tm
    real(dp), dimension(:,:), allocatable :: Vs, Fs
    real(dp), dimension(nnbas,3) :: Tk_ints

    allocate(Vs(1,npoints(ncores-1)), Fs(3,npoints(ncores-1)))

    i = 1
    do point = npoints(myid-1)+1, npoints(myid)
#ifdef BUILD_GEN1INT
        call Tk_integrals(Tk_ints(:,1), nnbas, 1, mepgrid(:,i), .false., 0.0d0)
#else
        call Tk_integrals(Tk_ints(:,1), nnbas, 1, mepgrid(:,i),&
                         &work, size(work))
#endif

        Vs(1,i) = dot(denmats, Tk_ints(:,1))

        do j = 1, qmnucs
            call Tk_tensor(Tm(1:1), mepgrid(:,i) - Rm(:,j))
            Vs(1,i) = Vs(1,i) + Zm(1,j) * Tm(1)
        end do

#ifdef BUILD_GEN1INT
        call Tk_integrals(Tk_ints, nnbas, 3, mepgrid(:,i), .false., 0.0d0)
#else
        call Tk_integrals(Tk_ints, nnbas, 3, mepgrid(:,i), work, size(work))
#endif

        do j = 1, 3
            Fs(j,i) = dot(denmats, Tk_ints(:,j))
        end do

        do j = 1, qmnucs
            call Tk_tensor(Tm, mepgrid(:,i) - Rm(:,j))
            do k = 1, 3
                Fs(k,i) = Fs(k,i) - Zm(1,j) * Tm(k)
            end do
        end do
        i = i + 1
    end do

#ifdef VAR_MPI
    if (myid == 0 .and. ncores > 1) then
        displs(0) = 0
        do i = 1, ncores-1
            displs(i) = displs(i-1) + 3 * nmepdists(i-1)
        end do
        call mpi_gatherv(MPI_IN_PLACE, 0, MPI_REAL8,&
                        &Fs, 3*nmepdists, displs, MPI_REAL8,&
                        &0, MPI_COMM_WORLD, ierr)
        displs(0) = 0
        do i = 1, ncores-1
            displs(i) = displs(i-1) + nmepdists(i-1)
        end do
        call mpi_gatherv(MPI_IN_PLACE, 0, MPI_REAL8,&
                        &Vs, nmepdists, displs, MPI_REAL8,&
                        &0, MPI_COMM_WORLD, ierr)
    else if (myid /= 0) then
        call mpi_gatherv(Fs, 3*nmepdists(myid), MPI_REAL8,&
                        &0, 0, 0, MPI_REAL8,&
                        &0, MPI_COMM_WORLD, ierr)
        call mpi_gatherv(Vs, nmepdists(myid), MPI_REAL8,&
                        &0, 0, 0, MPI_REAL8,&
                        &0, MPI_COMM_WORLD, ierr)
    end if
#endif

    if (myid == 0) then
        call openfile('qm_mep.dat', lu, 'new', 'formatted')
        rewind(lu)
        write(lu,'(i7)') npoints(ncores-1)
        write(lu,'(a)') 'AU'
        do i = 1, npoints(ncores-1)
            write(lu,'(7(f15.8,2x))') (mepgrid(j,i), j = 1, 3),&
                                      & Vs(1,i), (Fs(j,i), j = 1, 3)
        end do
        close(lu)
    end if

end subroutine pe_compmep

!------------------------------------------------------------------------------

subroutine pe_fock(denmats, fckmats, Epe)

    real(dp), dimension(:), intent(in) :: denmats
    real(dp), dimension(:), intent(out), optional :: fckmats
    real(dp), dimension(:), intent(out), optional :: Epe

    integer :: i
    logical :: es = .false.
    logical :: pol = .false.

    if ((mulorder >= 0) .or. pe_fd) es = .true.
    if (lpol(1)) pol = .true.

    if (allocated(Ees)) deallocate(Ees)
    if (allocated(Epol)) deallocate(Epol)
    allocate(Ees(0:6,ndens))
    allocate(Epol(4,ndens))
    Ees = 0.0d0
    Epol = 0.0d0

    if (fock) fckmats = 0.0d0

    if (fock) then
        if (es) call pe_electrostatic(denmats, fckmats)
        if (pol) call pe_polarization(denmats, fckmats)
    else if (energy) then
        if (es) call pe_electrostatic(denmats)
        if (pol) call pe_polarization(denmats)
    end if

    if (fock) then
        Epe = 0.0d0
        do i = 1, ndens
            Epe(i) = sum(Ees(:,i)) + sum(Epol(:,i))
        end do
    end if

end subroutine pe_fock

!------------------------------------------------------------------------------

subroutine pe_electrostatic(denmats, fckmats)

    real(dp), dimension(:), intent(in) :: denmats
    real(dp), dimension(:), intent(inout), optional :: fckmats

    logical :: lexist
    integer :: lu
    integer :: i, j, k
    real(dp) :: Enuc, Esave
    real(dp), dimension(ndens) :: Eel
    real(dp), dimension(:), allocatable :: tmpfcks

    if (myid == 0) then
        inquire(file='pe_electrostatics.bin', exist=lexist)
    end if

#ifdef VAR_MPI
    if (ncores > 1) then
        call mpi_bcast(lexist, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
    end if
#endif

    if (lexist .and. fock) then
        if (myid == 0) then
            call openfile('pe_electrostatics.bin', lu, 'old', 'unformatted')
            rewind(lu)
            read(lu) Esave, fckmats
            close(lu)
            do i = 1, ndens
                j = (i - 1) * nnbas + 1
                k = i * nnbas
                Ees(0,i) = Ees(0,i) + dot(denmats(j:k), fckmats(j:k)) + Esave
            end do
        end if
    else
        Esave = 0.0d0
        if (lmul(0)) then
            if (fock) then
                call es_multipoles(M0s, denmats, Eel, Enuc, fckmats)
            else if (energy) then
                call es_multipoles(M0s, denmats, Eel, Enuc)
            end if
            do i = 1, ndens
                Ees(0,i) = Ees(0,i) + Eel(i) + Enuc
            end do
            Esave = Esave + Enuc
        end if
        if (lmul(1)) then
            if (fock) then
                call es_multipoles(M1s, denmats, Eel, Enuc, fckmats)
            else if (energy) then
                call es_multipoles(M1s, denmats, Eel, Enuc)
            end if
            do i = 1, ndens
                Ees(1,i) = Ees(1,i) + Eel(i) + Enuc
            end do
            Esave = Esave + Enuc
        end if
        if (lmul(2)) then
            if (fock) then
                call es_multipoles(M2s, denmats, Eel, Enuc, fckmats)
            else if (energy) then
                call es_multipoles(M2s, denmats, Eel, Enuc)
            end if
            do i = 1, ndens
                Ees(2,i) = Ees(2,i) + Eel(i) + Enuc
            end do
            Esave = Esave + Enuc
        end if
        if (lmul(3)) then
            if (fock) then
                call es_multipoles(M3s, denmats, Eel, Enuc, fckmats)
            else if (energy) then
                call es_multipoles(M3s, denmats, Eel, Enuc)
            end if
            do i = 1, ndens
                Ees(3,i) = Ees(3,i) + Eel(i) + Enuc
            end do
            Esave = Esave + Enuc
        end if
        if (lmul(4)) then
            if (fock) then
                call es_multipoles(M4s, denmats, Eel, Enuc, fckmats)
            else if (energy) then
                call es_multipoles(M4s, denmats, Eel, Enuc)
            end if
            do i = 1, ndens
                Ees(4,i) = Ees(4,i) + Eel(i) + Enuc
            end do
            Esave = Esave + Enuc
        end if
        if (lmul(5)) then
            if (fock) then
                call es_multipoles(M5s, denmats, Eel, Enuc, fckmats)
            else if (energy) then
                call es_multipoles(M5s, denmats, Eel, Enuc)
            end if
            do i = 1, ndens
                Ees(5,i) = Ees(5,i) + Eel(i) + Enuc
            end do
            Esave = Esave + Enuc
        end if
        if (myid == 0) then
            if (pe_fd) then
                if (fock) then
                    call es_frozen_densities(denmats, Eel, Enuc, fckmats)
                else if (energy) then
                    call es_frozen_densities(denmats, Eel, Enuc)
                end if
                do i = 1, ndens
                    Ees(6,i) = Ees(6,i) + Eel(i) + Enuc
                end do
                Esave = Esave + Enuc
            end if
        end if
        if (fock) then
#ifdef VAR_MPI
            if (myid == 0 .and. ncores > 1) then
                allocate(tmpfcks(ndens*nnbas))
                tmpfcks = fckmats
                call mpi_reduce(MPI_IN_PLACE, fckmats, ndens*nnbas, MPI_REAL8,&
                               &MPI_SUM, 0, MPI_COMM_WORLD, ierr)
                call mpi_reduce(MPI_IN_PLACE, Esave, 1, MPI_REAL8, MPI_SUM,&
                               &0, MPI_COMM_WORLD, ierr)
            else if (myid /= 0) then
                call mpi_reduce(fckmats, 0, ndens*nnbas, MPI_REAL8, MPI_SUM,&
                               &0, MPI_COMM_WORLD, ierr)
                call mpi_reduce(Esave, 0, 1, MPI_REAL8, MPI_SUM,&
                               &0, MPI_COMM_WORLD, ierr)
            end if
#endif
            if (myid == 0) then
                call openfile('pe_electrostatics.bin', lu, 'new', 'unformatted')
                rewind(lu)
                write(lu) Esave, fckmats
                close(lu)
            end if
            if (myid == 0 .and. ncores > 1) then
                fckmats = tmpfcks
                deallocate(tmpfcks)
            end if
        end if
#ifdef VAR_MPI
        if (myid == 0 .and. ncores > 1) then
            call mpi_reduce(MPI_IN_PLACE, Ees, 7*ndens, MPI_REAL8, MPI_SUM,&
                           &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            call mpi_reduce(Ees, 0, 7*ndens, MPI_REAL8, MPI_SUM,&
                           &0, MPI_COMM_WORLD, ierr)
        end if
#endif
    end if

end subroutine pe_electrostatic

!------------------------------------------------------------------------------

subroutine es_frozen_densities(denmats, Eel, Enuc, fckmats)

    real(dp), dimension(:), intent(in) :: denmats
    real(dp), dimension(:), intent(out) :: Eel
    real(dp), intent(out) :: Enuc
    real(dp), dimension(:), intent(inout), optional :: fckmats

    integer :: i, j, k, l, m, n, o
    integer :: lufck, lexist, lu
    real(dp) :: Ene, Enn
    real(dp) :: R
    real(dp), dimension(ndens) :: Een, Eee
    real(dp), dimension(1) :: Tfm
    real(dp), dimension(3) :: Rfm
    real(dp), dimension(3*npols) :: temp
    real(dp), dimension(nnbas) :: fd_fock
    real(dp), dimension(nnbas,1) :: Zfd_ints
    character(len=99) :: ci
    character(len=99) :: filename

    Eel = 0.0d0; Enuc = 0.0d0

    do i = 1, nfds
        Eee = 0.0d0; Een = 0.0d0; Ene = 0.0d0; Enn = 0.0d0
        write(ci,*) i
        ci = adjustl(ci)
        filename = 'pe_fock_'//trim(ci)//'.bin'
        call openfile(trim(filename), lufck, 'old', 'unformatted')
        rewind(lufck)
        read(lufck) temp
        read(lufck) Ene
        read(lufck) fd_fock
        read(lufck) fdnucs
        allocate(Rfd(3,fdnucs), Zfd(1,fdnucs))
        read(lufck) Rfd, Zfd
!        read(lufck) gauss
        close(lufck)

!        print *, 'gauss: ', gauss

        do j = 1, ndens
            l = (j - 1) * nnbas + 1
            m = j * nnbas
            if (fock) fckmats(l:m) = fckmats(l:m) + fd_fock
            Eee(j) = dot(denmats(l:m), fd_fock)
        end do

        do j = 1, fdnucs
            R = 1.0d6
            do k = 1, qmnucs
                Rfm = Rm(:,k) - Rfd(:,j)
                if (R > nrm2(Rfm)) R = nrm2(Rfm)
                call Tk_tensor(Tfm, Rfm)
                Enn = Enn + Zm(1,k) * Zfd(1,j) * Tfm(1)
            end do
#ifdef BUILD_GEN1INT
            call Tk_integrals(Zfd_ints, nnbas, 1, Rfd(:,j), pe_gauss, gauss) 
#else
            call Tk_integrals(Zfd_ints, nnbas, 1, Rfd(:,j), work, size(work))
#endif
            Zfd_ints = Zfd(1,j) * Zfd_ints
!            call Mk_integrals(Zfd_ints, Rfd(:,j), Zfd(:,j))
            do m = 1, ndens
                n = (m - 1) * nnbas + 1
                o = m * nnbas
                Een(m) = Een(m) + dot(denmats(n:o), Zfd_ints(:,1))
                if (fock) fckmats(n:o) = fckmats(n:o) + Zfd_ints(:,1)
            end do
        end do

        deallocate(Rfd, Zfd)

        Enuc = Enuc + Ene + Enn
        do j = 1, ndens
            Eel(j) = Eel(j) + Een(j) + Eee(j)
        end do
    end do

end subroutine es_frozen_densities

!------------------------------------------------------------------------------

subroutine es_multipoles(Mks, denmats, Eel, Enuc, fckmats)

    real(dp), dimension(:,:), intent(in) :: Mks
    real(dp), dimension(:), intent(in) :: denmats
    real(dp), dimension(:), intent(inout), optional :: fckmats
    real(dp), dimension(:), intent(out) :: Eel
    real(dp), intent(out) :: Enuc

    integer :: site, ncomps
    integer :: i, j, k, l, m, n
    real(dp) :: taylor
    real(dp), dimension(3) :: Rsm
    real(dp), dimension(:), allocatable :: Tsm, symfacs
    real(dp), dimension(:,:), allocatable :: Mk_ints

    ncomps = size(Mks,1)

    k = int(0.5d0 * (sqrt(1.0d0 + 8.0d0 * ncomps) - 1.0d0)) - 1

    if (mod(k,2) == 0) then
        taylor = 1.0d0 / factorial(k)
    else if (mod(k,2) /= 0) then
        taylor = - 1.0d0 / factorial(k)
    end if

    allocate(Tsm(ncomps))
    allocate(symfacs(ncomps))
    allocate(Mk_ints(nnbas,ncomps))

    Eel = 0.0d0; Enuc = 0.0d0

    i = 1
    do site = nsites(myid-1)+1, nsites(myid)
        if (abs(maxval(Mks(:,i))) < zero) then
            i = i + 1
            cycle
        end if

        ! nuclei - multipole interaction energy
        do j = 1, qmnucs
            Rsm = Rm(:,j) - Rs(:,site)
            call Tk_tensor(Tsm, Rsm)
            call symmetry_factors(symfacs)
            do l = 1, ncomps
                Enuc = Enuc + taylor * symfacs(l) * Zm(1,j) * Mks(l,i) * Tsm(l)
            end do
        end do

        ! electron - multipole interaction energy
        call Mk_integrals(Mk_ints, Rs(:,site), Mks(:,i))
        do j = 1, ncomps
            do l = 1, ndens
                m = (l - 1) * nnbas + 1
                n = l * nnbas
                Eel(l) = Eel(l) + dot(denmats(m:n), Mk_ints(:,j))
                if (fock) fckmats(m:n) = fckmats(m:n) + Mk_ints(:,j)
            end do
        end do
        i = i + 1
    end do

end subroutine es_multipoles

!------------------------------------------------------------------------------

subroutine pe_polarization(denmats, fckmats)

    external :: Tk_integrals

    real(dp), dimension(:), intent(in) :: denmats
    real(dp), dimension(:), intent(inout), optional :: fckmats

    integer :: site, ndist, nrest
    integer :: i, j, k, l, m
    logical :: skip
    real(dp), dimension(3*npols) :: Fnucs, Fmuls, Ffd
    real(dp), dimension(3*npols,ndens) :: M1inds, Fels, Ftots
    real(dp), dimension(:,:), allocatable :: Fel_ints

    if (response) fckmats = 0.0d0

    if (response) then
        call electron_fields(Fels, denmats)
        call induced_dipoles(M1inds, Fels)
    else
        call electron_fields(Fels, denmats)
        call nuclear_fields(Fnucs)
        call multipole_fields(Fmuls)
        if (myid == 0) then
            if (pe_fd) then
                call frozen_density_field(Ffd)
            else
                Ffd = 0.0d0
            end if
            do i = 1, ndens
                Ftots(:,i) = Fels(:,i) + Fnucs + Fmuls + Ffd
            end do
        end if
        call induced_dipoles(M1inds, Ftots)
        if (myid == 0) then
            do i = 1, ndens
                Epol(1,i) = - 0.5d0 * dot(M1inds(:,i), Fels(:,i))
                Epol(2,i) = - 0.5d0 * dot(M1inds(:,i), Fnucs)
                Epol(3,i) = - 0.5d0 * dot(M1inds(:,i), Fmuls)
                if (pe_fd) Epol(4,i) = - 0.5d0 * dot(M1inds(:,i), Ffd)
            end do
        end if
    end if

#ifdef VAR_MPI
    if (myid == 0 .and. ncores > 1) then
        do i = 1, ndens
            call mpi_scatterv(M1inds(:,i), 3*npoldists, displs, MPI_REAL8,&
                             &MPI_IN_PLACE, 0, MPI_REAL8,&
                             &myid, MPI_COMM_WORLD, ierr)
        end do
    else if (myid /= 0) then
        do i = 1, ndens
            call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                             &M1inds(:,i), 3*npoldists(myid), MPI_REAL8,&
                             &0, MPI_COMM_WORLD, ierr)
        end do
    end if
#endif

    if (fock .or. response) then
        allocate(Fel_ints(nnbas,3))
        i = 0
        do site = nsites(myid-1)+1, nsites(myid)
            if (zeroalphas(site)) cycle
#ifdef BUILD_GEN1INT
            call Tk_integrals(Fel_ints, nnbas, 3, Rs(:,site), .false., 0.0d0)
#else
            call Tk_integrals(Fel_ints, nnbas, 3, Rs(:,site), work, size(work))
#endif
            do j = 1, 3
                do k = 1, ndens
                    l = (k - 1) * nnbas + 1
                    m = k * nnbas
                    fckmats(l:m) = fckmats(l:m) - M1inds(i+j,k) * Fel_ints(:,j)
                end do
            end do
            i = i + 3
        end do
    end if

end subroutine pe_polarization

!------------------------------------------------------------------------------

subroutine induced_dipoles(M1inds, Fs)

    real(dp), dimension(:,:), intent(out) :: M1inds
    real(dp), dimension(:,:), intent(in) :: Fs

    integer :: lu, iter, info
    integer :: i, j, k, l, m, n
    integer, dimension(:), allocatable :: ipiv
    logical :: exclude, lexist
    logical :: converged = .false.
    real(dp) :: fe = 1.0d0
    real(dp) :: ft = 1.0d0
    real(dp) :: R, R3, R5, Rd, ai, aj, norm, redthr
    real(dp), parameter :: d3i = 1.0d0 / 3.0d0
    real(dp), parameter :: d6i = 1.0d0 / 6.0d0
    real(dp), dimension(:), allocatable :: B, T, Rij, Ftmp, M1tmp

    if (pe_iter) then
        if (myid == 0) then
            if (fock .and. scfcycle <= 5) then
                redthr = 10**(5-scfcycle)
            else
                redthr = 1.0d0
            end if
        end if

        if (myid == 0) then
            inquire(file='pe_induced_dipoles.bin', exist=lexist)
        end if

#ifdef VAR_MPI
        if (ncores > 1) then
            call mpi_bcast(lexist, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
        end if
#endif

        if (lexist .and. fock) then
            if (myid == 0) then
                call openfile('pe_induced_dipoles.bin', lu, 'old', 'unformatted')
                rewind(lu)
                read(lu) M1inds
                close(lu)
            end if
        end if

        allocate(T(6), Rij(3), Ftmp(3), M1tmp(3))
        do n = 1, ndens
            if (.not.lexist .or. response) then
#ifdef VAR_MPI
                if (myid == 0 .and. ncores > 1) then
                    call mpi_scatterv(Fs(:,n), 3*npoldists, displs, MPI_REAL8,&
                                     &MPI_IN_PLACE, 0, MPI_REAL8,&
                                     &0, MPI_COMM_WORLD, ierr)
                else if (myid /= 0) then
                    call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                                     &Fs(:,n), 3*npoldists(myid), MPI_REAL8,&
                                     &0, MPI_COMM_WORLD, ierr)
                end if
#endif

                l = 1
                do i = nsites(myid-1)+1, nsites(myid)
                    if (zeroalphas(i)) cycle
                    call spmv(P1s(:,i), Fs(l:l+2,n), M1inds(l:l+2,n), 'L')
                    l = l + 3
                end do

#ifdef VAR_MPI
                if (myid == 0 .and. ncores > 1) then
                    call mpi_gatherv(MPI_IN_PLACE, 0, MPI_REAL8,&
                                    &M1inds(:,n), 3*npoldists, displs, MPI_REAL8,&
                                    &0, MPI_COMM_WORLD, ierr)
                else if (myid /= 0) then
                    call mpi_gatherv(M1inds(:,n), 3*npoldists(myid), MPI_REAL8,&
                                    &0, 0, 0, MPI_REAL8,&
                                    &0, MPI_COMM_WORLD, ierr)
                end if
#endif
            end if

            if (pe_nomb) cycle

#ifdef VAR_MPI
            if (myid == 0 .and. ncores > 1) then
                call mpi_scatterv(M1inds(:,n), 3*npoldists, displs, MPI_REAL8,&
                                 &MPI_IN_PLACE, 0, MPI_REAL8,&
                                 &0, MPI_COMM_WORLD, ierr)
            else if (myid /= 0) then
                call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                                 &M1inds(:,n), 3*npoldists(myid), MPI_REAL8,&
                                 &0, MPI_COMM_WORLD, ierr)
            end if
#endif

            iter = 1
            do
                norm = 0.0d0
                l = 1
                do i = 1, nsites(ncores-1)
                    if (zeroalphas(i)) cycle
                    if (pe_damp) then
                        ai = (P1s(1,i) + P1s(4,i) + P1s(6,i)) * d3i
                    end if
                    m = 1
                    Ftmp = 0.0d0
                    do j = nsites(myid-1)+1, nsites(myid)
                        if (zeroalphas(j)) cycle
                        exclude = .false.
                        do k = 1, lexlst
                            if (exlists(k,i) == exlists(1,j)) then
                                exclude = .true.
                                exit
                            end if
                        end do
                        if (i == j .or. exclude) then
                            m = m + 3
                            cycle
                        end if
! TODO: damping needs to be fixed
                        ! damping parameters
                        ! JPC A 102 (1998) 2399 & Mol. Sim. 32 (2006) 471
                        ! a = 2.1304 = damp
                        ! u = R / (alpha_i * alpha_j)**(1/6)
                        ! fe = 1-(a²u²/2+au+1)*exp(-au)
                        ! ft = 1-(a³u³/6+a²u²/2+au+1)*exp(-au)
                        if (pe_damp) then
                            aj = (P1s(1,j) + P1s(4,j) + P1s(6,j)) * d3i
                            Rd = damp * R / (ai * aj)**(d6i)
                            fe = 1.0d0 - (0.5d0 * Rd**2 + Rd + 1.0d0) * exp(-Rd)
                            ft = fe - d6i * Rd**3 * exp(-Rd)
                        end if
                        Rij = Rs(:,j) - Rs(:,i)
                        R = nrm2(Rij)
                        R3 = R**3
                        R5 = R**5
                        T(1) = 3.0d0 * Rij(1) * Rij(1) * ft / R5 - fe / R3
                        T(2) = 3.0d0 * Rij(1) * Rij(2) * ft / R5
                        T(3) = 3.0d0 * Rij(1) * Rij(3) * ft / R5
                        T(4) = 3.0d0 * Rij(2) * Rij(2) * ft / R5 - fe / R3
                        T(5) = 3.0d0 * Rij(2) * Rij(3) * ft / R5
                        T(6) = 3.0d0 * Rij(3) * Rij(3) * ft / R5 - fe / R3
                        call spmv(T, M1inds(m:m+2,n), Ftmp, 'L', 1.0d0, 1.0d0)
                        m = m + 3
                    end do

#ifdef VAR_MPI
                    if (myid == 0 .and. ncores > 1) then
                        call mpi_reduce(MPI_IN_PLACE, Ftmp, 3, MPI_REAL8,&
                                       &MPI_SUM, 0, MPI_COMM_WORLD, ierr)
                    else if (myid /= 0) then
                        call mpi_reduce(Ftmp, 0, 3, MPI_REAL8,&
                                       &MPI_SUM, 0, MPI_COMM_WORLD, ierr)
                    end if
#endif

                    if (myid == 0) then
                        M1tmp = M1inds(l:l+2,n)
                        Ftmp = Ftmp + Fs(l:l+2,n)
                        call spmv(P1s(:,i), Ftmp, M1inds(l:l+2,n), 'L')
                        norm = norm + nrm2(M1inds(l:l+2,n) - M1tmp)
                    end if

#ifdef VAR_MPI
                    if (myid == 0 .and. ncores > 1) then
                        call mpi_scatterv(M1inds(:,n), 3*npoldists, displs,&
                                         &MPI_REAL8, MPI_IN_PLACE, 0,&
                                         &MPI_REAL8, 0, MPI_COMM_WORLD, ierr)
                    else if (myid /= 0) then
                        call mpi_scatterv(0, 0, 0, MPI_REAL8,&
                                         &M1inds(:,n), 3*npoldists(myid),&
                                         &MPI_REAL8, 0, MPI_COMM_WORLD, ierr)
                    end if
#endif
                    l = l + 3
                end do

                if (myid == 0) then
                    if (norm < redthr * thriter) then
                        write (luout,'(a,i2,a)') 'Induced dipoles converged in ',&
                                                 & iter, ' iterations.'
                        converged = .true.
                    else if (iter > 50) then
                        stop 'Maximum iterations reached.'
                    else
                        converged = .false.
                        iter = iter + 1
                    end if
                end if

#ifdef VAR_MPI
                if (ncores > 1) then
                    call mpi_bcast(converged, 1, MPI_LOGICAL, 0,&
                                  &MPI_COMM_WORLD, ierr)
                end if
#endif
                if (converged) exit
            end do
        end do
        if (fock) then
            if (myid == 0) then
                call openfile('pe_induced_dipoles.bin', lu, 'unknown', 'unformatted')
                rewind(lu)
                write(lu) M1inds
                close(lu)
            end if
        end if
        deallocate(T, Rij, Ftmp, M1tmp)
    else
        if (myid == 0) then
            allocate(B(3*npols*(3*npols+1)/2))
            inquire(file='pe_response_matrix.bin', exist=lexist)
            if (lexist) then
                call openfile('pe_response_matrix.bin', lu, 'old', 'unformatted')
                rewind(lu)
                if (chol) then
                    read(lu) B
                else
                    allocate(ipiv(3*npols))
                    read(lu) B, ipiv
                end if
                close(lu)
            else
                call response_matrix(B)
                if (chol) then
                    call pptrf(B, 'L', info)
                    if (info /= 0) then
                        print *, 'Cholesky factorization failed. Trying regular...'
                        allocate(ipiv(3*npols))
                        call sptrf(B, 'L', ipiv, info)
                        if (info /= 0) then
                            stop 'ERROR: cannot create response matrix.'
                        else
                            chol = .false.
                        end if
                    end if
                else
                    allocate(ipiv(3*npols))
                    call sptrf(B, 'L', ipiv, info)
                    if (info /= 0) then
                        stop 'ERROR: cannot create response matrix.'
                    end if
                end if
                call openfile('pe_response_matrix.bin', lu, 'new', 'unformatted')
                rewind(lu)
                if (chol) then
                    write(lu) B
                else
                    write(lu) B, ipiv
                end if
                close(lu)
            end if
            M1inds = Fs
            if (chol) then
                call pptrs(B, M1inds, 'L')
                deallocate(B)
            else
                call sptrs(B, M1inds, ipiv, 'L')
                deallocate(B, ipiv)
            end if
        end if
    end if

    ! check induced dipoles
    if (myid == 0) then
        do n = 1, ndens
            l = 1
            do i = 1, nsites(ncores-1)
                if (zeroalphas(i)) cycle
                if (nrm2(M1inds(l:l+2,n)) > 1.0d0) then
                    write(luout,'(4x,a,i6)') 'Large induced dipole encountered&
                                             & at site:', i
                    write(luout,'(f10.4)') nrm2(M1inds(l:l+2,n))
                end if
                l = l + 3
            end do
        end do
    end if

end subroutine induced_dipoles

!------------------------------------------------------------------------------

subroutine electron_fields(Fels, denmats)

    external :: Tk_integrals

    real(dp), dimension(:,:), intent(out) :: Fels
    real(dp), dimension(:), intent(in) :: denmats

    logical :: skip
    integer :: site
    integer :: i, j, k, l, m
    real(dp), dimension(nnbas,3) :: Fel_ints

    Fels = 0.0d0

    i = 0
    do site = nsites(myid-1)+1, nsites(myid)
        if (zeroalphas(site)) cycle
        if (pe_savden) then
            skip = .false.
            do j = 1, qmnucs
                if (nrm2(Rs(:,site) - Rm(:,j)) <= 1.0d0) skip = .true.
            end do
            if (skip) cycle
        end if
#ifdef BUILD_GEN1INT
        call Tk_integrals(Fel_ints, nnbas, 3, Rs(:,site), .false., 0.0d0)
#else
        call Tk_integrals(Fel_ints, nnbas, 3, Rs(:,site), work, size(work))
#endif
        do j = 1, 3
            do k = 1, ndens
                l = (k - 1) * nnbas + 1
                m = k * nnbas
                Fels(i+j,k) = dot(denmats(l:m), Fel_ints(:,j))
            end do
        end do
        i = i + 3
    end do

#ifdef VAR_MPI
    if (myid == 0 .and. ncores > 1) then
        displs(0) = 0
        do i = 1, ncores-1
            displs(i) = displs(i-1) + 3 * npoldists(i-1)
        end do
        do i = 1, ndens
            call mpi_gatherv(MPI_IN_PLACE, 0, MPI_REAL8,&
                            &Fels(:,i), 3*npoldists, displs, MPI_REAL8,&
                            &0, MPI_COMM_WORLD, ierr)
        end do
    else if (myid /= 0) then
        do i = 1, ndens
            call mpi_gatherv(Fels(:,i), 3*npoldists(myid), MPI_REAL8,&
                            &0, 0, 0, MPI_REAL8,&
                            &0, MPI_COMM_WORLD, ierr)
        end do
    end if
#endif

end subroutine electron_fields

!------------------------------------------------------------------------------

subroutine nuclear_fields(Fnucs)

    real(dp), dimension(:), intent(out) :: Fnucs

    logical :: lexist, skip
    integer :: lu, site
    integer :: i, j, k
    real(dp), dimension(3) :: Rms, Tms

    if (myid == 0) then
        inquire(file='pe_nuclear_field.bin', exist=lexist)
    end if

#ifdef VAR_MPI
    if (ncores > 1) then
        call mpi_bcast(lexist, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
    end if
#endif

    if (lexist) then
        if (myid == 0) then
            call openfile('pe_nuclear_field.bin', lu, 'old', 'unformatted')
            rewind(lu)
            read(lu) Fnucs
            close(lu)
        end if
    else
        Fnucs = 0.0d0
        i = 0
        do site = nsites(myid-1)+1, nsites(myid)
            if (zeroalphas(site)) cycle
            if (pe_savden) then
                skip = .false.
                do j = 1, qmnucs
                    if (nrm2(Rs(:,site) - Rm(:,j)) <= 1.0d0) skip = .true.
                end do
                if (skip) cycle
            end if
            do j = 1, qmnucs
                Rms = Rs(:,site) - Rm(:,j)
                call Tk_tensor(Tms, Rms)
                do k = 1, 3
                    Fnucs(i+k) = Fnucs(i+k) - Zm(1,j) * Tms(k)
                end do
            end do
            i = i + 3
        end do
#ifdef VAR_MPI
        if (myid == 0 .and. ncores > 1) then
            call mpi_gatherv(MPI_IN_PLACE, 0, MPI_REAL8,&
                            &Fnucs, 3*npoldists, displs, MPI_REAL8,&
                            &0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            call mpi_gatherv(Fnucs, 3*npoldists(myid), MPI_REAL8,&
                            &0, 0, 0, MPI_REAL8,&
                            &0, MPI_COMM_WORLD, ierr)
        end if
#endif
        if (myid == 0) then
            call openfile('pe_nuclear_field.bin', lu, 'new', 'unformatted')
            rewind(lu)
            write(lu) Fnucs
            close(lu)
        end if
    end if

end subroutine nuclear_fields

!------------------------------------------------------------------------------

subroutine frozen_density_field(Ffd)

    real(dp), dimension(:), intent(out) :: Ffd

    integer :: i
    integer :: lu
    character(len=99) :: ci
    character(len=80) :: filename
    real(dp), dimension(3*npols) :: Ftmp

    Ffd = 0.0d0

    do i = 1, nfds
        Ftmp = 0.0d0
        write(ci,*) i
        ci = adjustl(ci)
        filename = 'pe_fock_'//trim(ci)//'.bin'
        call openfile(trim(filename), lu, 'old', 'unformatted')
        rewind(lu)
        read(lu) Ftmp
        close(lu)
        Ffd = Ffd + Ftmp
    end do

end subroutine frozen_density_field

!------------------------------------------------------------------------------

subroutine multipole_fields(Fmuls)

    real(dp), dimension(:), intent(out) :: Fmuls

    logical :: exclude, lexist
    integer :: lu
    integer :: i, j, k, l, m
    real(dp), dimension(3) :: Rji

    if (myid == 0) then
        inquire(file='pe_multipole_field.bin', exist=lexist)
    end if

#ifdef VAR_MPI
    if (ncores > 1) then
        call mpi_bcast(lexist, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
    end if
#endif

    if (lexist) then
        if (myid == 0) then
            call openfile('pe_multipole_field.bin', lu, 'old', 'unformatted')
            rewind(lu)
            read(lu) Fmuls
            close(lu)
        end if
    else
        Fmuls = 0.0d0
        l = 1
        do i = 1, nsites(ncores-1)
            if (zeroalphas(i)) cycle
            k = 1
            do j = nsites(myid-1)+1, nsites(myid)
                if (i == j) then
                    k = k + 1
                    cycle
                end if
                exclude = .false.
                do m = 1, lexlst
                    if (exlists(m,i) == exlists(1,j)) then
                        exclude = .true.
                        k = k + 1
                        exit
                    end if
                end do
                if (exclude) cycle
! TODO: cutoff???
                Rji = Rs(:,i) - Rs(:,j)
                if (lmul(0)) then
                    if (abs(maxval(M0s(:,k))) >= zero) then
                        call multipole_field(Fmuls(l:l+2), Rji, M0s(:,k))
                    end if
                end if
                if (lmul(1)) then
                    if (abs(maxval(M1s(:,k))) >= zero) then
                        call multipole_field(Fmuls(l:l+2), Rji, M1s(:,k))
                    end if
                end if
                if (lmul(2)) then
                    if (abs(maxval(M2s(:,k))) >= zero) then
                        call multipole_field(Fmuls(l:l+2), Rji, M2s(:,k))
                    end if
                end if
                if (lmul(3)) then
                    if (abs(maxval(M3s(:,k))) >= zero) then
                        call multipole_field(Fmuls(l:l+2), Rji, M3s(:,k))
                    end if
                end if
                if (lmul(4)) then
                    if (abs(maxval(M4s(:,k))) >= zero) then
                        call multipole_field(Fmuls(l:l+2), Rji, M4s(:,k))
                    end if
                end if
                if (lmul(5)) then
                    if (abs(maxval(M5s(:,k))) >= zero) then
                        call multipole_field(Fmuls(l:l+2), Rji, M5s(:,k))
                    end if
                end if
                k = k + 1
            end do
            l = l + 3
        end do
#ifdef VAR_MPI
        if (myid == 0 .and. ncores > 1) then
            call mpi_reduce(MPI_IN_PLACE, Fmuls, 3*npols, MPI_REAL8,&
                           &MPI_SUM, 0, MPI_COMM_WORLD, ierr)
        else if (myid /= 0) then
            call mpi_reduce(Fmuls, 0, 3*npols, MPI_REAL8,&
                           &MPI_SUM, 0, MPI_COMM_WORLD, ierr)
        end if
#endif
        if (myid == 0) then
            call openfile('pe_multipole_field.bin', lu, 'new', 'unformatted')
            rewind(lu)
            write(lu) Fmuls
            close(lu)
        end if
     end if

end subroutine multipole_fields

!------------------------------------------------------------------------------

subroutine multipole_field(Fi, Rji, Mkj)

    real(dp), dimension(3), intent(inout) :: Fi
    real(dp), dimension(3), intent(in) :: Rji
    real(dp), dimension(:), intent(in) :: Mkj

    integer :: k
    integer :: a, b, c, x, y, z
    real(dp) :: taylor

    k = int(0.5d0 * (sqrt(1.0d0 + 8.0d0 * size(Mkj)) - 1.0d0))

    if (mod(k,2) == 0) then
        taylor = 1.0d0 / factorial(k-1)
    else if (mod(k,2) /= 0) then
        taylor = - 1.0d0 / factorial(k-1)
    end if

    a = 1; b = 1; c = 1
    do x = k, 0, -1
        do y = k, 0, -1
            do z = k, 0, -1
                if (x+y+z /= k) cycle
                if (x /= 0) then
                    Fi(1) = Fi(1) + taylor * symfac(x-1,y,z) * T(Rji,x,y,z) * Mkj(a)
                    a = a + 1
                end if
                if (y /= 0) then
                    Fi(2) = Fi(2) + taylor * symfac(x,y-1,z) * T(Rji,x,y,z) * Mkj(b)
                    b = b + 1
                end if
                if (z /= 0) then
                    Fi(3) = Fi(3) + taylor * symfac(x,y,z-1) * T(Rji,x,y,z) * Mkj(c)
                    c = c + 1
                end if
            end do
        end do
     end do

end subroutine multipole_field

!------------------------------------------------------------------------------

subroutine response_matrix(B)

! TODO: Cutoff radius

    real(dp), dimension(:), intent(out) :: B

    logical :: exclude
    integer :: info
    integer :: i, j, k, l, m, n
    integer, dimension(3) :: ipiv
    real(dp), parameter :: d3i = 1.0d0 / 3.0d0
    real(dp), parameter :: d6i = 1.0d0 / 6.0d0
    real(dp) :: fe = 1.0d0
    real(dp) :: ft = 1.0d0
    real(dp) :: Rd, ai, aj
    real(dp) :: R, R3, R5, T
    real(dp), dimension(3) :: Rij
    real(dp), dimension(6) :: P1inv

    B = 0.0d0
    m = 0
    do i = 1, nsites(ncores-1)
        if (zeroalphas(i)) cycle
        P1inv = P1s(:,i)
        call pptrf(P1inv, 'L', info)
        if (info /= 0) then
            P1inv = P1s(:,i)
            call sptrf(P1inv, 'L', ipiv, info)
            if (info /= 0) then
                stop 'ERROR: could not factorize polarizability.'
            else if (chol) then
                chol = .false.
            end if
            call sptri(P1inv, ipiv, 'L')
        else
            call pptri(P1inv, 'L')
        end if
        if (pe_damp) then
            ai = (P1s(1,i) + P1s(4,i) + P1s(6,i)) * d3i
        end if
        do l = 3, 1, -1
            do j = i, nsites(ncores-1)
                if (zeroalphas(j)) cycle
                if (j == i) then
                    if (l == 3) then
                        do k = 1, l
                            B(m+k) = P1inv(k)
                        end do
                    else if (l == 2) then
                        do k = 1, l
                            B(m+k) = P1inv(3+k)
                        end do
                    else if (l == 1) then
                        do k = 1, l
                            B(m+k) = P1inv(5+k)
                        end do
                    end if
                    m = m + l
                else
                    if (pe_nomb) then
                        m = m + 3
                        cycle
                    end if
                    exclude = .false.
                    do k = 1, lexlst
                        if (exlists(k,i) == exlists(1,j)) then
                            exclude = .true.
                            exit
                        end if
                    end do
                    if (exclude) then
                        m = m + 3
                        cycle
                    end if
                    Rij = Rs(:,j) - Rs(:,i)
                    R = nrm2(Rij)
                    R3 = R**3
                    R5 = R**5
! TODO: cutoff radius
!                        if (R > cutoff) then
!                            m = m + 3
!                            cycle
!                        end if
                    ! damping parameters
                    ! JPC A 102 (1998) 2399 & Mol. Sim. 32 (2006) 471
                    ! a = 2.1304 = damp
                    ! u = R / (alpha_i * alpha_j)**(1/6)
                    ! fe = 1-(a²u²/2+au+1)*exp(-au)
                    ! ft = 1-(a³u³/6+a²u²/2+au+1)*exp(-au)
                    if (pe_damp) then
                        aj = (P1s(1,j) + P1s(4,j) + P1s(6,j)) * d3i
                        Rd = damp * R / (ai * aj)**d6i
                        fe = 1.0d0 - (0.5d0 * Rd**2 + Rd + 1.0d0) * exp(-Rd)
                        ft = fe - d6i * Rd**3 * exp(-Rd)
                    end if
                    if (l == 3) then
                        do k = 1, 3
                            T = 3.0d0 * Rij(1) * Rij(k) * ft / R5
                            if (k == 1) T = T - fe / R3
                            B(m+k) = - T
                        end do
                    else if (l == 2) then
                        do k = 1, 3
                            T = 3.0d0 * Rij(2) * Rij(k) * ft / R5
                            if (k == 2) T = T - fe / R3
                            B(m+k) = - T
                        end do
                    else if (l == 1) then
                        do k = 1, 3
                            T = 3.0d0 * Rij(3) * Rij(k) * ft / R5
                            if (k == 3) T = T - fe / R3
                            B(m+k) = - T
                        end do
                    end if
                    m = m + 3
                end if
            end do
        end do
    end do

end subroutine response_matrix

!------------------------------------------------------------------------------

subroutine Tk_coefficients

    ! C. E. Dykstra, J. Comp. Chem., 9 (1988), 476

    integer :: i, j, k, l, m, n

! TODO: if mulorder less than polorder then it will be too small?
!    allocate(Cnij(2*mulorder+3,0:mulorder+1,0:mulorder+1))
    allocate(Cnij(2*5+3,0:5+1,0:5+1))

    Cnij = 0
    Cnij(:,0,0) = 1
    do n = 1, 2*5+3
        if (mod(n,2) == 0) cycle
        do i = 1, 5+1
            if (mod(i,2) /= 0) then
                k = i - 1
            else if (mod(i,2) == 0) then
                k = i
            end if
            do j = 0, i
                if (mod(i+j,2) /= 0) cycle
                if (j == 0) then
                    Cnij(n,i,j) = Cnij(n,i-1,j+1)
                else if (j /= i) then
                    Cnij(n,i,j) = (j + 1) * Cnij(n,i-1,j+1)
                    Cnij(n,i,j) = Cnij(n,i,j) - (n + k) * Cnij(n,i-1,j-1)
                    k = k + 2
                else if (j == i) then
                    Cnij(n,i,j) = - (n + k) * Cnij(n,i-1,j-1)
                end if
            end do
        end do
    end do

end subroutine Tk_coefficients

!------------------------------------------------------------------------------

function T(Rij, x, y, z)

    ! C. E. Dykstra, J. Comp. Chem., 9 (1988), 476

    integer, intent(in) :: x, y, z
    real(dp), dimension(3), intent(in) :: Rij

    integer :: l, m, n
    real(dp) :: T
    real(dp) :: R, Cx, Cy, Cz

    if (.not. allocated(Cnij)) call Tk_coefficients

    R = nrm2(Rij)

    T = 0.0d0

    do l = 0, x
        Cx = Cnij(1,x,l)*(Rij(1)/R)**l
        do m = 0, y
            Cy = Cx * Cnij(l+x+1,y,m)*(Rij(2)/R)**m
            do n = 0, z
                Cz = Cy * Cnij(l+x+m+y+1,z,n)*(Rij(3)/R)**n
                T = T + Cz
            end do
        end do
    end do
    T = T / R**(x+y+z+1)

end function T

!------------------------------------------------------------------------------

subroutine Tk_tensor(Tk, Rij)

    ! C. E. Dykstra, J. Comp. Chem., 9 (1988), 476

    real(dp), dimension(:), intent(out) :: Tk
    real(dp), dimension(3), intent(in) :: Rij

    integer :: k, i
    integer :: x, y, z

    k = int(0.5d0 * (sqrt(1.0d0 + 8.0d0 * size(Tk)) - 1.0d0)) - 1

    i = 1
    do x = k, 0, -1
        do y = k, 0, -1
            do z = k, 0, -1
                if (x+y+z /= k) cycle
                Tk(i) = T(Rij, x, y, z)
                i = i + 1
            end do
        end do
    end do

end subroutine Tk_tensor

!------------------------------------------------------------------------------

subroutine Mk_integrals(Mk_ints, Rij, Mk)

    external :: Tk_integrals

    real(dp), dimension(:,:), intent(out) :: Mk_ints
    real(dp), dimension(:), intent(in) :: Mk
    real(dp), dimension(3), intent(in) :: Rij

    integer :: i, k
    integer :: ncomps
    real(dp) :: taylor
    real(dp), dimension(:), allocatable :: factors

    k = int(0.5d0 * (sqrt(1.0d0 + 8.0d0 * size(Mk)) - 1.0d0)) - 1

    if (mod(k,2) == 0) then
        taylor = 1.0d0 / factorial(k)
    else if (mod(k,2) /= 0) then
        taylor = - 1.0d0 / factorial(k)
    end if

    ncomps = size(Mk_ints, 2)

#ifdef BUILD_GEN1INT
    call Tk_integrals(Mk_ints, nnbas, ncomps, Rij, .false., 0.0d0)
#else
    call Tk_integrals(Mk_ints, nnbas, ncomps, Rij, work, size(work))
#endif

    ! get symmetry factors
    allocate(factors(ncomps)); factors = 0.0d0
    call symmetry_factors(factors)

    ! dot T^(k) integrals with multipole to get M^(k) integrals
    do i = 1, ncomps
        Mk_ints(:,i) = taylor * factors(i) * Mk(i) * Mk_ints(:,i)
    end do

    deallocate(factors)

end subroutine Mk_integrals

!------------------------------------------------------------------------------

subroutine symmetry_factors(factors)

    real(dp), dimension(:), intent(out) :: factors

    integer :: idx, x, y, z, k

    k = int(0.5d0 * (sqrt(1.0d0 + 8.0d0 * size(factors)) - 1.0d0)) - 1

    idx = 1
    do x = k, 0, -1
        do y = k, 0, -1
            do z = k, 0, -1
                if (x+y+z /= k) cycle
                factors(idx) = symfac(x, y, z)
                idx = idx + 1
            end do
        end do
     end do

end subroutine symmetry_factors

!------------------------------------------------------------------------------

function symfac(i, j, k)

    ! trinomial coefficient

    integer, intent(in) :: i, j, k

    integer :: symfac

    symfac = factorial(i+j+k) / (factorial(i) * factorial(j) * factorial(k))

end function symfac

!------------------------------------------------------------------------------

recursive function factorial(n) result(nfact)

    ! Clive Page, http://www.star.le.ac.uk/~cgp/f90course/f90.html

    integer, intent(in) :: n

    integer :: nfact

    if (n > 0) then
        nfact = n * factorial(n-1)
    else
        nfact = 1
    end if

end function factorial

!------------------------------------------------------------------------------

subroutine pe_save_density(density, nbas, coords, charges, dalwrk)

    external :: Tk_integrals

    integer, intent(in) :: nbas
    real(dp), dimension(:), intent(in) :: density
    real(dp), dimension(:), intent(in) :: charges
    real(dp), dimension(:,:), intent(in) :: coords
    real(dp), dimension(:), target, intent(inout) :: dalwrk

    integer :: i, j, l
    integer :: corenucs
    integer, parameter :: k = 0
    integer :: lucore, luden
    character(len=2) :: auoraa
    real(dp) :: Ene
    real(dp), dimension(:,:), allocatable :: Rc, Zc
    real(dp), dimension(:,:), allocatable :: full_density
    real(dp), dimension(:,:), allocatable :: T0_ints
    real(dp), dimension(:), allocatable :: Ffd
    real(dp), dimension(:,:), allocatable :: Ftmp

    work => dalwrk

    ndens = 1
    nnbas = nbas * (nbas + 1) / 2

    ! frozen density nuclear charges and coordinates
    qmnucs = size(charges)
    allocate(Rm(3,qmnucs), Zm(1,qmnucs))
    Rm = coords
    Zm(1,:) = charges
    
    ! read in information about qm core
    call openfile('core.dat', lucore, 'old', 'formatted')
    rewind(lucore)
    read(lucore,*) auoraa
    read(lucore,*) corenucs
    allocate(Zc(1,corenucs), Rc(3,corenucs))
    do i = 1, corenucs
        read(lucore,*) Zc(1,i), (Rc(j,i), j = 1, 3)
    end do
    close(lucore)
    if (auoraa == 'AA') then
        Rc = Rc * aa2au
    end if

    ! unfold density matrix
    allocate(full_density(nbas,nbas)); full_density = 0.0d0
    l = 1
    do i = 1, nbas
        do j = 1, i
            if (j == i) then
                full_density(i,j) = density(l)
            else
                full_density(i,j) = 0.5d0 * density(l)
                full_density(j,i) = 0.5d0 * density(l)
            end if
            l = l + 1
        end do
    end do

    ! get electric field from frozen density at polarizable sites
    allocate(Ftmp(3*npols,1), Ffd(3*npols)); Ftmp = 0.0d0
    call electron_fields(Ftmp, density)
    Ffd = Ftmp(:,1)
    call nuclear_fields(Ftmp(:,1))
    Ffd = Ffd + Ftmp(:,1)

    ! calculate nuclear - electron energy contribution
    allocate(T0_ints(nnbas,1)); T0_ints = 0.0d0
    Ene = 0.0d0
    do i = 1, corenucs
#ifdef BUILD_GEN1INT
        call Tk_integrals(T0_ints, nnbas, 1, Rc(:,i), .false., 0.0d0)
#else
        call Tk_integrals(T0_ints, nnbas, 1, Rc(:,i), work, size(work))
#endif
        T0_ints = Zc(1,i) * T0_ints
        Ene = Ene + dot(density, T0_ints(:,1))
    end do
    deallocate(T0_ints)

    ! save density, energy and field for subsequent calculations
    call openfile('pe_density.bin', luden, 'new', 'unformatted')
    rewind(luden)
    write(luden) Ene
    write(luden) qmnucs
    write(luden) Rm, Zm
    write(luden) npols
    write(luden) Ffd
    write(luden) nbas
    write(luden) full_density
    close(luden)

    deallocate(full_density, Ffd, Ftmp)

end subroutine pe_save_density

!------------------------------------------------------------------------------

subroutine pe_intmol_twoints(nbas, dalwrk)

    external :: sirfck

    integer, intent(in) :: nbas
    real(dp), dimension(:), target, intent(inout) :: dalwrk

    integer :: i, j, k, l
    integer :: fbas, cbas
    integer :: luden, lufck
    integer, dimension(1) :: isymdm, ifctyp
    real(dp) :: Ene
    real(dp), dimension(:), allocatable :: core_fock, Ffd
    real(dp), dimension(:,:), allocatable :: frozen_density, full_density
    real(dp), dimension(:,:), allocatable :: full_fock

    external :: rdonel, dsptge
    real(dp) :: nrm
    real(dp), dimension(:), allocatable :: packed_overlap
    real(dp), dimension(:,:), allocatable :: full_overlap
    real(dp), dimension(:,:), allocatable :: intmol_overlap

    work => dalwrk

    call openfile('pe_density.bin', luden, 'old', 'unformatted')
    rewind(luden)
    read(luden) Ene
    read(luden) fdnucs
    allocate(Rfd(3,fdnucs), Zfd(1,fdnucs))
    read(luden) Rfd, Zfd
    read(luden) npols
    allocate(Ffd(3*npols))
    read(luden) Ffd
    read(luden) fbas
    allocate(frozen_density(fbas, fbas))
    read(luden) frozen_density
    close(luden)

    cbas = nbas - fbas

    allocate(packed_overlap(nbas*(nbas+1)/2))
    allocate(full_overlap(nbas,nbas))
    allocate(intmol_overlap(cbas,cbas))
    call rdonel('OVERLAP', .true., packed_overlap, nbas*(nbas+1)/2)
    call dsptge(nbas, packed_overlap, full_overlap)
    deallocate(packed_overlap)
    call gemm(full_overlap(fbas+1:nbas,1:fbas),&
             &full_overlap(1:fbas,fbas+1:nbas),&
             &intmol_overlap)
    deallocate(full_overlap)
    nrm = 0.0d0
    do i = 1, cbas
        do j = 1, cbas
            nrm = nrm + intmol_overlap(i,j)**2
        end do
    end do
    nrm = sqrt(nrm)
    deallocate(intmol_overlap)

    ! density matrix with frozen density in first block
    allocate(full_density(nbas,nbas)); full_density = 0.0d0
    full_density(1:fbas,1:fbas) = frozen_density
    deallocate(frozen_density)

    ! get two-electron part of Fock matrix using resized density matrix
    allocate(full_fock(nbas,nbas)); full_fock = 0.0d0
!     IFCTYP = +/-XY
!       X indicates symmetry about diagonal
!         X = 0 No symmetry
!         X = 1 Symmetric
!         X = 2 Anti-symmetric
!       Y indicates contributions
!         Y = 0 no contribution !
!         Y = 1 Coulomb
!         Y = 2 Exchange
!         Y = 3 Coulomb + Exchange
!       + sign: alpha + beta matrix (singlet)
!       - sign: alpha - beta matrix (triplet)
!     sirfck(fock, density, ?, isymdm, ifctyp, direct, work, nwrk)
    isymdm = 1
    ifctyp = 11
    call sirfck(full_fock, full_density, 1, isymdm, ifctyp, .false.,&
                work, size(work))
    deallocate(full_density)

    ! extract upper triangle part of full Fock matrix corresponding to
    ! core fragment
    allocate(core_fock(cbas*(cbas+1)/2)); core_fock = 0.0d0
    l = 1
    do i = fbas + 1, nbas
        do j = fbas + 1, i
            core_fock(l) = full_fock(j,i)
            l = l + 1
        end do
    end do
    deallocate(full_fock)

    ! save core Fock matrix
    call openfile('pe_fock.bin', lufck, 'new', 'unformatted')
    rewind(lufck)
    write(lufck) Ffd
    write(lufck) Ene
    write(lufck) core_fock
    write(lufck) fdnucs
    write(lufck) Rfd, Zfd
    write(lufck) nrm
    close(lufck)

    deallocate(core_fock, Rfd, Zfd, Ffd)

end subroutine pe_intmol_twoints

!------------------------------------------------------------------------------

subroutine pe_repulsion()

!    external :: rdonel
!
!    real(dp), dimension(:), intent(in) :: fckmat
!    real(dp), dimension(:), intent(inout) :: dalwrk
!
!    integer :: i, j, k, l
!    integer :: nbas, fbas, cbas, nnbas
!    real(dp), dimension(:), allocatable :: overlap
!
!    nnbas = size(fckmat)
!    nbas = int(0.5d0 * (sqrt(1.0d0 + 8.0d0 * nnbas) - 1.0d0))
!
!    call openfile('pe_density.bin', luden, 'old', 'unformatted')
!    rewind(luden)
!    read(luden) dalwrk
!    read(luden) dalwrk
!    read(luden) dalwrk
!    read(luden) dalwrk
!    read(luden) dalwrk
!    read(luden) fbas
!    close(luden)
!
!    cbas = nbas - fbas
!
!    call rdonel('OVERLAP', .true., overlap, nnbas)


end subroutine pe_repulsion

!------------------------------------------------------------------------------

subroutine invert_matrix(ap, sp)

    external :: dpptrf, dpptri, dsptrf, dsptri, xerbla

    character(*), optional :: sp
    real(dp), dimension(:), intent(inout) :: ap

    integer :: n, info
    integer, dimension(:), allocatable :: ipiv
    real(dp), dimension(:), allocatable :: wrk

    n = int(0.5d0 * (sqrt(1.0d0 + 8.0d0 * size(ap)) - 1.0d0))

    if (.not. present(sp)) then
        sp = 's'
    end if

    if (sp == 'p') then
        call dpptrf('L', n, ap, info)
        if (info /= 0) call xerbla('pptrf', info)
        call dpptri('L', n, ap, info)
        if (info /= 0) call xerbla('pptri', info)
    else if (sp == 's') then
        allocate(ipiv(n), wrk(n))
        call dsptrf('L', n, ap, ipiv, info)
        if (info /= 0) call xerbla('sptrf', info)
        call dsptri('L', n, ap, ipiv, wrk, info)
        if (info /= 0) call xerbla('sptri', info)
        deallocate(ipiv, wrk)
    end if

end subroutine invert_matrix

!------------------------------------------------------------------------------

subroutine solve(ap, b)

    real(dp), dimension(:), intent(inout) :: ap
    real(dp), dimension(:,:), intent(inout) :: b

    integer :: n, nrhs, info
    integer, dimension(:), allocatable :: ipiv

    n = size(b, 1)
    nrhs = size(b, 2)

    allocate(ipiv(n))

end subroutine solve

!------------------------------------------------------------------------------

subroutine openfile(filename, lunit, stat, frmt)

    character(*), intent(in) :: filename, stat, frmt
    integer, intent(out) :: lunit
    integer :: i
    logical :: lexist, lopen

    if (stat == 'old') then
      inquire(file=filename, exist=lexist)

      if (.not. lexist) then
        print *, filename, ' not found!'
        stop
      end if
    end if

    do i = 21, 99
      inquire(unit=i, opened=lopen)
      if (lopen) then
        cycle
      else
        lunit = i
        open(unit=lunit, file=filename, status=stat, form=frmt)
        exit
      end if
    end do

    return

end subroutine openfile

!------------------------------------------------------------------------------

function elem2charge(elem)

    character(*) :: elem
    real(dp) :: elem2charge

    integer :: i
    character(len=2), dimension(112) :: elements

    elements = (/ 'H ', 'He', 'Li', 'Be', 'B ', 'C ', 'N ', 'O ', 'F ', 'Ne',&
                & 'Na', 'Mg', 'Al', 'Si', 'P ', 'S ', 'Cl', 'Ar', 'K ', 'Ca',&
                & 'Sc', 'Ti', 'V ', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',&
                & 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y ', 'Zr',&
                & 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn',&
                & 'Sb', 'Te', 'I ', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd',&
                & 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb',&
                & 'Lu', 'Hf', 'Ta', 'W ', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',&
                & 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th',&
                & 'Pa', 'U ', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm',&
                & 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds',&
                & 'Rg', 'Cn'/)

    if (elem == 'X') then
        elem2charge = 0.0d0
        return
    end if

    do i = 1, 112
        if (elem == trim(elements(i))) then
            elem2charge = real(i, dp)
            exit
        end if
    end do

end function elem2charge

!------------------------------------------------------------------------------

subroutine chcase(string, uplo)

    character(len=*), intent(inout) :: string
    character(len=*), intent(in), optional :: uplo

    integer :: i, gap
    character(len=1) :: a, z, o_uplo

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'u'
    end if

    gap = iachar('a') - iachar('A')

    if (o_uplo == 'u' .or. o_uplo == 'U') then
        a = 'a'
        z = 'z'
    else if (o_uplo == 'l' .or. o_uplo == 'L') then
        a = 'A'
        z = 'Z'
        gap = - gap
    else
        stop 'Unknown case specified'
    end if

    do i = 1, len_trim(string)
        if (lge(string(i:i), a) .and. lle(string(i:i), z)) then
            string(i:i) = achar(iachar(string(i:i)) - gap)
        end if
    end do

end subroutine chcase

!------------------------------------------------------------------------------

function nrm2(x)

    real(dp), external :: dnrm2

    real(dp) :: nrm2
    real(dp), dimension(:), intent(in) :: x

    integer :: n, incx

    incx = 1

    n = size(x)

    nrm2 = dnrm2(n, x, incx)

end function nrm2

!------------------------------------------------------------------------------

function dot(x,y)

    real(dp), external :: ddot

    real(dp) :: dot
    real(dp), dimension(:), intent(in) :: x, y

    integer :: n, incx, incy

    incx = 1
    incy = 1

    n = size(x)

    dot = ddot(n, x, incx, y, incy)

end function dot

!------------------------------------------------------------------------------

subroutine axpy(x, y, a)

    external :: daxpy

    real(dp), intent(in), optional :: a
    real(dp), dimension(:), intent(in) :: x
    real(dp), dimension(:), intent(inout) :: y

    real(dp) :: o_a
    integer :: n, incx, incy

    if (present(a)) then
        o_a = a
    else
        o_a = 1.0d0
    end if

    incx = 1
    incy = 1

    n = size(x)

    call daxpy(n, o_a, x, incx, y, incy)

end subroutine axpy

!------------------------------------------------------------------------------

subroutine gemm(a, b, c, transa, transb, alpha, beta)

    external :: dgemm

    real(dp), intent(in), optional :: alpha, beta
    character(len=1), intent(in), optional :: transa, transb
    real(dp), dimension(:,:), intent(in) :: a, b
    real(dp), dimension(:,:) , intent(inout) :: c

    integer :: m, n, k, lda, ldb, ldc
    character(len=1) :: o_transa, o_transb
    real(dp) :: o_alpha, o_beta

    if (present(alpha)) then
        o_alpha = alpha
    else
        o_alpha = 1.0d0
    end if

    if (present(beta)) then
        o_beta = beta
    else
        o_beta = 0.0d0
    end if

    if (present(transa)) then
        o_transa = transa
    else
        o_transa = 'N'
    end if

    if (present(transb)) then
        o_transb = transb
    else
        o_transb = 'N'
    end if

    if (o_transa == 'N') then
        k = size(a, 2)
    else
        k = size(a, 1)
    end if

    m = size(c, 1)
    n = size(c, 2)
    lda = max(1, size(a, 1))
    ldb = max(1, size(b, 1))
    ldc = max(1, size(c, 1))

    call dgemm(o_transa, o_transb, m, n, k, o_alpha, a, lda, b, ldb, o_beta, c, ldc)

end subroutine gemm

!------------------------------------------------------------------------------

subroutine spmv(ap, x, y, uplo, alpha, beta)

    external :: dspmv

    real(dp), dimension(:), intent(in) :: ap
    real(dp), dimension(:), intent(in) :: x
    real(dp), dimension(:), intent(inout) :: y
    character(len=1), intent(in), optional :: uplo
    real(dp), intent(in), optional :: alpha, beta

    integer :: n, incx, incy
    real(dp) :: o_alpha, o_beta
    character(len=1) :: o_uplo

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'U'
    end if

    if (present(alpha)) then
        o_alpha = alpha
    else
        o_alpha = 1.0d0
    end if

    if (present(beta)) then
        o_beta = beta
    else
        o_beta = 0.0d0
    end if

    incx = 1
    incy = 1
    n = size(x)

    call dspmv(o_uplo, n, o_alpha, ap, x, incx, o_beta, y, incy)

end subroutine spmv

!------------------------------------------------------------------------------

subroutine sptrf(ap, uplo, ipiv, info)

    external :: dsptrf

    real(dp), dimension(:), intent(inout) :: ap
    character(len=1), optional :: uplo
    integer, dimension(:), optional, target :: ipiv
    integer, intent(out), optional :: info

    character(len=1) :: o_uplo
    integer :: o_info
    integer :: n, nn
    integer, dimension(:), pointer :: o_ipiv

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'U'
    end if

    nn = size(ap)

    if (nn <= 0) then
        n = nn
    else
        n = int((- 1 + sqrt(1.0d0 + 8.0d0 * real(nn, dp))) * 0.5d0)
    end if

    if (present(ipiv)) then
        o_ipiv => ipiv
    else
        allocate(o_ipiv(n))
    end if

    call dsptrf(o_uplo, n, ap, o_ipiv, o_info)

    if (.not. present(ipiv)) then
        deallocate(o_ipiv)
    end if

    if (present(info)) then
        info = o_info
    else if (o_info <= -1000) then
        call xerbla('SPTRF', - o_info)
    end if

end subroutine sptrf

!------------------------------------------------------------------------------

subroutine sptri(ap, ipiv, uplo, info)

    external :: dsptri

    real(dp), dimension(:), intent(inout) :: ap
    integer, dimension(:), intent(in) :: ipiv
    character(len=1), intent(in), optional :: uplo
    integer, intent(out), optional :: info

    character(len=1) :: o_uplo
    integer :: o_info
    integer :: n, nn

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'U'
    end if

    nn = size(ap)

    if (nn <= 0) then
        n = nn
    else
        n = int((- 1 + sqrt(1.0d0 + 8.0d0 * real(nn, dp))) * 0.5d0)
    end if

    call dsptri(o_uplo, n, ap, ipiv, work, o_info)

    if (present(info)) then
        info = o_info
    else if (o_info <= -1000) then
        call xerbla('SPTRI', - o_info)
    end if

end subroutine sptri

!------------------------------------------------------------------------------

subroutine sptrs(ap, b, ipiv, uplo, info)

    external :: dsptrs

    real(dp), dimension(:), intent(in) :: ap
    real(dp), dimension(:,:), intent(inout) :: b
    integer, dimension(:), intent(in) :: ipiv
    character(len=1), optional :: uplo
    integer, optional :: info

    character(len=1) :: o_uplo
    integer :: o_info
    integer :: n, nn, nrhs, ldb

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'U'
    end if

    nn = size(ap)
    nrhs = size(b, 2)
    ldb = max(1, size(b, 1))

    if (nn <= 0) then
        n = nn
    else
        n = int((- 1 + sqrt(1.0d0 + 8.0d0 * real(nn, dp))) * 0.5d0)
    end if

    call dsptrs(o_uplo, n, nrhs, ap, ipiv, b, ldb, o_info)

    if (present(info)) then
        info = o_info
    else if (o_info <= -1000) then
        call xerbla('SPTRS', - o_info)
    end if

end subroutine sptrs

!------------------------------------------------------------------------------

subroutine pptrf(ap, uplo, info)

    external :: dpptrf

    real(dp), dimension(:), intent(inout) :: ap
    character(len=1), optional :: uplo
    integer, optional :: info

    character(len=1) :: o_uplo
    integer :: o_info
    integer :: n, nn

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'U'
    end if

    nn = size(ap)

    if (nn <= 0) then
        n = nn
    else
        n = int((- 1 + sqrt(1.0d0 + 8.0d0 * real(nn, dp))) * 0.5d0)
    end if

    call dpptrf(o_uplo, n, ap, o_info)

    if (present(info)) then
        info = o_info
    else if (o_info <= -1000) then
        call xerbla('PPTRF', - o_info)
    end if

end subroutine pptrf

!------------------------------------------------------------------------------

subroutine pptri(ap, uplo, info)

    external :: dpptri

    real(dp), dimension(:), intent(inout) :: ap
    character(len=1), optional :: uplo
    integer, optional :: info

    character(len=1) :: o_uplo
    integer :: o_info
    integer :: n, nn

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'U'
    end if

    nn = size(ap)

    if (nn <= 0) then
        n = nn 
    else
        n = int((- 1 + sqrt(1.0d0 + 8.0d0 * real(nn, dp))) * 0.5d0)
    end if

    call dpptri(o_uplo, n, ap, o_info)

    if (present(info)) then
        info = o_info
    else if (o_info <= -1000) then
        call xerbla('PPTRI', - o_info)
    end if

end subroutine pptri

!------------------------------------------------------------------------------

subroutine pptrs(ap, b, uplo, info)

    external :: dpptrs

    real(dp), dimension(:), intent(inout) :: ap
    real(dp), dimension(:,:), intent(inout) :: b
    character(len=1), optional :: uplo
    integer, optional :: info

    character(len=1) :: o_uplo
    integer :: o_info
    integer :: n, nn, nrhs, ldb

    if (present(uplo)) then
        o_uplo = uplo
    else
        o_uplo = 'U'
    end if

    nn = size(ap)
    nrhs = size(b, 2)
    ldb = max(1, size(b, 1))

    if (nn <= 0) then
        n = nn
    else
        n = int((- 1 + sqrt(1.0d0 + 8.0d0 * real(nn, dp))) * 0.5d0)
    end if

    call dpptrs(o_uplo, n, nrhs, ap, b, ldb, o_info)

    if (present(info)) then
        info = o_info
    else if (o_info <= -1000) then
        call xerbla('PPTRS', - o_info)
    end if

end subroutine pptrs

!------------------------------------------------------------------------------

end module polarizable_embedding
