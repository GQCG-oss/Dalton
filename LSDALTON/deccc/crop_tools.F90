!> @file
!> Contains routines needed for CROP solver in CC driver
!> \author Marcin Ziolkowski

!> Set of subroutines for DIIS or CROP solver for linear or nonlinear set of
!> equations in CC methods.
module crop_tools_module

  use precision
  use tensor_interface_module

  
  ! DEC DEPENDENCIES (within deccc directory)   
  ! *****************************************
  use array2_simple_operations
  use array4_simple_operations

  ! Interface for CC2 or CCSD energies
  interface get_cc_energy
     module procedure get_cc_energy_arrold
     module procedure get_cc_energy_arrnew
  end interface

  contains

  !> \brief Solve system of linear equations using DGESV lapack routine 
  !> \author Marcin Ziolkowski
  !> \param Amat Square matrix A in Ax=b
  !> \param Bvec RHS vector (b)
  !> \param n Size of the problem (A(n,n))
  subroutine SolveLinearEquations(Amat,Bvec,n)
  
    implicit none
    real(realk), dimension(n,n), intent(in) :: Amat
    real(realk), dimension(n), intent(inout) :: Bvec
    integer, dimension(n) :: ipiv
    integer :: n,infoLAPACK
    external dgesv

    infoLAPACK = 0
  
    call dgesv(n,1,Amat,n,ipiv,Bvec,n,infoLAPACK)

    if(infoLAPACK /= 0) then
       print *,"DGESV INFO:",infoLAPACK
       call lsquit('SolveLinearEquations: error in LAPACK DGESV routine',-1)
    end if
  
  end subroutine SolveLinearEquations

  !> \brief Solve CROP/DIIS system of equations to get mixing coefficients 
  !> \author Marcin Ziolkowski
  !> \param maxDIIS Maximum size of iterative subspace
  !> \param maxIter Maximum number of iterations
  !> \param iter Current iteration number
  !> \param Bmat B matrix in CROP/DIIS
  !> \param c Mixing coefficients
  !> \param verbose Verbose parameter
  subroutine CalculateDIIScoefficients(maxDIIS,maxIter,iter,Bmat,c,verbose)
  
    implicit none
    integer, intent(in) :: maxDIIS,maxIter,iter
    integer :: i,j,k,l
    real(realk), dimension(maxIter,maxIter), intent(in) :: Bmat
    real(realk), dimension(maxIter), intent(inout) :: c
    logical, intent(in) :: verbose
  
    ! Maximal size of the subspace equations should be 4x4 (3 from vectors and 1
    ! from Lagrange coefficient). 
    real(realk), dimension(min(maxDIIS+1,iter+1),min(maxDIIS+1,iter+1)) :: bb
    real(realk), dimension(min(maxDIIS+1,iter+1)) :: cc
  
    bb=1.0E0_realk
  
    k=1
    do i=max(iter-maxDIIS+1,1),iter
      l=1
      do j=max(iter-maxDIIS+1,1),iter
        bb(k,l)=Bmat(i,j)
        l=l+1
      end do 
      k=k+1
    end do
   
    bb(min(maxDIIS+1,iter+1),min(maxDIIS+1,iter+1))=0E0_realk
    cc=0E0_realk; cc(min(maxDIIS+1,iter+1))=1E0_realk
   
    if(verbose) call PrintMatrix(bb,min(maxDIIS+1,iter+1),'B matrix  ')
   
    ! --- solve system of the linear equations ---   
    call SolveLinearEquations(bb,cc,min(maxDIIS+1,iter+1))
    ! ---

    k=1
    c=0E0_realk
    do i=max(iter-maxDIIS+1,1),iter
      c(i)=cc(k)
      k=k+1
    end do

    return
  end subroutine CalculateDIIScoefficients

  !> \brief Print simple fortran matrix in nice form, just for debuging purpose 
  !> \author Marcin Ziolkowski
  !> \param my_matrix Matrix to print
  !> \param m Size of the matrix
  !> \param title Title for the matrix
  subroutine PrintMatrix(my_matrix,m,title)
  
    implicit none
    real(realk), dimension(m,m) :: my_matrix
    integer :: m,i,j
    character(len=10), intent(in), optional :: title
  
    print *,''
    if(present(title)) print *,' *** ',title,' ***'
    do i=1,m
      print 100,(my_matrix(i,j),j=1,m)
    enddo
    print *,''
  
100 format(15f10.5) 
  
    return
  end subroutine PrintMatrix

  !> \brief Standard mp2 correlation energy
  !> \author Kasper Kristensen
  !> \return Full molecular MP2 energy
  !> \param t2 Double amplitudes
  !> \param Lmo Two-electron integrals L_{bjai} = 2*g_{bjai} - g_{ajbi}
  function get_mp2_energy(t2,Lmo) result(ecorr)

    implicit none
    type(array4), intent(in) :: Lmo,t2
    real(realk) :: ecorr

    ! Ecorr = sum_{aibj} t2_{bjai}*Lmo_{bjai}
    Ecorr=t2*Lmo

  end function get_mp2_energy

  !> \brief Coupled-cluster correlation energy
  !> \author Marcin Ziolkowski
  !> \return Full molecular CC correlation energy
  !> \param t2 Single amplitudes
  !> \param t2 Double amplitudes
  !> \param gmo Two-electron integrals (ia|jb)
  !> \param nocc Number of occupied orbitals
  !> \param nvirt Number of unoccupied orbitals
  function get_cc_energy_arrold(t1,t2,gmo,nocc,nvirt) result(ecorr)

    implicit none
    type(array2), intent(in) :: t1
    type(array4), intent(in) :: gmo,t2
    integer, intent(in) :: nocc,nvirt
    real(realk) :: ecorr,ecorr_s,ecorr_d
    integer :: a,i,b,j

    ecorr = 0.0E0_realk
    ecorr_s = 0.0E0_realk
    ecorr_d = 0.0E0_realk

    do j=1,nocc
       do b=1,nvirt
          do i=1,nocc
             do a=1,nvirt
                ecorr_d = ecorr_d + t2%val(a,i,b,j)* &
                     (2.0E0_realk*gmo%val(i,a,j,b)-gmo%val(i,b,j,a))
                ecorr_s = ecorr_s + ( t1%val(a,i)*t1%val(b,j) ) * &
                     (2.0E0_realk*gmo%val(i,a,j,b)-gmo%val(i,b,j,a))
             end do
          end do
       end do
    end do

    if(DECinfo%cc_driver_debug) then
       print *,' Singles energy : ',ecorr_s
       print *,' Doubles energy : ',ecorr_d
    end if

    ecorr = ecorr_s + ecorr_d

    return
  end function get_cc_energy_arrold

  function get_cc_energy_arrnew(t1,t2,gmo,nocc,nvirt) result(ecorr)

    implicit none
    type(array), intent(inout) :: t1
    type(array), intent(in) :: t2
    type(array), intent(inout) :: gmo
    integer, intent(in) :: nocc,nvirt
    real(realk) :: ecorr,ecorr_s,ecorr_d
    integer :: a,i,b,j

    ecorr = 0.0E0_realk
    ecorr_s = 0.0E0_realk
    ecorr_d = 0.0E0_realk

    if(t2%itype==DENSE.and.gmo%itype==DENSE.and.(t1%itype==DENSE.or.t1%itype==REPLICATED))then
      do j=1,nocc
         do b=1,nvirt
            do i=1,nocc
               do a=1,nvirt
                  ecorr_d = ecorr_d + t2%elm4(a,b,i,j)* &
                       (2.0E0_realk*gmo%elm4(i,a,j,b)-gmo%elm4(i,b,j,a))
                  ecorr_s = ecorr_s + ( t1%elm2(a,i)*t1%elm2(b,j) ) * &
                       (2.0E0_realk*gmo%elm4(i,a,j,b)-gmo%elm4(i,b,j,a))
               end do
            end do
         end do
      end do

      if(DECinfo%cc_driver_debug) then
         print *,' Singles energy : ',ecorr_s
         print *,' Doubles energy : ',ecorr_d
      end if

      ecorr = ecorr_s + ecorr_d
    elseif(t2%itype==TILED_DIST.and.gmo%itype==TILED_DIST)then
      t1%itype=REPLICATED
      call array_sync_replicated(t1)
      ecorr=get_cc_energy_parallel(t1,t2,gmo)
      t1%itype=DENSE
    endif


  end function get_cc_energy_arrnew

  !> \brief Get antisymmetrized double amplitudes
  !> \return Array4 structure with antisymmetrized double amplitudes
  function get_u(t2) result(u)

    implicit none
    type(array4), intent(inout) :: t2
    type(array4) :: u
    integer, dimension(4) :: dims
    integer :: a,i,b,j

    dims = t2%dims

#ifdef EXTRA_SIMPLE

    u = array4_init(dims)

    do j=1,dims(4)
       do b=1,dims(3)
          do i=1,dims(2)
             do a=1,dims(1)

                u%val(a,i,b,j) = 2.0E0_realk*t2%val(a,i,b,j) - t2%val(a,j,b,i)

             end do
          end do
       end do
    end do

#else

    u = array4_duplicate(t2)
    call array4_scale(u,2.0E0_realk)
    call array4_reorder(t2,[1,4,3,2])
    call array4_add_to(u,-1.0E0_realk,t2)
    call array4_reorder(t2,[1,4,3,2])

#endif

    return
  end function get_u

  !> \brief Print header and info about coupled-cluster job
  !> \author Marcin Ziolkowski
  !> \param ccPrintLevel Print level
  !> \param framgment_job Fragment job
  !> \param nbasis Number of basis functions
  !> \param nocc Number of occupied orbitals
  !> \param nvirt Number of unoccupied orbitals
  subroutine print_ccjob_header(ccmodel,ccPrintLevel,fj,multiplier_job,&
  &nbasis,nocc,nvirt,maxsub)
    implicit none
    integer, intent(in) :: ccmodel,ccPrintLevel,nbasis,nocc,nvirt,maxsub
    logical, intent(in) :: fj,multiplier_job

    if(ccPrintLevel > 0) then
       if(.not.fj) then
          if(multiplier_job)then
             write(DECinfo%output,'(/,a)') '-------------------------------'
             write(DECinfo%output,'(a)')   '  Coupled-cluster multipliers  '
             write(DECinfo%output,'(a,/)') '-------------------------------'
          else
             write(DECinfo%output,'(/,a)') '--------------------------'
             write(DECinfo%output,'(a)')   '  Coupled-cluster energy  '
             write(DECinfo%output,'(a,/)') '--------------------------'
          endif
          if(DECinfo%CCDhack)then
            write(DECinfo%output,'(a,a)')      'Wave function    = ','CCD'
          else
            write(DECinfo%output,'(a,a)')      'Wave function    = ',DECinfo%cc_models(ccModel)
          endif
          write(DECinfo%output,'(a,i4)')     'MaxIter          = ',DECinfo%ccMaxIter
          write(DECinfo%output,'(a,i4)')     'Num. b.f.        = ',nbasis
          write(DECinfo%output,'(a,i4)')     'Num. occ. orb.   = ',nocc
          write(DECinfo%output,'(a,i4)')     'Num. unocc. orb. = ',nvirt
          write(DECinfo%output,'(a,e8.1e2)') 'Convergence      = ',DECinfo%ccConvergenceThreshold
          write(DECinfo%output,'(a,l1)')     'Debug routine    = ',DECinfo%CCDEBUG
          write(DECinfo%output,'(a,l1)')     'Debug mode       = ',DECinfo%cc_driver_debug
          write(DECinfo%output,'(a,i4)')     'Print level      = ',ccPrintLevel
          write(DECinfo%output,'(a,l1)')     'Use CROP         = ',DECinfo%use_crop
          write(DECinfo%output,'(a,i4)')     'CROP subspace    = ',maxsub
          write(DECinfo%output,'(a,l1)')     'Preconditioner   = ',DECinfo%use_preconditioner
          write(DECinfo%output,'(a,l1)')     'Precond. B       = ',DECinfo%use_preconditioner_in_b
          write(DECinfo%output,'(a,l1)')     'Singles          = ',DECinfo%use_singles
       else
          write(DECinfo%output,'(/,a)') '  Coupled-cluster energy  -> Fragment job '
          write(DECinfo%output,'(a)')   '------------------------------------------'
          if(DECinfo%CCDhack)then
            write(DECinfo%output,'(a,a)')      'Wave function    = ','CCD'
          else
            write(DECinfo%output,'(a,a)')      'Wave function    = ',DECinfo%cc_models(ccModel)
          endif
          write(DECinfo%output,'(4x,a,l1)')     'Debug mode       = ',DECinfo%cc_driver_debug
          write(DECinfo%output,'(a,i4,$)')      'MaxIter          = ',DECinfo%ccMaxIter
          write(DECinfo%output,'(5x,a,e8.1e2)') 'Convergence      = ',DECinfo%ccConvergenceThreshold
          write(DECinfo%output,'(a,i4,$)')      'Num. b.f.        = ',nbasis
          write(DECinfo%output,'(5x,a,i4)')     'Print level      = ',ccPrintLevel
          write(DECinfo%output,'(a,i4,$)')      'Num. occ. orb.   = ',nocc
          write(DECinfo%output,'(5x,a,i4)')     'CROP subspace    = ',DECinfo%ccMaxDIIS
          write(DECinfo%output,'(a,i4,$)')      'Num. unocc. orb. = ',nvirt
          write(DECinfo%output,'(5x,a,l1)')     'Preconditioner   = ',DECinfo%use_preconditioner
       end if

       ! cc parameters
       !if(ccPrintLevel > 0) then
       !   if(fj) then
       !      write(DECinfo%output,'(/,a,a)') &
       !           '----  -------------   -------------   -------------   -------------   -------------     ------'
       !      write(DECinfo%output,'(a,a)') &
       !           'Iter   1norm(S)        1norm(D)        2norm(S+D)      Targ-N(S+D)     Targ-energy       time  '
       !      write(DECinfo%output,'(a,a)') &
       !           '----  -------------   -------------   -------------   -------------   -------------     ------'
       !   else
       !      write(DECinfo%output,'(/,a,a)') &
       !           '----  -------------   -------------   -------------   -------------   -------------     ------'
       !      write(DECinfo%output,'(a,a)') &
       !           'Iter   1norm(S)        1norm(D)        1norm(S+D)      2norm(S+D)      energy            time  '
       !      write(DECinfo%output,'(a,a)') &
       !           '----  -------------   -------------   -------------   -------------   -------------     ------'
       !   end if
       !end if
    end if

    if(.not.fj.or.DECinfo%PL>1)then
       if(.not.multiplier_job)then
         print *
         print *, '### Starting CC iterations'
         print *, '### ----------------------'
         print '(1X,a)',  '###  Iteration     Residual norm          CC energy'

         write(DECinfo%output,*)
         write(DECinfo%output,*) '### Starting CC iterations'
         write(DECinfo%output,*) '### ----------------------'
         write(DECinfo%output,'(1X,a)')  '###  Iteration     Residual norm          CC energy'
       else
         print *
         print *, '### Starting  Lagrangian iterations'
         print *, '### -------------------------------'
         print '(1X,a)',  '###  Iteration     Residual norm'

         write(DECinfo%output,*)
         write(DECinfo%output,*) '### Starting Lagrangian iterations'
         write(DECinfo%output,*) '### ------------------------------'
         write(DECinfo%output,'(1X,a)')  '###  Iteration     Residual norm'
       endif
    endif
     
  end subroutine print_ccjob_header


  !it = iteration number
  !norm = norm of the total residual
  !ce = correlation energy
  !gm = multipliers yes or no?
  !fj = fragment job?
  subroutine print_ccjob_iterinfo(it,norm,ce,gm,fj)
    implicit none
    integer,intent(in)     :: it
    real(realk),intent(in) :: norm,ce
    logical, intent(in)    :: gm,fj
    if( .not. fj .or. DECinfo%PL>1 )then
       if( gm ) then
         print '(1X,a,2X,i4,5X,g19.9,4X)',  '### ',it, norm
         write(DECinfo%output,'(1X,a,2X,i4,5X,g19.9,4X)') &
            &   '### ',it, norm
       else
         print '(1X,a,2X,i4,5X,g19.9,4X,g19.9)',  '### ',it, norm,ce
         write(DECinfo%output,'(1X,a,2X,i4,5X,g19.9,4X,g19.9)') &
            &   '### ',it, norm,ce
       endif
    endif
    
  end subroutine print_ccjob_iterinfo
  


  ! bi is the logical for break_iterations => success of the crop procedure
  ! gm is the logical for get_mult(ipliers) => ccequations vs left-hand
  ! transformations
  ! fj is the logical for fragment_job => fj or not fj, that is the question
  ! li is the number of the last iteration
  ! ce is the correlation energy
  ! t* are timings
  subroutine print_ccjob_summary(bi,gm,fj,li,ce,tew,tsw,tec,tsc,t1,t2)
    implicit none
    logical, intent(in)        :: bi,gm,fj
    integer, intent(in)        :: li
    real(realk), intent(in)    :: ce,tew,tsw,tec,tsc
    type(array2),intent(inout) :: t1
    type(array4),intent(inout) :: t2
    real(realk) :: snorm,dnorm,tnorm
     call print_norm(t1,snorm,.true.)
     call print_norm(t2,dnorm,.true.)
     tnorm = sqrt(snorm+dnorm)
     snorm = sqrt(snorm)
     dnorm = sqrt(dnorm)
     if( .not. fj .or. DECinfo%PL>1)then
       write(DECinfo%output,*)
       write(DECinfo%output,'(/,a)') '-------------------------------'
       write(DECinfo%output,'(a)')   '  Coupled-cluster job summary  '
       write(DECinfo%output,'(a,/)') '-------------------------------'
       if(bi) then
          if(gm)then
            write(DECinfo%output,'(a)')     'Yeeehaw! left-transformations converged!'
          else
            write(DECinfo%output,'(a)')     'Hooray! CC equation is solved!'
          endif
       else
          write(DECinfo%output,'(a,i4,a)')  'Equation not solved in ', &
               & DECinfo%ccMaxIter, ' iterations!'
          call lsquit('CC equation not solved!',DECinfo%output)
       end if
       write(DECinfo%output,'(a,f16.3,a)') 'CCSOL: Total cpu time    = ',tec-tsc,' s'
       write(DECinfo%output,'(a,f16.3,a)') 'CCSOL: Total wall time   = ',tew-tsw,' s'

       if(fj) then
          write(DECinfo%output,'(a,f16.10)')  'Frag. corr. energy = ',ce
       else
          if(gm)then
            if(DECinfo%use_singles)then
              write(DECinfo%output,'(a,f16.10)')  'Singles multiplier norm  = ',snorm
            endif
            write(DECinfo%output,'(a,f16.10)')  'Doubles multiplier norm  = ',dnorm
            write(DECinfo%output,'(a,f16.10)')  'Total multiplier norm    = ',tnorm
          else
            if(DECinfo%use_singles)then
              write(DECinfo%output,'(a,f16.10)')  'Singles amplitudes norm  = ',snorm
            endif
            write(DECinfo%output,'(a,f16.10)')  'Doubles amplitudes norm  = ',dnorm
            write(DECinfo%output,'(a,f16.10)')  'Total amplitudes norm    = ',tnorm
            write(DECinfo%output,'(a,f16.10)')  'Corr. energy             = ',ce
          endif
       end if
       write(DECinfo%output,'(a,i5)') 'Number of CC iterations  =', li
     else
       print '(1X,a,2X,i4,5X,g19.9,4X,g19.9)', 'converged cc fragment job',li,tnorm,ce
     endif
  end subroutine print_ccjob_summary

  !> \brief: transform ccsd_doubles, ccsdpt_singles and ccsdpt_doubles from canonical to local basis
  !> \author: Patrick Ettenhuber adapted from Janus Juul Eriksen
  !> \date: April 2013
  !> \param: t2, gvovo, t1, no and nv are nocc and nvirt, respectively, 
  !<         and U_occ and U_virt are unitary matrices from canonical --> local basis
  subroutine ccsolver_can_local_trans(no,nv,nb,Uocc,Uvirt,gvovo,t2,t1,Co,Cv)

    implicit none
    !> integers
    integer, intent(in) :: no, nv, nb
    !> ccsd_doubles and ccsdpt_doubles
    real(realk), intent(inout),optional :: t2(nv*nv*no*no), gvovo(nv*nv*no*no)
    real(realk), intent(inout),optional :: Co(nb*no), Cv(nb*nv)
    !> unitary transformation matrices - indices: (local,semi-canonical)
    real(realk), intent(inout) :: Uocc(no*no), Uvirt(nv*nv)
    !> ccsdpt_singles
    real(realk), intent(inout),optional :: t1(nv*no)
    !> temp array2 and array4 structures
    real(realk),pointer :: tmp(:)

    call mem_alloc(tmp,max(nv*nv*no*no,nb*max(no,nv)))

    ! (a,i,b,j) are local basis indices and (A,I,B,J) refer to the canonical basis.
    ! on input t2 and gvovo are ordered AIBJ and t1 AI

    if(present(t2)) call successive_xyxy_trafo(nv,no,t2,Uvirt,Uocc,tmp)

    !successive transformation of gvovo:
    if(present(gvovo)) call successive_xyxy_trafo(nv,no,gvovo,Uvirt,Uocc,tmp)

    !if t1 trafo has to be done as well
    if(present(t1))then
      !U(a,A) t(AI)    -> t(aI)
      call dgemm('n','n',nv,no,nv,1.0E0_realk,Uvirt,nv,t1,nv,0.0E0_realk,tmp,nv)
      ! tmp(aI) U(i,I)^T   -> t(ai)
      call dgemm('n','t',nv,no,no,1.0E0_realk,tmp,nv,Uocc,no,0.0E0_realk,t1,nv)
    endif

    if(present(Co))then
      tmp = Co
      ! tmp(alpha,I) U(i,I)^T   -> Co(alpha,i)
      call dgemm('n','t',nb,no,no,1.0E0_realk,tmp,nb,Uocc,no,0.0E0_realk,Co,nb)
    endif

    if(present(Cv))then
      tmp = Cv
      ! tmp(alpha,A) U(a,A)^T   -> Cv(alpha,a)
      call dgemm('n','t',nb,nv,nv,1.0E0_realk,tmp,nb,Uvirt,nv,0.0E0_realk,Cv,nb)
    endif

    call mem_dealloc(tmp)
  end subroutine ccsolver_can_local_trans

  subroutine ccsolver_local_can_trans(no,nv,nb,Uocc,Uvirt,gvovo,t2,t1,Co,Cv)

    implicit none
    !> integers
    integer, intent(in) :: no, nv, nb
    !> ccsd_doubles and ccsdpt_doubles
    real(realk), intent(inout),optional :: t2(nv*nv*no*no), gvovo(nv*nv*no*no)
    real(realk), intent(inout),optional :: Co(nb*no), Cv(nb*nv)
    !> unitary transformation matrices
    !> unitary transformation matrices - indices: (local,semi-canonical)
    real(realk), intent(inout) :: Uocc(no*no), Uvirt(nv*nv)
    real(realk) :: UoccT(no*no), UvirtT(nv*nv)
    !> ccsdpt_singles
    real(realk), intent(inout),optional :: t1(nv*no)
    !> temp array2 and array4 structures
    real(realk),pointer :: tmp(:)

    call mat_transpose(no,no,1.0E0_realk,Uocc,0.0E0_realk,UoccT)
    call mat_transpose(nv,nv,1.0E0_realk,Uvirt,0.0E0_realk,UvirtT)
    call mem_alloc(tmp,max(nv*nv*no*no,nb*max(no,nv)))

    ! (a,i,b,j) are local basis indices and (A,I,B,J) refer to the canonical basis.
    ! on input t2 and gvovo are ordered AIBJ and t1 AI

    if(present(t2))call successive_xyxy_trafo(nv,no,t2,UvirtT,UoccT,tmp)

    !successive transformation of gvovo:
    if(present(gvovo))call successive_xyxy_trafo(nv,no,gvovo,UvirtT,UoccT,tmp)

    !if t1 trafo has to be done as well
    if(present(t1))then
      !U(a,A) t(AI)    -> t(aI)
      call dgemm('n','n',nv,no,nv,1.0E0_realk,UvirtT,nv,t1,nv,0.0E0_realk,tmp,nv)
      ! tmp(aI) U(i,I)^T   -> t(ai)
      call dgemm('n','n',nv,no,no,1.0E0_realk,tmp,nv,Uocc,no,0.0E0_realk,t1,nv)
    endif
    if(present(Co))then
      tmp = Co
      ! tmp(alpha,i) U(i,I)   -> Co(alpha,I)
      call dgemm('n','n',nb,no,no,1.0E0_realk,tmp,nb,Uocc,no,0.0E0_realk,Co,nb)
    endif

    if(present(Cv))then
      tmp = Cv
      ! tmp(alpha,a) U(a,A)   -> Cv(alpha,A)
      call dgemm('n','t',nb,nv,nv,1.0E0_realk,tmp,nb,Uvirt,nv,0.0E0_realk,Cv,nb)
    endif

    call mem_dealloc(tmp)
  end subroutine ccsolver_local_can_trans

  subroutine successive_xyxy_trafo(x,y,XYXY,XX,YY,WRKYXYX)
    implicit none
    integer, intent(in) :: x,y
    real(realk), intent(inout) :: XYXY(x*y*x*y),WRKYXYX(y*x*y*x)
    real(realk), intent(in) :: XX(x,x),YY(y,y)
    !XYXY(X,YXY)^T XX(x,X)^T   -> WRKYXYX (YXY,x)
    call dgemm('t','t',x*y*y,x,x,1.0E0_realk,XYXY,x,XX,x,0.0E0_realk,WRKYXYX,x*y*y)
    ! WRKYXYX(Y,XYx)^T YY(y,Y)^T   -> XYXY (XYx,y)
    call dgemm('t','t',x*x*y,y,y,1.0E0_realk,WRKYXYX,y,YY,y,0.0E0_realk,XYXY,x*x*y)
    ! XYXY(X,Yxy)^T XX(x,X)^T   -> WRKYXYX (Yxy,x)
    call dgemm('t','t',x*y*y,x,x,1.0E0_realk,XYXY,x,XX,x,0.0E0_realk,WRKYXYX,x*y*y)
    ! WRKYXYX(Y,xyx)^T YY(y,Y)^T   -> XYXY (xyxy)
    call dgemm('t','t',x*x*y,y,y,1.0E0_realk,WRKYXYX,y,YY,y,0.0E0_realk,XYXY,x*x*y)
  end subroutine successive_xyxy_trafo
end module crop_tools_module
