  !> \brief CCSD(T) is supposed to be evaluated here in full molecular dummy code!
  !> \authors Janus Juul Eriksen
  !> \date May/June 2012
  subroutine full_ccsd_parenthesisT(MyMolecule,MyLsitem,energy)


    implicit none

    !> Full molecule info
    type(fullmolecule), intent(in) :: MyMolecule
!    type(fullmolecule), intent(in) :: MyMolecule
    !> Lsitem structure
    type(lsitem), intent(inout) :: mylsitem
    !> Correlation energy
    real(realk), intent(inout) :: energy
    real(realk), pointer :: gao(:,:,:,:)
    real(realk), pointer :: AIBJ(:,:,:,:)
    real(realk), pointer :: AIBC(:,:,:,:)
    real(realk), pointer :: AIJK(:,:,:,:)
    real(realk) :: ECCSD, Ttmp, Gtmp
    real(realk) :: etot1, etot2, etot3
    real(realk) :: astta1, astta2, astta3, astta4, astta5, astta6
    real(realk) :: asttb1, asttb2, asttb3, asttb4, asttb5, asttb6
    real(realk) :: asttc1, asttc2, asttc3, asttc4, asttc5, asttc6
    real(realk) :: asttd1, asttd2, asttd3, asttd4, asttd5, asttd6
    real(realk) :: astte1, astte2, astte3, astte4, astte5, astte6
    real(realk) :: asttf1, asttf2, asttf3, asttf4, asttf5, asttf6
    real(realk) :: asttatmp11, asttatmp12, asttatmp13, asttatmp14, asttatmp15, asttatmp16
    real(realk) :: asttatmp21, asttatmp22, asttatmp23, asttatmp24, asttatmp25, asttatmp26
    real(realk) :: asttbtmp11, asttbtmp12, asttbtmp13, asttbtmp14, asttbtmp15, asttbtmp16
    real(realk) :: asttbtmp21, asttbtmp22, asttbtmp23, asttbtmp24, asttbtmp25, asttbtmp26
    real(realk) :: asttctmp11, asttctmp12, asttctmp13, asttctmp14, asttctmp15, asttctmp16
    real(realk) :: asttctmp21, asttctmp22, asttctmp23, asttctmp24, asttctmp25, asttctmp26
    real(realk) :: asttdtmp11, asttdtmp12, asttdtmp13, asttdtmp14, asttdtmp15, asttdtmp16
    real(realk) :: asttdtmp21, asttdtmp22, asttdtmp23, asttdtmp24, asttdtmp25, asttdtmp26
    real(realk) :: asttetmp11, asttetmp12, asttetmp13, asttetmp14, asttetmp15, asttetmp16
    real(realk) :: asttetmp21, asttetmp22, asttetmp23, asttetmp24, asttetmp25, asttetmp26
    real(realk) :: asttftmp11, asttftmp12, asttftmp13, asttftmp14, asttftmp15, asttftmp16
    real(realk) :: asttftmp21, asttftmp22, asttftmp23, asttftmp24, asttftmp25, asttftmp26
    real(realk) :: ECCSDocc_single, ECCSDocc_pair, ECCSDvirt_single, ECCSDvirt_pair
    real(realk) :: EpT1_pair
    real(realk) :: EpT2occ_single, EpT2occ_pair, EpT2virt_single, EpT2virt_pair
    real(realk) :: EpT2occ_single_test, EpT2occ_pair_test
    real(realk) :: ECCSDocc, ECCSDvirt, EpTocc, EpTvirt
    real(realk), pointer :: EpT11(:,:), EpT12(:,:), EpT13(:,:), EpT14(:,:), EpT15(:,:), EpT16(:,:)
    real(realk), pointer :: EpT17(:,:), EpT18(:,:), EpT19(:,:), EpT110(:,:), EpT111(:,:), EpT112(:,:)
    real(realk), pointer :: EpT211(:,:), EpT212(:,:), EpT213(:,:), EpT214(:,:), EpT215(:,:), EpT216(:,:)
    real(realk), pointer :: EpT217(:,:), EpT218(:,:), EpT219(:,:), EpT2110(:,:), EpT2111(:,:), EpT2112(:,:)
    real(realk), pointer :: EpT221(:,:), EpT222(:,:), EpT223(:,:), EpT224(:,:), EpT225(:,:), EpT226(:,:)
    real(realk), pointer :: EpT227(:,:), EpT228(:,:), EpT229(:,:), EpT2210(:,:)
    real(realk), pointer :: EpT2211(:,:), EpT2212(:,:), EpTtest(:,:)
    integer :: ncabs, ncabsAO, nocc,nvirt,nbasis,noccfull, i,j,k,l,a,b,c,d,e,m,p
    type(array2) :: Tai
    type(array4) :: Taibj
    type(array4) :: AIBJ_tmp, AIBC_tmp, AIJK_tmp
    real(realk), pointer :: Cocc_data(:,:), Cvirt_data(:,:), Socc(:,:), Svirt(:,:)
    real(realk), pointer :: eivalocc(:), eivalvirt(:)
    type(array2) :: Cocc, Cvirt
    integer, dimension(4) :: dims_aiai, dims_iaai
    integer, dimension(4) :: dims_aiaa, dims_iaaa, dims_aaai
    integer, dimension(4) :: dims_aiii, dims_iaii, dims_iiai
    integer, dimension(2) :: occdims, virtdims, virtoccdims
    type(array4) :: canAIBJ, canAIBC, canAIJK, canTaibj
    type(array4) :: tmp11, tmp12, tmp13, tmp14, tmp15, tmp16
    type(array4) :: tmp17, tmp18, tmp19, tmp110, tmp111, tmp112
    type(array4) :: tmp113, tmp114, tmp115, tmp116, tmp117, tmp118
    type(array4) :: tmp119, tmp120, tmp121, tmp122, tmp123, tmp124
    type(array4) :: tmp21, tmp22, tmp23, tmp24, tmp25, tmp26
    type(array4) :: tmp27, tmp28, tmp29, tmp210, tmp211, tmp212
    type(array4) :: tmp213, tmp214, tmp215, tmp216, tmp217, tmp218
    type(array4) :: tmp219, tmp220, tmp221, tmp222, tmp223, tmp224, tmptest1, tmptest2
    type(array2) :: canTai_tmp, canTai
    type(array2) :: tmp01, tmp02, tmp03, tmp04, tmp05, tmp06
    type(array2) :: tmp07, tmp08, tmp09, tmp010, tmp011, tmp012
    type(array2) :: astT11, astT12, astT13, astT14, astT15, astT16
    type(array2) :: astT21, astT22, astT23, astT24, astT25, astT26
    type(array4) :: astT31, astT32, astT33, astT34, astT35, astT36
    type(array4) :: astT41, astT42, astT43, astT44, astT45, astT46
    type(array4) :: astT51, astT52, astT53, astT54, astT55, astT56
    type(array4) :: astT61, astT62, astT63, astT64, astT65, astT66, astTtest
    type(ccorbital), pointer :: OccOrbitals(:)
    type(ccorbital), pointer :: UnoccOrbitals(:)
    real(realk), pointer :: DistanceTable(:,:), energy_matrix_ccsd(:,:), energy_matrix_1(:,:), energy_matrix_2(:,:)
    real(realk), pointer :: energy_matrix_2_test(:,:)
    integer :: AtomA, AtomB, AtomI, AtomJ, my_atom, numatoms, pdx,start,end
    logical, pointer :: orbitals_assigned(:)
    real(realk) :: astTtest2

    print *, 'Entering *OLD* CCSD(T) toy code'

    ! Init dimensions
    if(DECinfo%FrozenCore) then
       nocc = MyMolecule%nval
       start = MyMolecule%ncore+1  
    else
       nocc = MyMolecule%numocc
       start = 1
    end if
    end = MyMolecule%numocc
    nvirt = MyMolecule%numvirt
    nbasis = MyMolecule%nbasis
    numatoms = MyMolecule%natoms
    noccfull = MyMolecule%numocc


    call determine_CABS_nbast(ncabsAO,ncabs,mylsitem%setting,DECinfo%output)

    ! Get full CCSD singles (Tai) and doubles (Taibj) amplitudes
    call full_get_ccsd_singles_and_doubles(MyMolecule,MyLsitem,Tai,Taibj)

    ! Get all AO integrals in regular basis
    call mem_alloc(gao,nbasis,nbasis,nbasis,nbasis)
    gao = 0.0E0_realk
    call get_full_AO_integrals(nbasis,ncabsAO,gao,MyLsitem,'RRRRC')

    ! Transform AO integrals to MO integrals (A I | B J)
    call get_4Center_MO_integrals(mylsitem,DECinfo%output,nbasis,nocc,noccfull,nvirt,&
         & MyMolecule%ypo(1:nbasis,start:end), MyMolecule%ypv,'aiai',gAO,AIBJ)
    ! Transform AO integrals to MO integrals (A I | B C)
    ! equal to (I A | B C), that is, iaaa, and (B C | I A), i.e., aaia
    call get_4Center_MO_integrals(mylsitem,DECinfo%output,nbasis,nocc,noccfull,nvirt,&
         & MyMolecule%ypo(1:nbasis,start:end), MyMolecule%ypv,'aiaa',gAO,AIBC)
    ! Transform AO integrals to MO integrals (A I | J K)
    ! equal to (J K | I A), that is, iiia, and (J K | A I), i.e., iiai
    call get_4Center_MO_integrals(mylsitem,DECinfo%output,nbasis,nocc,noccfull,nvirt,&
         & MyMolecule%ypo(1:nbasis,start:end), MyMolecule%ypv,'aiii',gAO,AIJK)

    ! For locality analysis purposes we need DistanceTable and OccOrbitals/
    ! UnoccOrbitals (adapted from fragment_energy.f90)

    ! -- Calculate distance matrix
    call mem_alloc(DistanceTable,numatoms,numatoms)
    DistanceTable=0.0E0_realk
    call GetDistances(DistanceTable,numatoms,mylsitem,DECinfo%output) ! distances in atomic units

    ! -- Analyze basis and create orbitals
    call mem_alloc(OccOrbitals,nocc)
    call mem_alloc(UnoccOrbitals,nvirt)
    call GenerateOrbitals_driver(MyMolecule,mylsitem,nocc,nvirt,numatoms, &
         & OccOrbitals, UnoccOrbitals, DistanceTable)

    ! Orbital assignment
    call mem_alloc(orbitals_assigned,numatoms)
    orbitals_assigned=.false.
    do p=1,nocc
       pdx = OccOrbitals(p)%centralatom
       orbitals_assigned(pdx) = .true.
    end do
    do p=1,nvirt
       pdx = UnoccOrbitals(p)%centralatom
       orbitals_assigned(pdx) = .true.
    end do


    ! Calculate standard CCSD energy (brainless summation in this test code)
    ! Energy = sum_{ijab} [ Tai*Tbj + Taibj ] * [ 2*(ai | bj) - (bi | aj) ]

    ! First, we calculate the CCSD corr. energy in the occupied partitioning scheme

    call mem_alloc(energy_matrix_ccsd,numatoms,numatoms)
    energy_matrix_ccsd = 0.0E0_realk

    do i=1,nocc
    AtomI = OccOrbitals(i)%CentralAtom
       do j=1,nocc
       AtomJ = OccOrbitals(j)%CentralAtom
          do a=1,nvirt
             do b=1,nvirt
                energy_matrix_ccsd(AtomI,AtomJ) = energy_matrix_ccsd(AtomI,AtomJ) &
                                              & + (Tai%val(a,i) * Tai%val(b,j) + Taibj%val(a,i,b,j)) &
                                              & * (2.0E0_realk * AIBJ(a,i,b,j) - AIBJ(b,i,a,j))
             end do
          end do
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,'(1X,a)') '*          Full DEC CCSD calculation is done (occ. part. scheme)!           *'
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Atomic fragments [ECCSD]'
    write(DECinfo%output,'(8X,a)') '------    --------------------'
    write(DECinfo%output,'(8X,a)') ' Atom            Energy '
    write(DECinfo%output,'(8X,a)') '------    --------------------'


    ECCSDocc_single = 0.0E0_realk
    do i=1,numatoms
       if(orbitals_assigned(i)) then
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#SING#', i, energy_matrix_ccsd(i,i)
          ECCSDocc_single = ECCSDocc_single + energy_matrix_ccsd(i,i)
       end if
    end do

    ! Total pair fragment energy matrix
    ! Only consider pairs IJ where J>I; thus, move contributions

    do AtomI=1,numatoms
       do AtomJ=AtomI+1,numatoms
          energy_matrix_ccsd(AtomI,AtomJ) = energy_matrix_ccsd(AtomI,AtomJ) + energy_matrix_ccsd(AtomJ,AtomI)
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Pair fragments [ECCSD]'
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'
    write(DECinfo%output,'(8X,a)') '   P         Q        R(Ang)           deltaE(PQ) '
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'

    ECCSDocc_pair = 0.0E0_realk
    do i=1,numatoms
       do j=i+1,numatoms
          ! write increments only if pair interaction energy is nonzero
          if( orbitals_assigned(i) .and. orbitals_assigned(j) ) then
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#PAIR#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), energy_matrix_ccsd(i,j)
             ECCSDocc_pair = ECCSDocc_pair + energy_matrix_ccsd(i,j)
          end if
       end do
    end do

    call mem_dealloc(energy_matrix_ccsd)

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Atomic fragment energy [ECCSD]   = ', ECCSDocc_single
    write(DECinfo%output,'(1X,a,g20.10)') 'Pair atomic fragment en. [ECCSD] = ', ECCSDocc_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'Total CCSD corr. energy [ECCSD]  = ', ECCSDocc_single + ECCSDocc_pair
    write(DECinfo%output,'(1X,a)')

    ! Next, we calculate the CCSD corr. energy in the unoccupied partitioning scheme

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,'(1X,a)') '*         Full DEC CCSD calculation is done (unocc. part. scheme)!          *'
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Atomic fragments [ECCSD]'
    write(DECinfo%output,'(8X,a)') '------    --------------------'
    write(DECinfo%output,'(8X,a)') ' Atom            Energy '
    write(DECinfo%output,'(8X,a)') '------    --------------------'

    call mem_alloc(energy_matrix_ccsd,numatoms,numatoms)
    energy_matrix_ccsd = 0.0E0_realk

    do a=1,nvirt
    AtomA = UnoccOrbitals(a)%CentralAtom
       do b=1,nvirt
       AtomB = UnoccOrbitals(b)%CentralAtom
          do i=1,nocc
             do j=1,nocc
                energy_matrix_ccsd(AtomA,AtomB) = energy_matrix_ccsd(AtomA,AtomB) &
                                              & + (Tai%val(a,i) * Tai%val(b,j) + Taibj%val(a,i,b,j)) &
                                              & * (2.0E0_realk * AIBJ(a,i,b,j) - AIBJ(b,i,a,j))
             end do
          end do
       end do
    end do

    ECCSDvirt_single = 0.0E0_realk
    do i=1,numatoms
       if(orbitals_assigned(i)) then
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#SING#', i, energy_matrix_ccsd(i,i)
          ECCSDvirt_single = ECCSDvirt_single + energy_matrix_ccsd(i,i)
       end if
    end do

    ! Total pair fragment energy matrix
    ! Only consider pairs IJ where J>I; thus, move contributions
    do AtomA=1,numatoms
       do AtomB=AtomA+1,numatoms
          energy_matrix_ccsd(AtomA,AtomB) = energy_matrix_ccsd(AtomA,AtomB) + energy_matrix_ccsd(AtomB,AtomA)
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Pair fragments [ECCSD]'
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'
    write(DECinfo%output,'(8X,a)') '   P         Q        R(Ang)           deltaE(PQ) '
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'

    ECCSDvirt_pair = 0.0E0_realk
    do i=1,numatoms
       do j=i+1,numatoms
          ! write increments only if pair interaction energy is nonzero
          if( orbitals_assigned(i) .and. orbitals_assigned(j) ) then
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#PAIR#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), energy_matrix_ccsd(i,j)
             ECCSDvirt_pair = ECCSDvirt_pair + energy_matrix_ccsd(i,j)
          end if
       end do
    end do

    call mem_dealloc(energy_matrix_ccsd)

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Atomic fragment energy [ECCSD]   = ', ECCSDvirt_single
    write(DECinfo%output,'(1X,a,g20.10)') 'Pair atomic fragment en. [ECCSD] = ', ECCSDvirt_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'Total CCSD corr. energy [ECCSD]  = ', ECCSDvirt_single + ECCSDvirt_pair
    write(DECinfo%output,'(1X,a)')

    ! With the CCSD part finished, we move on to the CCSD(T) part

    ! In order to calculate the perturbed triples amplitudes, we need to transform the above
    ! 2-el integral and doubles amplitude quantities into canonical basis.
    ! We end the transformation section by transposing the eigenvectors as we will need to
    ! transform back into local basis when we want to perform our locality analyses.
    !
    ! Transformation stuff adpated from cc_driver.f90 and appropriately modified

    call mem_alloc(Socc,nocc,nocc)
    call mem_alloc(Svirt,nvirt,nvirt)
    call mem_alloc(Cocc_data,nocc,nocc)
    call mem_alloc(Cvirt_data,nvirt,nvirt)
    call mem_alloc(eivalocc,nocc)
    call mem_alloc(eivalvirt,nvirt)

    ! Initialize stuff pt. 1
    ! ****************
    occdims = [nocc,nocc]
    virtdims = [nvirt,nvirt]
    virtoccdims = [nvirt,nocc]

    ! make occ-occ and virt-virt identity matrices

    Socc=0.0E0_realk
    do i=1,nocc
       Socc(i,i) = 1.0E0_realk
    end do
    Svirt=0.0E0_realk
    do j=1,nvirt
       Svirt(j,j) = 1.0E0_realk
    end do

    ! solve for eivals and C matrices

    call solve_eigenvalue_problem(nocc,MyMolecule%ppfock(start:end,start:end),Socc,eivalocc,Cocc_data)
    call solve_eigenvalue_problem(nvirt,MyMolecule%qqfock,Svirt,eivalvirt,Cvirt_data)

    Cocc = array2_init_data(occdims,Cocc_data)
    Cvirt = array2_init_data(virtdims,Cvirt_data)

    call mem_dealloc(Socc)
    call mem_dealloc(Svirt)
    call mem_dealloc(Cocc_data)
    call mem_dealloc(Cvirt_data)

    ! Transform two-electron integrals, singles and doubles amplitudes to diagonal basis
    ! *****************************************************

    ! Using notation that (a,i,b,j) are LCM indices
    ! and (A,I,B,J) are indices in the diagonal basis,
    ! we want to carry out the transformations (for 2-el integrals):
    ! RHS_{AIBJ} = sum_{aibj} C_{aA} C_{iI} C_{bB} C_{jJ} RHS_{aibj} (*)

    ! Transform doubles amplitudes and the three kinds of 2-el integrals

    ! Initialize stuff
    ! ****************
    dims_aiai = [nvirt,nocc,nvirt,nocc]
    dims_iaai = [nocc,nvirt,nvirt,nocc]
    dims_aiaa = [nvirt,nocc,nvirt,nvirt]
    dims_iaaa = [nocc,nvirt,nvirt,nvirt]
    dims_aaai = [nvirt,nvirt,nvirt,nocc]
    dims_aiii = [nvirt,nocc,nocc,nocc]
    dims_iaii = [nocc,nvirt,nocc,nocc]
    dims_iiai = [nocc,nocc,nvirt,nocc]

    ! 1. Init temporary arrays
    tmp11 = array4_init_standard(dims_aiai)
    tmp12 = array4_init_standard(dims_aiaa)
    tmp13 = array4_init_standard(dims_aiii)
    tmp14 = array4_init_standard(dims_aiai)
    AIBJ_tmp = array4_init_standard(dims_aiai)
    AIBC_tmp = array4_init_standard(dims_aiaa)
    AIJK_tmp = array4_init_standard(dims_aiii)
    AIBJ_tmp%val = AIBJ
    AIBC_tmp%val = AIBC
    AIJK_tmp%val = AIJK

    ! 2. 1st index:
    ! 1. line: AIBJ(a,i,b,j) --> tmp11(A,i,b,j)
    ! 2. line: AIBC(a,i,b,c) --> tmp12(A,i,b,c,)
    ! 3. line: AIJK(a,i,j,k) --> tmp13(A,i,j,k)
    ! 4. line: Taibj(a,i,b,j) --> tmp14(A,i,b,j)
    call array4_contract1(AIBJ_tmp,Cvirt,tmp11,.true.)
    call array4_contract1(AIBC_tmp,Cvirt,tmp12,.true.)
    call array4_contract1(AIJK_tmp,Cvirt,tmp13,.true.)
    call array4_contract1(Taibj,Cvirt,tmp14,.true.)
    call array4_free(AIBJ_tmp)
    call array4_free(AIBC_tmp)
    call array4_free(AIJK_tmp)

    ! 3. 2nd index:
    ! 1. line: tmp11(A,i,b,j) --> tmp11(i,A,b,j) --> tmp21(I,A,b,j)
    ! 2. line: tmp12(A,i,b,c) --> tmp12(i,A,b,c) --> tmp22(I,A,b,c)
    ! 3. line: tmp13(A,i,j,k) --> tmp13(i,A,j,k) --> tmp23(I,A,j,k)
    ! 4. line: tmp14(A,i,b,j) --> tmp14(i,A,b,j) --> tmp24(I,A,b,j)
    call array4_reorder(tmp11,[2,1,3,4])
    call array4_reorder(tmp12,[2,1,3,4])
    call array4_reorder(tmp13,[2,1,3,4])
    call array4_reorder(tmp14,[2,1,3,4])
    tmp21 = array4_init_standard(dims_iaai)
    tmp22 = array4_init_standard(dims_iaaa)
    tmp23 = array4_init_standard(dims_iaii)
    tmp24 = array4_init_standard(dims_iaai)
    call array4_contract1(tmp11,Cocc,tmp21,.true.)
    call array4_contract1(tmp12,Cocc,tmp22,.true.)
    call array4_contract1(tmp13,Cocc,tmp23,.true.)
    call array4_contract1(tmp14,Cocc,tmp24,.true.)
    call array4_free(tmp11)
    call array4_free(tmp12)
    call array4_free(tmp13)
    call array4_free(tmp14)

    ! 4. 3rd index:
    ! 1. line: tmp21(I,A,b,j) --> tmp21(j,b,A,I) --> tmp11(J,b,A,I)
    ! 2. line: tmp22(I,A,b,c) --> tmp22(c,b,A,I) --> tmp12(C,b,A,I)
    ! 3. line: tmp23(I,A,j,k) --> tmp23(k,j,A,I) --> tmp13(K,j,A,I)
    ! 4. line; tmp24(I,A,b,j) --> tmp24(j,b,A,I) --> tmp14(J,b,A,I)
    call array4_reorder(tmp21,[4,3,2,1])
    call array4_reorder(tmp22,[4,3,2,1])
    call array4_reorder(tmp23,[4,3,2,1])
    call array4_reorder(tmp24,[4,3,2,1])
    tmp11 = array4_init_standard(dims_iaai)
    tmp12 = array4_init_standard(dims_aaai)
    tmp13 = array4_init_standard(dims_iiai)
    tmp14 = array4_init_standard(dims_iaai)
    call array4_contract1(tmp21,Cocc,tmp11,.true.)
    call array4_contract1(tmp22,Cvirt,tmp12,.true.)
    call array4_contract1(tmp23,Cocc,tmp13,.true.)
    call array4_contract1(tmp24,Cocc,tmp14,.true.)
    call array4_free(tmp21)
    call array4_free(tmp22)
    call array4_free(tmp23)
    call array4_free(tmp24)

    ! 5. 4th index:
    ! 1. line: tmp11(J,b,A,I) --> tmp11(b,J,A,I) --> canBJAI(B,J,A,I) = canAIBJ (*)
    ! 2. line: tmp12(C,b,A,I) --> tmp12(b,C,A,I) --> canBCAI(B,C,A,I) = canAIBC (**)
    ! 3. line: tmp13(K,j,A,I) --> tmp13(j,K,A,I) --> canJKAI(J,K,A,I) = canAIJK (**)
    ! 4. line: tmp14(J,b,A,I) --> tmp14(b,J,A,I) --> canTbjai(B,J,A,I) = canTaibj (*)
    ! (*) due to permutational symmetry
    ! (**) dimensions of array4 need be reordered
    call array4_reorder(tmp11,[2,1,3,4])
    call array4_reorder(tmp12,[2,1,3,4])
    call array4_reorder(tmp13,[2,1,3,4])
    call array4_reorder(tmp14,[2,1,3,4])
    canAIBJ = array4_init_standard(dims_aiai)
    canAIBC = array4_init_standard(dims_aaai)
    canAIJK = array4_init_standard(dims_iiai)
    canTaibj = array4_init_standard(dims_aiai)
    call array4_contract1(tmp11,Cvirt,canAIBJ,.true.)
    call array4_contract1(tmp12,Cvirt,canAIBC,.true.)
    call array4_contract1(tmp13,Cocc,canAIJK,.true.)
    call array4_contract1(tmp14,Cvirt,canTaibj,.true.)
    call array4_reorder(canAIBC,[3,4,1,2])
    call array4_reorder(canAIJK,[3,4,1,2])
    call array4_free(tmp11)
    call array4_free(tmp12)
    call array4_free(tmp13)
    call array4_free(tmp14)

    ! Now we transpose the eigenvectors as we will need these in the transformation
    ! of the ^{*}T^{a}_{i} and ^{*}T^{ab}_{ij} amplitudes from canonical to local basis
    ! later on
    call array2_transpose(Cocc)
    call array2_transpose(Cvirt)

    ! Begin ECCSD(T) [here: EpT] calculation

    ! *t^{abc}_{ijk} = {-1}*P^{abc}_{ijk} (6 terms - 123, 312, 231, 132, 213, 321)
    !                 x[sum_{d}[t^{ad}_{ij}*g_{ckbd}] - sum_{l}[t^{ab}_{il}*g_{cklj}]]
    !                 x[1/[e_{a} + e_{b} + e_{c} - e_{i} - e_{j} - e_{k}]]
    ! 6 (*t) terms appear in EpT expressions. these are called astta, asttb, asttc, asttd, astte, asttf
    ! 2 in ^{*}T^{a}_{i} part (a and b) and 4 in ^{*}T^{ab}_{ij} (c, d, e, and f)
    ! all of these have 6 terms, e.g., astta123, astta312, astta231,
    !                                  astta132, astta213, astta321

    ! Enter EpT1 part of CCSD(T) corr. energy
    !
    ! *T^{a}_{i} (here: astT1 and astT2) part:

    etot1 = 0.0E0_realk
    astT11 = array2_init_plain(virtoccdims); astT12 = array2_init_plain(virtoccdims)
    astT13 = array2_init_plain(virtoccdims); astT14 = array2_init_plain(virtoccdims)
    astT15 = array2_init_plain(virtoccdims); astT16 = array2_init_plain(virtoccdims)
    astT21 = array2_init_plain(virtoccdims); astT22 = array2_init_plain(virtoccdims)
    astT23 = array2_init_plain(virtoccdims); astT24 = array2_init_plain(virtoccdims)
    astT25 = array2_init_plain(virtoccdims); astT26 = array2_init_plain(virtoccdims)

    do a=1,nvirt
       do i=1,nocc
    ! astT1, astT2 loop
          do c=1,nvirt
             do d=1,nvirt
                do k=1,nocc
                   do l=1,nocc
                      astta1 = 0.0E0_realk; astta2 = 0.0E0_realk; astta3 = 0.0E0_realk
                      astta4 = 0.0E0_realk; astta5 = 0.0E0_realk; astta6 = 0.0E0_realk
                      asttb1 = 0.0E0_realk; asttb2 = 0.0E0_realk; asttb3 = 0.0E0_realk
                      asttb4 = 0.0E0_realk; asttb5 = 0.0E0_realk; asttb6 = 0.0E0_realk
                      asttatmp11 = 0.0E0_realk; asttatmp12 = 0.0E0_realk; asttatmp13 = 0.0E0_realk
                      asttatmp14 = 0.0E0_realk; asttatmp15 = 0.0E0_realk; asttatmp16 = 0.0E0_realk
                      asttbtmp11 = 0.0E0_realk; asttbtmp12 = 0.0E0_realk; asttbtmp13 = 0.0E0_realk
                      asttbtmp14 = 0.0E0_realk; asttbtmp15 = 0.0E0_realk; asttbtmp16 = 0.0E0_realk
                      do e=1,nvirt ! 'e' is a virt index
                         asttatmp11 = asttatmp11 &
                                  & + canTaibj%val(a,i,e,k) * canAIBC%val(d,l,c,e)
                         asttatmp12 = asttatmp12 &
                                  & + canTaibj%val(d,l,e,i) * canAIBC%val(c,k,a,e)
                         asttatmp13 = asttatmp13 &
                                  & + canTaibj%val(c,k,e,l) * canAIBC%val(a,i,d,e)
                         asttatmp14 = asttatmp14 &
                                  & + canTaibj%val(a,i,e,l) * canAIBC%val(c,k,d,e)
                         asttatmp15 = asttatmp15 &
                                  & + canTaibj%val(c,k,e,i) * canAIBC%val(d,l,a,e)
                         asttatmp16 = asttatmp16 &
                                  & + canTaibj%val(d,l,e,k) * canAIBC%val(a,i,c,e)
                         asttbtmp11 = asttbtmp11 &
                                  & + canTaibj%val(a,l,e,k) * canAIBC%val(d,i,c,e)
                         asttbtmp12 = asttbtmp12 &
                                  & + canTaibj%val(d,i,e,l) * canAIBC%val(c,k,a,e)
                         asttbtmp13 = asttbtmp13 &
                                  & + canTaibj%val(c,k,e,i) * canAIBC%val(a,l,d,e)
                         asttbtmp14 = asttbtmp14 &
                                  & + canTaibj%val(a,l,e,i) * canAIBC%val(c,k,d,e)
                         asttbtmp15 = asttbtmp15 &
                                  & + canTaibj%val(c,k,e,l) * canAIBC%val(d,i,a,e)
                         asttbtmp16 = asttbtmp16 &
                                  & + canTaibj%val(d,i,e,k) * canAIBC%val(a,l,c,e)
                      end do
                      asttatmp21 = 0.0E0_realk; asttatmp22 = 0.0E0_realk; asttatmp23 = 0.0E0_realk
                      asttatmp24 = 0.0E0_realk; asttatmp25 = 0.0E0_realk; asttatmp26 = 0.0E0_realk
                      asttbtmp21 = 0.0E0_realk; asttbtmp22 = 0.0E0_realk; asttbtmp23 = 0.0E0_realk
                      asttbtmp24 = 0.0E0_realk; asttbtmp25 = 0.0E0_realk; asttbtmp26 = 0.0E0_realk
                      do m=1,nocc ! 'm' is an occ index
                         asttatmp21 = asttatmp21 &
                                  & + canTaibj%val(a,i,c,m) * canAIJK%val(d,l,m,k)
                         asttatmp22 = asttatmp22 &
                                  & + canTaibj%val(d,l,a,m) * canAIJK%val(c,k,m,i)
                         asttatmp23 = asttatmp23 &
                                  & + canTaibj%val(c,k,d,m) * canAIJK%val(a,i,m,l)
                         asttatmp24 = asttatmp24 &
                                  & + canTaibj%val(a,i,d,m) * canAIJK%val(c,k,m,l)
                         asttatmp25 = asttatmp25 &
                                  & + canTaibj%val(c,k,a,m) * canAIJK%val(d,l,m,i)
                         asttatmp26 = asttatmp26 &
                                  & + canTaibj%val(d,l,c,m) * canAIJK%val(a,i,m,k)
                         asttbtmp21 = asttbtmp21 &
                                  & + canTaibj%val(a,l,c,m) * canAIJK%val(d,i,m,k)
                         asttbtmp22 = asttbtmp22 &
                                  & + canTaibj%val(d,i,a,m) * canAIJK%val(c,k,m,l)
                         asttbtmp23 = asttbtmp23 &
                                  & + canTaibj%val(c,k,d,m) * canAIJK%val(a,l,m,i)
                         asttbtmp24 = asttbtmp24 &
                                  & + canTaibj%val(a,l,d,m) * canAIJK%val(c,k,m,i)
                         asttbtmp25 = asttbtmp25 &
                                  & + canTaibj%val(c,k,a,m) * canAIJK%val(d,i,m,l)
                         asttbtmp26 = asttbtmp26 &
                                  & + canTaibj%val(d,i,c,m) * canAIJK%val(a,l,m,k)
                      end do
                      etot1 = 1.0E0_realk / (eivalvirt(a) + eivalvirt(c) + eivalvirt(d) &
                                         & - eivalocc(i) - eivalocc(k) - eivalocc(l))
                      astta1 = -1.0E0_realk * (asttatmp11 - asttatmp21) * etot1
                      astta2 = -1.0E0_realk * (asttatmp12 - asttatmp22) * etot1
                      astta3 = -1.0E0_realk * (asttatmp13 - asttatmp23) * etot1
                      astta4 = -1.0E0_realk * (asttatmp14 - asttatmp24) * etot1
                      astta5 = -1.0E0_realk * (asttatmp15 - asttatmp25) * etot1
                      astta6 = -1.0E0_realk * (asttatmp16 - asttatmp26) * etot1
                      asttb1 = -1.0E0_realk * (asttbtmp11 - asttbtmp21) * etot1
                      asttb2 = -1.0E0_realk * (asttbtmp12 - asttbtmp22) * etot1
                      asttb3 = -1.0E0_realk * (asttbtmp13 - asttbtmp23) * etot1
                      asttb4 = -1.0E0_realk * (asttbtmp14 - asttbtmp24) * etot1
                      asttb5 = -1.0E0_realk * (asttbtmp15 - asttbtmp25) * etot1
                      asttb6 = -1.0E0_realk * (asttbtmp16 - asttbtmp26) * etot1
                      astT11%val(a,i) = astT11%val(a,i) + astta1 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT12%val(a,i) = astT12%val(a,i) + astta2 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT13%val(a,i) = astT13%val(a,i) + astta3 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT14%val(a,i) = astT14%val(a,i) + astta4 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT15%val(a,i) = astT15%val(a,i) + astta5 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT16%val(a,i) = astT16%val(a,i) + astta6 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT21%val(a,i) = astT21%val(a,i) + asttb1 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT22%val(a,i) = astT22%val(a,i) + asttb2 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT23%val(a,i) = astT23%val(a,i) + asttb3 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT24%val(a,i) = astT24%val(a,i) + asttb4 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT25%val(a,i) = astT25%val(a,i) + asttb5 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                      astT26%val(a,i) = astT26%val(a,i) + asttb6 &
                                    & * (2.0E0_realk * canAIBJ%val(c,k,d,l) - canAIBJ%val(d,k,c,l))
                   end do
                end do
             end do
          end do
       end do
    end do

    ! Now we wish to transform back into local basis before we evaluate the energy (fragment
    ! and fragment pair) components.
    ! We note at this point that since the astTX array2's are written as virt-occ,
    ! we may follow the path of the Tai integrals in the initial local --> canonical transformation.

    ! 1. Init temporary array2's, tmpY

    tmp01 = array2_init_plain(virtoccdims)
    tmp02 = array2_init_plain(virtoccdims)
    tmp03 = array2_init_plain(virtoccdims)
    tmp04 = array2_init_plain(virtoccdims)
    tmp05 = array2_init_plain(virtoccdims)
    tmp06 = array2_init_plain(virtoccdims)
    tmp07 = array2_init_plain(virtoccdims)
    tmp08 = array2_init_plain(virtoccdims)
    tmp09 = array2_init_plain(virtoccdims)
    tmp010 = array2_init_plain(virtoccdims)
    tmp011 = array2_init_plain(virtoccdims)
    tmp012 = array2_init_plain(virtoccdims)

    ! astTX(a,i) --> tmpY(A,i)

    call array2_matmul(Cvirt,astT11,tmp01,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT12,tmp02,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT13,tmp03,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT14,tmp04,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT15,tmp05,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT16,tmp06,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT21,tmp07,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT22,tmp08,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT23,tmp09,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT24,tmp010,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT25,tmp011,'t','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(Cvirt,astT26,tmp012,'t','n',1.0E0_realk,0.0E0_realk)

    ! Free the initial astTX array2's

    call array2_free(astT11)
    call array2_free(astT12)
    call array2_free(astT13)
    call array2_free(astT14)
    call array2_free(astT15)
    call array2_free(astT16)
    call array2_free(astT21)
    call array2_free(astT22)
    call array2_free(astT23)
    call array2_free(astT24)
    call array2_free(astT25)
    call array2_free(astT26)

    ! Init the astTX array2's as we want to reuse these

    astT11 = array2_init_plain(virtoccdims)
    astT12 = array2_init_plain(virtoccdims)
    astT13 = array2_init_plain(virtoccdims)
    astT14 = array2_init_plain(virtoccdims)
    astT15 = array2_init_plain(virtoccdims)
    astT16 = array2_init_plain(virtoccdims)
    astT21 = array2_init_plain(virtoccdims)
    astT22 = array2_init_plain(virtoccdims)
    astT23 = array2_init_plain(virtoccdims)
    astT24 = array2_init_plain(virtoccdims)
    astT25 = array2_init_plain(virtoccdims)
    astT26 = array2_init_plain(virtoccdims)

    ! tmpY(A,i) --> astTX(A,I)

    call array2_matmul(tmp01,Cocc,astT11,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp02,Cocc,astT12,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp03,Cocc,astT13,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp04,Cocc,astT14,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp05,Cocc,astT15,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp06,Cocc,astT16,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp07,Cocc,astT21,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp08,Cocc,astT22,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp09,Cocc,astT23,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp010,Cocc,astT24,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp011,Cocc,astT25,'n','n',1.0E0_realk,0.0E0_realk)
    call array2_matmul(tmp012,Cocc,astT26,'n','n',1.0E0_realk,0.0E0_realk)

    ! Free the temporary tmpY array2's

    call array2_free(tmp01)
    call array2_free(tmp02)
    call array2_free(tmp03)
    call array2_free(tmp04)
    call array2_free(tmp05)
    call array2_free(tmp06)
    call array2_free(tmp07)
    call array2_free(tmp08)
    call array2_free(tmp09)
    call array2_free(tmp010)
    call array2_free(tmp011)
    call array2_free(tmp012)

    ! Calculate EpT1 in local basis

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,'(1X,a)') '*                      Full DEC EpT1 calculation is done!                   *'
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(9X,a)') '-- Pair fragments [EpT1]'
    write(DECinfo%output,'(9X,a)') '------    ------    ----------    --------------------'
    write(DECinfo%output,'(9X,a)') '   P         Q        R(Ang)           deltaE(PQ) '
    write(DECinfo%output,'(9X,a)') '------    ------    ----------    --------------------'

    call mem_alloc(EpT11,numatoms,numatoms)
    call mem_alloc(EpT12,numatoms,numatoms)
    call mem_alloc(EpT13,numatoms,numatoms)
    call mem_alloc(EpT14,numatoms,numatoms)
    call mem_alloc(EpT15,numatoms,numatoms)
    call mem_alloc(EpT16,numatoms,numatoms)
    call mem_alloc(EpT17,numatoms,numatoms)
    call mem_alloc(EpT18,numatoms,numatoms)
    call mem_alloc(EpT19,numatoms,numatoms)
    call mem_alloc(EpT110,numatoms,numatoms)
    call mem_alloc(EpT111,numatoms,numatoms)
    call mem_alloc(EpT112,numatoms,numatoms)
    call mem_alloc(energy_matrix_1,numatoms,numatoms)
    EpT11 = 0.0E0_realk; EpT12 = 0.0E0_realk; EpT13 = 0.0E0_realk; EpT14 = 0.0E0_realk
    EpT15 = 0.0E0_realk; EpT16 = 0.0E0_realk; EpT17 = 0.0E0_realk; EpT18 = 0.0E0_realk
    EpT19 = 0.0E0_realk; EpT110 = 0.0E0_realk; EpT111 = 0.0E0_realk; EpT112 = 0.0E0_realk
    energy_matrix_1 = 0.0E0_realk

    do i=1,nocc
    AtomI = OccOrbitals(i)%CentralAtom
       do a=1,nvirt
       AtomA = UnoccOrbitals(a)%CentralAtom
          EpT11(AtomI,AtomA) = EpT11(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT11%val(a,i)
          EpT12(AtomI,AtomA) = EpT12(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT12%val(a,i)
          EpT13(AtomI,AtomA) = EpT13(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT13%val(a,i)
          EpT14(AtomI,AtomA) = EpT14(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT14%val(a,i)
          EpT15(AtomI,AtomA) = EpT15(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT15%val(a,i)
          EpT16(AtomI,AtomA) = EpT16(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT16%val(a,i)
          EpT17(AtomI,AtomA) = EpT17(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT21%val(a,i)
          EpT18(AtomI,AtomA) = EpT18(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT22%val(a,i)
          EpT19(AtomI,AtomA) = EpT19(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT23%val(a,i)
          EpT110(AtomI,AtomA) = EpT110(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT24%val(a,i)
          EpT111(AtomI,AtomA) = EpT111(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT25%val(a,i)
          EpT112(AtomI,AtomA) = EpT112(AtomI,AtomA) + 2.0E0_realk * Tai%val(a,i) * astT26%val(a,i)
       end do
    end do

    ! free astT11 - astT16 and astT21 - astT26
    call array2_free(astT11)
    call array2_free(astT12)
    call array2_free(astT13)
    call array2_free(astT14)
    call array2_free(astT15)
    call array2_free(astT16)
    call array2_free(astT21)
    call array2_free(astT22)
    call array2_free(astT23)
    call array2_free(astT24)
    call array2_free(astT25)
    call array2_free(astT26)

    ! Total EpT1 energy
    ! The total EpT1 energy must result from an unrestricted summation over all occ and virt indices
    ! as we are only interested in general orbital interactions and hence not the nature (occ/virt)
    ! of the individual orbitals

    do AtomI=1,numatoms
       do AtomA=1,numatoms
          energy_matrix_1(AtomI,AtomA) = EpT11(AtomI,AtomA) + EpT12(AtomI,AtomA) + EpT13(AtomI,AtomA) + &
              & EpT14(AtomI,AtomA) + EpT15(AtomI,AtomA) + EpT16(AtomI,AtomA) - &
              & (EpT17(AtomI,AtomA) + EpT18(AtomI,AtomA) + EpT19(AtomI,AtomA) + &
              & EpT110(AtomI,AtomA) + EpT111(AtomI,AtomA) + EpT112(AtomI,AtomA))
       end do
    end do

    EpT1_pair = 0.0E0_realk
    do i=1,numatoms
       do j=1,numatoms
          ! write increments only if pair interaction energy is nonzero
          if( orbitals_assigned(i) .and. orbitals_assigned(j) ) then
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.1#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT11(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.2#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT12(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.3#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT13(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.4#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT14(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.5#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT15(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.6#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT16(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.7#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT17(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.8#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT18(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.9#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT19(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.10#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT110(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.11#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT111(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.12#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT112(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#FULL#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), energy_matrix_1(i,j)
             EpT1_pair = EpT1_pair + energy_matrix_1(i,j)
          end if
       end do
    end do

    call mem_dealloc(EpT11)
    call mem_dealloc(EpT12)
    call mem_dealloc(EpT13)
    call mem_dealloc(EpT14)
    call mem_dealloc(EpT15)
    call mem_dealloc(EpT16)
    call mem_dealloc(EpT17)
    call mem_dealloc(EpT18)
    call mem_dealloc(EpT19)
    call mem_dealloc(EpT110)
    call mem_dealloc(EpT111)
    call mem_dealloc(EpT112)
    call mem_dealloc(energy_matrix_1)

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Pair atomic fragment en. [EpT1] = ', EpT1_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'Total EpT1 corr. energy [EpT1]  = ', EpT1_pair
    write(DECinfo%output,'(1X,a)')

    ! Enter EpT2 part of CCSD(T) corr. energy
    !
    ! *T^{ab}_{ij} (here: comprised of astT3, astT4, astT5, and astT6) part:

    etot2 = 0.0E0_realk
    etot3 = 0.0E0_realk
    astT31 = array4_init_standard(dims_aiai); astT32 = array4_init_standard(dims_aiai)
    astT33 = array4_init_standard(dims_aiai); astT34 = array4_init_standard(dims_aiai)
    astT35 = array4_init_standard(dims_aiai); astT36 = array4_init_standard(dims_aiai)
    astT41 = array4_init_standard(dims_aiai); astT42 = array4_init_standard(dims_aiai)
    astT43 = array4_init_standard(dims_aiai); astT44 = array4_init_standard(dims_aiai)
    astT45 = array4_init_standard(dims_aiai); astT46 = array4_init_standard(dims_aiai)
    astT51 = array4_init_standard(dims_aiai); astT52 = array4_init_standard(dims_aiai)
    astT53 = array4_init_standard(dims_aiai); astT54 = array4_init_standard(dims_aiai)
    astT55 = array4_init_standard(dims_aiai); astT56 = array4_init_standard(dims_aiai)
    astT61 = array4_init_standard(dims_aiai); astT62 = array4_init_standard(dims_aiai)
    astT63 = array4_init_standard(dims_aiai); astT64 = array4_init_standard(dims_aiai)
    astT65 = array4_init_standard(dims_aiai); astT66 = array4_init_standard(dims_aiai)
!test
    astTtest = array4_init_standard(dims_aiai)
!testend

    do i=1,nocc
       do j=1,nocc
          do a=1,nvirt
             do b=1,nvirt
    ! astT3, astT4 loop
!test
                astTtest2 = 0.0E0_realk
                do k=1,nocc
!testend
                   do c=1,nvirt
                      do d=1,nvirt
                         asttc1 = 0.0E0_realk; asttc2 = 0.0E0_realk; asttc3 = 0.0E0_realk
                         asttc4 = 0.0E0_realk; asttc5 = 0.0E0_realk; asttc6 = 0.0E0_realk
                         asttd1 = 0.0E0_realk; asttd2 = 0.0E0_realk; asttd3 = 0.0E0_realk
                         asttd4 = 0.0E0_realk; asttd5 = 0.0E0_realk; asttd6 = 0.0E0_realk
                         asttctmp11 = 0.0E0_realk; asttctmp12 = 0.0E0_realk; asttctmp13 = 0.0E0_realk
                         asttctmp14 = 0.0E0_realk; asttctmp15 = 0.0E0_realk; asttctmp16 = 0.0E0_realk
                         asttdtmp11 = 0.0E0_realk; asttdtmp12 = 0.0E0_realk; asttdtmp13 = 0.0E0_realk
                         asttdtmp14 = 0.0E0_realk; asttdtmp15 = 0.0E0_realk; asttdtmp16 = 0.0E0_realk
                         do e=1,nvirt ! 'e' is a virt index
                            asttctmp11 = asttctmp11 &
                                     & + canTaibj%val(a,i,e,j) * canAIBC%val(d,k,c,e)
                            asttctmp12 = asttctmp12 &
                                     & + canTaibj%val(d,k,e,i) * canAIBC%val(c,j,a,e)
                            asttctmp13 = asttctmp13 &
                                     & + canTaibj%val(c,j,e,k) * canAIBC%val(a,i,d,e)
                            asttctmp14 = asttctmp14 &
                                     & + canTaibj%val(a,i,e,k) * canAIBC%val(c,j,d,e)
                            asttctmp15 = asttctmp15 &
                                     & + canTaibj%val(c,j,e,i) * canAIBC%val(d,k,a,e)
                            asttctmp16 = asttctmp16 &
                                     & + canTaibj%val(d,k,e,j) * canAIBC%val(a,i,c,e)
                            asttdtmp11 = asttdtmp11 &
                                     & + canTaibj%val(a,k,e,j) * canAIBC%val(d,i,c,e)
                            asttdtmp12 = asttdtmp12 &
                                     & + canTaibj%val(d,i,e,k) * canAIBC%val(c,j,a,e)
                            asttdtmp13 = asttdtmp13 &
                                     & + canTaibj%val(c,j,e,i) * canAIBC%val(a,k,d,e)
                            asttdtmp14 = asttdtmp14 &
                                     & + canTaibj%val(a,k,e,i) * canAIBC%val(c,j,d,e)
                            asttdtmp15 = asttdtmp15 &
                                     & + canTaibj%val(c,j,e,k) * canAIBC%val(d,i,a,e)
                            asttdtmp16 = asttdtmp16 &
                                     & + canTaibj%val(d,i,e,j) * canAIBC%val(a,k,c,e)
                         end do
                         asttctmp21 = 0.0E0_realk; asttctmp22 = 0.0E0_realk; asttctmp23 = 0.0E0_realk
                         asttctmp24 = 0.0E0_realk; asttctmp25 = 0.0E0_realk; asttctmp26 = 0.0E0_realk
                         asttdtmp21 = 0.0E0_realk; asttdtmp22 = 0.0E0_realk; asttdtmp23 = 0.0E0_realk
                         asttdtmp24 = 0.0E0_realk; asttdtmp25 = 0.0E0_realk; asttdtmp26 = 0.0E0_realk
                         do m=1,nocc ! 'm' is an occ index
                            asttctmp21 = asttctmp21 &
                                     & + canTaibj%val(a,i,c,m) * canAIJK%val(d,k,m,j)
                            asttctmp22 = asttctmp22 &
                                     & + canTaibj%val(d,k,a,m) * canAIJK%val(c,j,m,i)
                            asttctmp23 = asttctmp23 &
                                     & + canTaibj%val(c,j,d,m) * canAIJK%val(a,i,m,k)
                            asttctmp24 = asttctmp24 &
                                     & + canTaibj%val(a,i,d,m) * canAIJK%val(c,j,m,k)
                            asttctmp25 = asttctmp25 &
                                     & + canTaibj%val(c,j,a,m) * canAIJK%val(d,k,m,i)
                            asttctmp26 = asttctmp26 &
                                     & + canTaibj%val(d,k,c,m) * canAIJK%val(a,i,m,j)
                            asttdtmp21 = asttdtmp21 &
                                     & + canTaibj%val(a,k,c,m) * canAIJK%val(d,i,m,j)
                            asttdtmp22 = asttdtmp22 &
                                     & + canTaibj%val(d,i,a,m) * canAIJK%val(c,j,m,k)
                            asttdtmp23 = asttdtmp23 &
                                     & + canTaibj%val(c,j,d,m) * canAIJK%val(a,k,m,i)
                            asttdtmp24 = asttdtmp24 &
                                     & + canTaibj%val(a,k,d,m) * canAIJK%val(c,j,m,i)
                            asttdtmp25 = asttdtmp25 &
                                     & + canTaibj%val(c,j,a,m) * canAIJK%val(d,i,m,k)
                            asttdtmp26 = asttdtmp26 &
                                     & + canTaibj%val(d,i,c,m) * canAIJK%val(a,k,m,j)
                         end do
                         etot2 = 1.0E0_realk / (eivalvirt(a) + eivalvirt(c) + eivalvirt(d) &
                                            & - eivalocc(i) - eivalocc(j) - eivalocc(k))
                         asttc1 = -1.0E0_realk * (asttctmp11 - asttctmp21) * etot2
                         asttc2 = -1.0E0_realk * (asttctmp12 - asttctmp22) * etot2
                         asttc3 = -1.0E0_realk * (asttctmp13 - asttctmp23) * etot2
                         asttc4 = -1.0E0_realk * (asttctmp14 - asttctmp24) * etot2
                         asttc5 = -1.0E0_realk * (asttctmp15 - asttctmp25) * etot2
                         asttc6 = -1.0E0_realk * (asttctmp16 - asttctmp26) * etot2
                         asttd1 = -1.0E0_realk * (asttdtmp11 - asttdtmp21) * etot2
                         asttd2 = -1.0E0_realk * (asttdtmp12 - asttdtmp22) * etot2
                         asttd3 = -1.0E0_realk * (asttdtmp13 - asttdtmp23) * etot2
                         asttd4 = -1.0E0_realk * (asttdtmp14 - asttdtmp24) * etot2
                         asttd5 = -1.0E0_realk * (asttdtmp15 - asttdtmp25) * etot2
                         asttd6 = -1.0E0_realk * (asttdtmp16 - asttdtmp26) * etot2
                         astT31%val(a,i,b,j) = astT31%val(a,i,b,j) + asttc1 &
                                           & * (2.0E0_realk * canAIBC%val(d,k,b,c) - canAIBC%val(c,k,b,d))
                         astT32%val(a,i,b,j) = astT32%val(a,i,b,j) + asttc2 &
                                           & * (2.0E0_realk * canAIBC%val(d,k,b,c) - canAIBC%val(c,k,b,d))
                         astT33%val(a,i,b,j) = astT33%val(a,i,b,j) + asttc3 &
                                           & * (2.0E0_realk * canAIBC%val(d,k,b,c) - canAIBC%val(c,k,b,d))
                         astT34%val(a,i,b,j) = astT34%val(a,i,b,j) + asttc4 &
                                           & * (2.0E0_realk * canAIBC%val(d,k,b,c) - canAIBC%val(c,k,b,d))
                         astT35%val(a,i,b,j) = astT35%val(a,i,b,j) + asttc5 &
                                           & * (2.0E0_realk * canAIBC%val(d,k,b,c) - canAIBC%val(c,k,b,d))
                         astT36%val(a,i,b,j) = astT36%val(a,i,b,j) + asttc6 &
                                           & * (2.0E0_realk * canAIBC%val(d,k,b,c) - canAIBC%val(c,k,b,d))
!test
!                         astTtest2 = astTtest2 + (asttc1 + asttc2 + asttc3 + asttc4 + asttc5 + asttc6) &
!                                           & * (2.0E0_realk * canAIBC%val(d,k,b,c) - canAIBC%val(c,k,b,d)) &
!                                           & - (asttd1 + asttd2 + asttd3 + asttd4 + asttd5 + asttd6) &
!                                           & * canAIBC%val(d,k,b,c)
!testend
                         astT41%val(a,i,b,j) = astT41%val(a,i,b,j) + asttd1 &
                                           & * canAIBC%val(d,k,b,c)
                         astT42%val(a,i,b,j) = astT42%val(a,i,b,j) + asttd2 &
                                           & * canAIBC%val(d,k,b,c)
                         astT43%val(a,i,b,j) = astT43%val(a,i,b,j) + asttd3 &
                                           & * canAIBC%val(d,k,b,c)
                         astT44%val(a,i,b,j) = astT44%val(a,i,b,j) + asttd4 &
                                           & * canAIBC%val(d,k,b,c)
                         astT45%val(a,i,b,j) = astT45%val(a,i,b,j) + asttd5 &
                                           & * canAIBC%val(d,k,b,c)
                         astT46%val(a,i,b,j) = astT46%val(a,i,b,j) + asttd6 &
                                           & * canAIBC%val(d,k,b,c)
                      end do
                   end do
!test
                end do
!                astTtest%val(a,i,b,j) = astTtest%val(a,i,b,j) + astTtest2
!testend
    ! astT5, astT6 loop
                do c=1,nvirt
                   do k=1,nocc
                      do l=1,nocc
                         astte1 = 0.0E0_realk; astte2 = 0.0E0_realk; astte3 = 0.0E0_realk
                         astte4 = 0.0E0_realk; astte5 = 0.0E0_realk; astte6 = 0.0E0_realk
                         asttf1 = 0.0E0_realk; asttf2 = 0.0E0_realk; asttf3 = 0.0E0_realk
                         asttf4 = 0.0E0_realk; asttf5 = 0.0E0_realk; asttf6 = 0.0E0_realk
                         asttetmp11 = 0.0E0_realk; asttetmp12 = 0.0E0_realk; asttetmp13 = 0.0E0_realk
                         asttetmp14 = 0.0E0_realk; asttetmp15 = 0.0E0_realk; asttetmp16 = 0.0E0_realk
                         asttftmp11 = 0.0E0_realk; asttftmp12 = 0.0E0_realk; asttftmp13 = 0.0E0_realk
                         asttftmp14 = 0.0E0_realk; asttftmp15 = 0.0E0_realk; asttftmp16 = 0.0E0_realk
                         do e=1,nvirt ! 'e' is a virt index
                            asttetmp11 = asttetmp11 &
                                     & + canTaibj%val(a,i,e,k) * canAIBC%val(c,l,b,e)
                            asttetmp12 = asttetmp12 &
                                     & + canTaibj%val(c,l,e,i) * canAIBC%val(b,k,a,e)
                            asttetmp13 = asttetmp13 &
                                     & + canTaibj%val(b,k,e,l) * canAIBC%val(a,i,c,e)
                            asttetmp14 = asttetmp14 &
                                     & + canTaibj%val(a,i,e,l) * canAIBC%val(b,k,c,e)
                            asttetmp15 = asttetmp15 &
                                     & + canTaibj%val(b,k,e,i) * canAIBC%val(c,l,a,e)
                            asttetmp16 = asttetmp16 &
                                     & + canTaibj%val(c,l,e,k) * canAIBC%val(a,i,b,e)
                            asttftmp11 = asttftmp11 &
                                     & + canTaibj%val(a,l,e,k) * canAIBC%val(c,i,b,e)
                            asttftmp12 = asttftmp12 &
                                     & + canTaibj%val(c,i,e,l) * canAIBC%val(b,k,a,e)
                            asttftmp13 = asttftmp13 &
                                     & + canTaibj%val(b,k,e,i) * canAIBC%val(a,l,c,e)
                            asttftmp14 = asttftmp14 &
                                     & + canTaibj%val(a,l,e,i) * canAIBC%val(b,k,c,e)
                            asttftmp15 = asttftmp15 &
                                     & + canTaibj%val(b,k,e,l) * canAIBC%val(c,i,a,e)
                            asttftmp16 = asttftmp16 &
                                     & + canTaibj%val(c,i,e,k) * canAIBC%val(a,l,b,e)
                         end do
                         asttetmp21 = 0.0E0_realk; asttetmp22 = 0.0E0_realk; asttetmp23 = 0.0E0_realk
                         asttetmp24 = 0.0E0_realk; asttetmp25 = 0.0E0_realk; asttetmp26 = 0.0E0_realk
                         asttftmp21 = 0.0E0_realk; asttftmp22 = 0.0E0_realk; asttftmp23 = 0.0E0_realk
                         asttftmp24 = 0.0E0_realk; asttftmp25 = 0.0E0_realk; asttftmp26 = 0.0E0_realk
                         do m=1,nocc ! 'm' is an occ index
                            asttetmp21 = asttetmp21 &
                                     & + canTaibj%val(a,i,b,m) * canAIJK%val(c,l,m,k)
                            asttetmp22 = asttetmp22 &
                                     & + canTaibj%val(c,l,a,m) * canAIJK%val(b,k,m,i)
                            asttetmp23 = asttetmp23 &
                                     & + canTaibj%val(b,k,c,m) * canAIJK%val(a,i,m,l)
                            asttetmp24 = asttetmp24 &
                                     & + canTaibj%val(a,i,c,m) * canAIJK%val(b,k,m,l)
                            asttetmp25 = asttetmp25 &
                                     & + canTaibj%val(b,k,a,m) * canAIJK%val(c,l,m,i)
                            asttetmp26 = asttetmp26 &
                                     & + canTaibj%val(c,l,b,m) * canAIJK%val(a,i,m,k)
                            asttftmp21 = asttftmp21 &
                                     & + canTaibj%val(a,l,b,m) * canAIJK%val(c,i,m,k)
                            asttftmp22 = asttftmp22 &
                                     & + canTaibj%val(c,i,a,m) * canAIJK%val(b,k,m,l)
                            asttftmp23 = asttftmp23 &
                                     & + canTaibj%val(b,k,c,m) * canAIJK%val(a,l,m,i)
                            asttftmp24 = asttftmp24 &
                                     & + canTaibj%val(a,l,c,m) * canAIJK%val(b,k,m,i)
                            asttftmp25 = asttftmp25 &
                                     & + canTaibj%val(b,k,a,m) * canAIJK%val(c,i,m,l)
                            asttftmp26 = asttftmp26 &
                                     & + canTaibj%val(c,i,b,m) * canAIJK%val(a,l,m,k)
                         end do
                         etot3 = 1.0E0_realk / (eivalvirt(a) + eivalvirt(b) + eivalvirt(c) &
                                            & - eivalocc(i) - eivalocc(l) - eivalocc(k))
                         astte1 = -1.0E0_realk * (asttetmp11 - asttetmp21) * etot3
                         astte2 = -1.0E0_realk * (asttetmp12 - asttetmp22) * etot3
                         astte3 = -1.0E0_realk * (asttetmp13 - asttetmp23) * etot3
                         astte4 = -1.0E0_realk * (asttetmp14 - asttetmp24) * etot3
                         astte5 = -1.0E0_realk * (asttetmp15 - asttetmp25) * etot3
                         astte6 = -1.0E0_realk * (asttetmp16 - asttetmp26) * etot3
                         asttf1 = -1.0E0_realk * (asttftmp11 - asttftmp21) * etot3
                         asttf2 = -1.0E0_realk * (asttftmp12 - asttftmp22) * etot3
                         asttf3 = -1.0E0_realk * (asttftmp13 - asttftmp23) * etot3
                         asttf4 = -1.0E0_realk * (asttftmp14 - asttftmp24) * etot3
                         asttf5 = -1.0E0_realk * (asttftmp15 - asttftmp25) * etot3
                         asttf6 = -1.0E0_realk * (asttftmp16 - asttftmp26) * etot3
                         astT51%val(a,i,b,j) = astT51%val(a,i,b,j) + astte1 &
                                           & * (2.0E0_realk * canAIJK%val(c,l,k,j) - canAIJK%val(c,k,l,j))
                         astT52%val(a,i,b,j) = astT52%val(a,i,b,j) + astte2 &
                                           & * (2.0E0_realk * canAIJK%val(c,l,k,j) - canAIJK%val(c,k,l,j))
                         astT53%val(a,i,b,j) = astT53%val(a,i,b,j) + astte3 &
                                           & * (2.0E0_realk * canAIJK%val(c,l,k,j) - canAIJK%val(c,k,l,j))
                         astT54%val(a,i,b,j) = astT54%val(a,i,b,j) + astte4 &
                                           & * (2.0E0_realk * canAIJK%val(c,l,k,j) - canAIJK%val(c,k,l,j))
                         astT55%val(a,i,b,j) = astT55%val(a,i,b,j) + astte5 &
                                           & * (2.0E0_realk * canAIJK%val(c,l,k,j) - canAIJK%val(c,k,l,j))
                         astT56%val(a,i,b,j) = astT56%val(a,i,b,j) + astte6 &
                                           & * (2.0E0_realk * canAIJK%val(c,l,k,j) - canAIJK%val(c,k,l,j))
!test
                         astTtest2 = astTtest2 + (astte1 + astte2 + astte3 + astte4 + astte5 + astte6) &
                                           & * (2.0E0_realk * canAIJK%val(c,l,k,j) - canAIJK%val(c,k,l,j)) &
                                           & - (asttf1 + asttf2 + asttf3 + asttf4 + asttf5 + asttf6) &
                                           & * canAIJK%val(c,l,k,j)
!testend
                         astT61%val(a,i,b,j) = astT61%val(a,i,b,j) + asttf1 &
                                           & * canAIJK%val(c,l,k,j)
                         astT62%val(a,i,b,j) = astT62%val(a,i,b,j) + asttf2 &
                                           & * canAIJK%val(c,l,k,j)
                         astT63%val(a,i,b,j) = astT63%val(a,i,b,j) + asttf3 &
                                           & * canAIJK%val(c,l,k,j)
                         astT64%val(a,i,b,j) = astT64%val(a,i,b,j) + asttf4 &
                                           & * canAIJK%val(c,l,k,j)
                         astT65%val(a,i,b,j) = astT65%val(a,i,b,j) + asttf5 &
                                           & * canAIJK%val(c,l,k,j)
                         astT66%val(a,i,b,j) = astT66%val(a,i,b,j) + asttf6 &
                                           & * canAIJK%val(c,l,k,j)
                      end do
                   end do
                end do
!test
                astTtest%val(a,i,b,j) = astTtest%val(a,i,b,j) + astTtest2
!testend
             end do
          end do
       end do
    end do

!test
!    print *,'before trans [OLD] : ', astTtest%val
!testend

    ! Now we wish to transform back into local basis before we evaluate the energy (fragment
    ! and fragment pair) components.
    ! We note at this point that since the astTX array4's are written as virt-occ-virt-occ,
    ! we may follow the path of the AIBJ integrals in the initial local --> canonical transformation.

    ! 1. Init temporary array4's, tmpY

                tmp11 = array4_init_standard(dims_aiai)
                tmp12 = array4_init_standard(dims_aiai)
                tmp13 = array4_init_standard(dims_aiai)
                tmp14 = array4_init_standard(dims_aiai)
                tmp15 = array4_init_standard(dims_aiai)
                tmp16 = array4_init_standard(dims_aiai)
                tmp17 = array4_init_standard(dims_aiai)
                tmp18 = array4_init_standard(dims_aiai)
                tmp19 = array4_init_standard(dims_aiai)
                tmp110 = array4_init_standard(dims_aiai)
                tmp111 = array4_init_standard(dims_aiai)
                tmp112 = array4_init_standard(dims_aiai)
                tmp113 = array4_init_standard(dims_aiai)
                tmp114 = array4_init_standard(dims_aiai)
                tmp115 = array4_init_standard(dims_aiai)
                tmp116 = array4_init_standard(dims_aiai)
                tmp117 = array4_init_standard(dims_aiai)
                tmp118 = array4_init_standard(dims_aiai)
                tmp119 = array4_init_standard(dims_aiai)
                tmp120 = array4_init_standard(dims_aiai)
                tmp121 = array4_init_standard(dims_aiai)
                tmp122 = array4_init_standard(dims_aiai)
                tmp123 = array4_init_standard(dims_aiai)
                tmp124 = array4_init_standard(dims_aiai)
!test
                tmptest1 = array4_init_standard(dims_aiai)
!testend

    ! 2. 1st index:
    ! astTX(A,I,B,J) --> tmpY(a,I,B,J)

                call array4_contract1(astT31,Cvirt,tmp11,.true.)
                call array4_contract1(astT32,Cvirt,tmp12,.true.)
                call array4_contract1(astT33,Cvirt,tmp13,.true.)
                call array4_contract1(astT34,Cvirt,tmp14,.true.)
                call array4_contract1(astT35,Cvirt,tmp15,.true.)
                call array4_contract1(astT36,Cvirt,tmp16,.true.)
                call array4_contract1(astT41,Cvirt,tmp17,.true.)
                call array4_contract1(astT42,Cvirt,tmp18,.true.)
                call array4_contract1(astT43,Cvirt,tmp19,.true.)
                call array4_contract1(astT44,Cvirt,tmp110,.true.)
                call array4_contract1(astT45,Cvirt,tmp111,.true.)
                call array4_contract1(astT46,Cvirt,tmp112,.true.)
                call array4_contract1(astT51,Cvirt,tmp113,.true.)
                call array4_contract1(astT52,Cvirt,tmp114,.true.)
                call array4_contract1(astT53,Cvirt,tmp115,.true.)
                call array4_contract1(astT54,Cvirt,tmp116,.true.)
                call array4_contract1(astT55,Cvirt,tmp117,.true.)
                call array4_contract1(astT56,Cvirt,tmp118,.true.)
                call array4_contract1(astT61,Cvirt,tmp119,.true.)
                call array4_contract1(astT62,Cvirt,tmp120,.true.)
                call array4_contract1(astT63,Cvirt,tmp121,.true.)
                call array4_contract1(astT64,Cvirt,tmp122,.true.)
                call array4_contract1(astT65,Cvirt,tmp123,.true.)
                call array4_contract1(astT66,Cvirt,tmp124,.true.)
!test
                call array4_contract1(astTtest,Cvirt,tmptest1,.true.)
!testend

    ! Free the astTX array4's

                call array4_free(astT31)
                call array4_free(astT32)
                call array4_free(astT33)
                call array4_free(astT34)
                call array4_free(astT35)
                call array4_free(astT36)
                call array4_free(astT41)
                call array4_free(astT42)
                call array4_free(astT43)
                call array4_free(astT44)
                call array4_free(astT45)
                call array4_free(astT46)
                call array4_free(astT51)
                call array4_free(astT52)
                call array4_free(astT53)
                call array4_free(astT54)
                call array4_free(astT55)
                call array4_free(astT56)
                call array4_free(astT61)
                call array4_free(astT62)
                call array4_free(astT63)
                call array4_free(astT64)
                call array4_free(astT65)
                call array4_free(astT66)
!test
                call array4_free(astTtest)
!testend

    ! 3. 2nd index:
    ! tmpY(a,I,B,J) --> tmpY(I,a,B,J) --> tmpZ(i,a,B,J)

                call array4_reorder(tmp11,[2,1,3,4])
                call array4_reorder(tmp12,[2,1,3,4])
                call array4_reorder(tmp13,[2,1,3,4])
                call array4_reorder(tmp14,[2,1,3,4])
                call array4_reorder(tmp15,[2,1,3,4])
                call array4_reorder(tmp16,[2,1,3,4])
                call array4_reorder(tmp17,[2,1,3,4])
                call array4_reorder(tmp18,[2,1,3,4])
                call array4_reorder(tmp19,[2,1,3,4])
                call array4_reorder(tmp110,[2,1,3,4])
                call array4_reorder(tmp111,[2,1,3,4])
                call array4_reorder(tmp112,[2,1,3,4])
                call array4_reorder(tmp113,[2,1,3,4])
                call array4_reorder(tmp114,[2,1,3,4])
                call array4_reorder(tmp115,[2,1,3,4])
                call array4_reorder(tmp116,[2,1,3,4])
                call array4_reorder(tmp117,[2,1,3,4])
                call array4_reorder(tmp118,[2,1,3,4])
                call array4_reorder(tmp119,[2,1,3,4])
                call array4_reorder(tmp120,[2,1,3,4])
                call array4_reorder(tmp121,[2,1,3,4])
                call array4_reorder(tmp122,[2,1,3,4])
                call array4_reorder(tmp123,[2,1,3,4])
                call array4_reorder(tmp124,[2,1,3,4])
!test
                call array4_reorder(tmptest1,[2,1,3,4])
!testend

    ! Init temporary array4's, tmpZ

                tmp21 = array4_init_standard(dims_iaai)
                tmp22 = array4_init_standard(dims_iaai)
                tmp23 = array4_init_standard(dims_iaai)
                tmp24 = array4_init_standard(dims_iaai)
                tmp25 = array4_init_standard(dims_iaai)
                tmp26 = array4_init_standard(dims_iaai)
                tmp27 = array4_init_standard(dims_iaai)
                tmp28 = array4_init_standard(dims_iaai)
                tmp29 = array4_init_standard(dims_iaai)
                tmp210 = array4_init_standard(dims_iaai)
                tmp211 = array4_init_standard(dims_iaai)
                tmp212 = array4_init_standard(dims_iaai)
                tmp213 = array4_init_standard(dims_iaai)
                tmp214 = array4_init_standard(dims_iaai)
                tmp215 = array4_init_standard(dims_iaai)
                tmp216 = array4_init_standard(dims_iaai)
                tmp217 = array4_init_standard(dims_iaai)
                tmp218 = array4_init_standard(dims_iaai)
                tmp219 = array4_init_standard(dims_iaai)
                tmp220 = array4_init_standard(dims_iaai)
                tmp221 = array4_init_standard(dims_iaai)
                tmp222 = array4_init_standard(dims_iaai)
                tmp223 = array4_init_standard(dims_iaai)
                tmp224 = array4_init_standard(dims_iaai)
!test
                tmptest2 = array4_init_standard(dims_iaai)
!testend

    ! Transformation time

                call array4_contract1(tmp11,Cocc,tmp21,.true.)
                call array4_contract1(tmp12,Cocc,tmp22,.true.)
                call array4_contract1(tmp13,Cocc,tmp23,.true.)
                call array4_contract1(tmp14,Cocc,tmp24,.true.)
                call array4_contract1(tmp15,Cocc,tmp25,.true.)
                call array4_contract1(tmp16,Cocc,tmp26,.true.)
                call array4_contract1(tmp17,Cocc,tmp27,.true.)
                call array4_contract1(tmp18,Cocc,tmp28,.true.)
                call array4_contract1(tmp19,Cocc,tmp29,.true.)
                call array4_contract1(tmp110,Cocc,tmp210,.true.)
                call array4_contract1(tmp111,Cocc,tmp211,.true.)
                call array4_contract1(tmp112,Cocc,tmp212,.true.)
                call array4_contract1(tmp113,Cocc,tmp213,.true.)
                call array4_contract1(tmp114,Cocc,tmp214,.true.)
                call array4_contract1(tmp115,Cocc,tmp215,.true.)
                call array4_contract1(tmp116,Cocc,tmp216,.true.)
                call array4_contract1(tmp117,Cocc,tmp217,.true.)
                call array4_contract1(tmp118,Cocc,tmp218,.true.)
                call array4_contract1(tmp119,Cocc,tmp219,.true.)
                call array4_contract1(tmp120,Cocc,tmp220,.true.)
                call array4_contract1(tmp121,Cocc,tmp221,.true.)
                call array4_contract1(tmp122,Cocc,tmp222,.true.)
                call array4_contract1(tmp123,Cocc,tmp223,.true.)
                call array4_contract1(tmp124,Cocc,tmp224,.true.)
!test
                call array4_contract1(tmptest1,Cocc,tmptest2,.true.)
!testend

    ! Free the tmpY array4's

                call array4_free(tmp11)
                call array4_free(tmp12)
                call array4_free(tmp13)
                call array4_free(tmp14)
                call array4_free(tmp15)
                call array4_free(tmp16)
                call array4_free(tmp17)
                call array4_free(tmp18)
                call array4_free(tmp19)
                call array4_free(tmp110)
                call array4_free(tmp111)
                call array4_free(tmp112)
                call array4_free(tmp113)
                call array4_free(tmp114)
                call array4_free(tmp115)
                call array4_free(tmp116)
                call array4_free(tmp117)
                call array4_free(tmp118)
                call array4_free(tmp119)
                call array4_free(tmp120)
                call array4_free(tmp121)
                call array4_free(tmp122)
                call array4_free(tmp123)
                call array4_free(tmp124)
!test
                call array4_free(tmptest1)
!testend

    ! 4. 3rd index:
    ! tmpZ(i,a,B,J) --> tmpZ(J,B,a,i) --> tmpY(j,B,a,i)

                call array4_reorder(tmp21,[4,3,2,1])
                call array4_reorder(tmp22,[4,3,2,1])
                call array4_reorder(tmp23,[4,3,2,1])
                call array4_reorder(tmp24,[4,3,2,1])
                call array4_reorder(tmp25,[4,3,2,1])
                call array4_reorder(tmp26,[4,3,2,1])
                call array4_reorder(tmp27,[4,3,2,1])
                call array4_reorder(tmp28,[4,3,2,1])
                call array4_reorder(tmp29,[4,3,2,1])
                call array4_reorder(tmp210,[4,3,2,1])
                call array4_reorder(tmp211,[4,3,2,1])
                call array4_reorder(tmp212,[4,3,2,1])
                call array4_reorder(tmp213,[4,3,2,1])
                call array4_reorder(tmp214,[4,3,2,1])
                call array4_reorder(tmp215,[4,3,2,1])
                call array4_reorder(tmp216,[4,3,2,1])
                call array4_reorder(tmp217,[4,3,2,1])
                call array4_reorder(tmp218,[4,3,2,1])
                call array4_reorder(tmp219,[4,3,2,1])
                call array4_reorder(tmp220,[4,3,2,1])
                call array4_reorder(tmp221,[4,3,2,1])
                call array4_reorder(tmp222,[4,3,2,1])
                call array4_reorder(tmp223,[4,3,2,1])
                call array4_reorder(tmp224,[4,3,2,1])
!test
                call array4_reorder(tmptest2,[4,3,2,1])
!testend

    ! Init temporary array4's, tmpY, once again

                tmp11 = array4_init_standard(dims_iaai)
                tmp12 = array4_init_standard(dims_iaai)
                tmp13 = array4_init_standard(dims_iaai)
                tmp14 = array4_init_standard(dims_iaai)
                tmp15 = array4_init_standard(dims_iaai)
                tmp16 = array4_init_standard(dims_iaai)
                tmp17 = array4_init_standard(dims_iaai)
                tmp18 = array4_init_standard(dims_iaai)
                tmp19 = array4_init_standard(dims_iaai)
                tmp110 = array4_init_standard(dims_iaai)
                tmp111 = array4_init_standard(dims_iaai)
                tmp112 = array4_init_standard(dims_iaai)
                tmp113 = array4_init_standard(dims_iaai)
                tmp114 = array4_init_standard(dims_iaai)
                tmp115 = array4_init_standard(dims_iaai)
                tmp116 = array4_init_standard(dims_iaai)
                tmp117 = array4_init_standard(dims_iaai)
                tmp118 = array4_init_standard(dims_iaai)
                tmp119 = array4_init_standard(dims_iaai)
                tmp120 = array4_init_standard(dims_iaai)
                tmp121 = array4_init_standard(dims_iaai)
                tmp122 = array4_init_standard(dims_iaai)
                tmp123 = array4_init_standard(dims_iaai)
                tmp124 = array4_init_standard(dims_iaai)
!test
                tmptest1 = array4_init_standard(dims_iaai)
!testend

    ! Transformation time

                call array4_contract1(tmp21,Cocc,tmp11,.true.)
                call array4_contract1(tmp22,Cocc,tmp12,.true.)
                call array4_contract1(tmp23,Cocc,tmp13,.true.)
                call array4_contract1(tmp24,Cocc,tmp14,.true.)
                call array4_contract1(tmp25,Cocc,tmp15,.true.)
                call array4_contract1(tmp26,Cocc,tmp16,.true.)
                call array4_contract1(tmp27,Cocc,tmp17,.true.)
                call array4_contract1(tmp28,Cocc,tmp18,.true.)
                call array4_contract1(tmp29,Cocc,tmp19,.true.)
                call array4_contract1(tmp210,Cocc,tmp110,.true.)
                call array4_contract1(tmp211,Cocc,tmp111,.true.)
                call array4_contract1(tmp212,Cocc,tmp112,.true.)
                call array4_contract1(tmp213,Cocc,tmp113,.true.)
                call array4_contract1(tmp214,Cocc,tmp114,.true.)
                call array4_contract1(tmp215,Cocc,tmp115,.true.)
                call array4_contract1(tmp216,Cocc,tmp116,.true.)
                call array4_contract1(tmp217,Cocc,tmp117,.true.)
                call array4_contract1(tmp218,Cocc,tmp118,.true.)
                call array4_contract1(tmp219,Cocc,tmp119,.true.)
                call array4_contract1(tmp220,Cocc,tmp120,.true.)
                call array4_contract1(tmp221,Cocc,tmp121,.true.)
                call array4_contract1(tmp222,Cocc,tmp122,.true.)
                call array4_contract1(tmp223,Cocc,tmp123,.true.)
                call array4_contract1(tmp224,Cocc,tmp124,.true.)
!test
                call array4_contract1(tmptest2,Cocc,tmptest1,.true.)
!testend

    ! Free the tmpZ array4's

                call array4_free(tmp21)
                call array4_free(tmp22)
                call array4_free(tmp23)
                call array4_free(tmp24)
                call array4_free(tmp25)
                call array4_free(tmp26)
                call array4_free(tmp27)
                call array4_free(tmp28)
                call array4_free(tmp29)
                call array4_free(tmp210)
                call array4_free(tmp211)
                call array4_free(tmp212)
                call array4_free(tmp213)
                call array4_free(tmp214)
                call array4_free(tmp215)
                call array4_free(tmp216)
                call array4_free(tmp217)
                call array4_free(tmp218)
                call array4_free(tmp219)
                call array4_free(tmp220)
                call array4_free(tmp221)
                call array4_free(tmp222)
                call array4_free(tmp223)
                call array4_free(tmp224)
!test
                call array4_free(tmptest2)
!testend

    ! 5. 4th index:
    ! tmpY(j,B,a,i) --> tmpY(B,j,a,i) --> astTX(b,j,a,i) = astTX (*)
    ! (*) due to permutational symmetry

                call array4_reorder(tmp11,[2,1,3,4])
                call array4_reorder(tmp12,[2,1,3,4])
                call array4_reorder(tmp13,[2,1,3,4])
                call array4_reorder(tmp14,[2,1,3,4])
                call array4_reorder(tmp15,[2,1,3,4])
                call array4_reorder(tmp16,[2,1,3,4])
                call array4_reorder(tmp17,[2,1,3,4])
                call array4_reorder(tmp18,[2,1,3,4])
                call array4_reorder(tmp19,[2,1,3,4])
                call array4_reorder(tmp110,[2,1,3,4])
                call array4_reorder(tmp111,[2,1,3,4])
                call array4_reorder(tmp112,[2,1,3,4])
                call array4_reorder(tmp113,[2,1,3,4])
                call array4_reorder(tmp114,[2,1,3,4])
                call array4_reorder(tmp115,[2,1,3,4])
                call array4_reorder(tmp116,[2,1,3,4])
                call array4_reorder(tmp117,[2,1,3,4])
                call array4_reorder(tmp118,[2,1,3,4])
                call array4_reorder(tmp119,[2,1,3,4])
                call array4_reorder(tmp120,[2,1,3,4])
                call array4_reorder(tmp121,[2,1,3,4])
                call array4_reorder(tmp122,[2,1,3,4])
                call array4_reorder(tmp123,[2,1,3,4])
                call array4_reorder(tmp124,[2,1,3,4])
!test
                call array4_reorder(tmptest1,[2,1,3,4])
!testend

    ! Init final astTX array4's once again

                astT31 = array4_init_standard(dims_aiai)
                astT32 = array4_init_standard(dims_aiai)
                astT33 = array4_init_standard(dims_aiai)
                astT34 = array4_init_standard(dims_aiai)
                astT35 = array4_init_standard(dims_aiai)
                astT36 = array4_init_standard(dims_aiai)
                astT41 = array4_init_standard(dims_aiai)
                astT42 = array4_init_standard(dims_aiai)
                astT43 = array4_init_standard(dims_aiai)
                astT44 = array4_init_standard(dims_aiai)
                astT45 = array4_init_standard(dims_aiai)
                astT46 = array4_init_standard(dims_aiai)
                astT51 = array4_init_standard(dims_aiai)
                astT52 = array4_init_standard(dims_aiai)
                astT53 = array4_init_standard(dims_aiai)
                astT54 = array4_init_standard(dims_aiai)
                astT55 = array4_init_standard(dims_aiai)
                astT56 = array4_init_standard(dims_aiai)
                astT61 = array4_init_standard(dims_aiai)
                astT62 = array4_init_standard(dims_aiai)
                astT63 = array4_init_standard(dims_aiai)
                astT64 = array4_init_standard(dims_aiai)
                astT65 = array4_init_standard(dims_aiai)
                astT66 = array4_init_standard(dims_aiai)
!test
                astTtest = array4_init_standard(dims_aiai)
!testend

    ! Transformation time

                call array4_contract1(tmp11,Cvirt,astT31,.true.)
                call array4_contract1(tmp12,Cvirt,astT32,.true.)
                call array4_contract1(tmp13,Cvirt,astT33,.true.)
                call array4_contract1(tmp14,Cvirt,astT34,.true.)
                call array4_contract1(tmp15,Cvirt,astT35,.true.)
                call array4_contract1(tmp16,Cvirt,astT36,.true.)
                call array4_contract1(tmp17,Cvirt,astT41,.true.)
                call array4_contract1(tmp18,Cvirt,astT42,.true.)
                call array4_contract1(tmp19,Cvirt,astT43,.true.)
                call array4_contract1(tmp110,Cvirt,astT44,.true.)
                call array4_contract1(tmp111,Cvirt,astT45,.true.)
                call array4_contract1(tmp112,Cvirt,astT46,.true.)
                call array4_contract1(tmp113,Cvirt,astT51,.true.)
                call array4_contract1(tmp114,Cvirt,astT52,.true.)
                call array4_contract1(tmp115,Cvirt,astT53,.true.)
                call array4_contract1(tmp116,Cvirt,astT54,.true.)
                call array4_contract1(tmp117,Cvirt,astT55,.true.)
                call array4_contract1(tmp118,Cvirt,astT56,.true.)
                call array4_contract1(tmp119,Cvirt,astT61,.true.)
                call array4_contract1(tmp120,Cvirt,astT62,.true.)
                call array4_contract1(tmp121,Cvirt,astT63,.true.)
                call array4_contract1(tmp122,Cvirt,astT64,.true.)
                call array4_contract1(tmp123,Cvirt,astT65,.true.)
                call array4_contract1(tmp124,Cvirt,astT66,.true.)
!test
                call array4_contract1(tmptest1,Cvirt,astTtest,.true.)
!testend

    ! Free the tmpY array4's

                call array4_free(tmp11)
                call array4_free(tmp12)
                call array4_free(tmp13)
                call array4_free(tmp14)
                call array4_free(tmp15)
                call array4_free(tmp16)
                call array4_free(tmp17)
                call array4_free(tmp18)
                call array4_free(tmp19)
                call array4_free(tmp110)
                call array4_free(tmp111)
                call array4_free(tmp112)
                call array4_free(tmp113)
                call array4_free(tmp114)
                call array4_free(tmp115)
                call array4_free(tmp116)
                call array4_free(tmp117)
                call array4_free(tmp118)
                call array4_free(tmp119)
                call array4_free(tmp120)
                call array4_free(tmp121)
                call array4_free(tmp122)
                call array4_free(tmp123)
                call array4_free(tmp124)
!test
                call array4_free(tmptest1)
!testend

    ! Calculate EpT2 in local basis

    ! First, we calculate the EpT2 part of the CCSD(T) corr. energy in the occupied partitioning scheme

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,'(1X,a)') '*          Full DEC EpT2 calculation is done (occ. part. scheme)!           *'
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Atomic fragments [EpT2]'
    write(DECinfo%output,'(8X,a)') '------    --------------------'
    write(DECinfo%output,'(8X,a)') ' Atom            Energy '
    write(DECinfo%output,'(8X,a)') '------    --------------------'

    call mem_alloc(EpT211,numatoms,numatoms)
    call mem_alloc(EpT212,numatoms,numatoms)
    call mem_alloc(EpT213,numatoms,numatoms)
    call mem_alloc(EpT214,numatoms,numatoms)
    call mem_alloc(EpT215,numatoms,numatoms)
    call mem_alloc(EpT216,numatoms,numatoms)
    call mem_alloc(EpT217,numatoms,numatoms)
    call mem_alloc(EpT218,numatoms,numatoms)
    call mem_alloc(EpT219,numatoms,numatoms)
    call mem_alloc(EpT2110,numatoms,numatoms)
    call mem_alloc(EpT2111,numatoms,numatoms)
    call mem_alloc(EpT2112,numatoms,numatoms)
    call mem_alloc(EpT221,numatoms,numatoms)
    call mem_alloc(EpT222,numatoms,numatoms)
    call mem_alloc(EpT223,numatoms,numatoms)
    call mem_alloc(EpT224,numatoms,numatoms)
    call mem_alloc(EpT225,numatoms,numatoms)
    call mem_alloc(EpT226,numatoms,numatoms)
    call mem_alloc(EpT227,numatoms,numatoms)
    call mem_alloc(EpT228,numatoms,numatoms)
    call mem_alloc(EpT229,numatoms,numatoms)
    call mem_alloc(EpT2210,numatoms,numatoms)
    call mem_alloc(EpT2211,numatoms,numatoms)
    call mem_alloc(EpT2212,numatoms,numatoms)
!test
    call mem_alloc(EpTtest,numatoms,numatoms)
!test
    call mem_alloc(energy_matrix_2,numatoms,numatoms)
!test
    call mem_alloc(energy_matrix_2_test,numatoms,numatoms)
!testend
    EpT211 = 0.0E0_realk; EpT212 = 0.0E0_realk; EpT213 = 0.0E0_realk; EpT214 = 0.0E0_realk
    EpT215 = 0.0E0_realk; EpT216 = 0.0E0_realk; EpT217 = 0.0E0_realk; EpT218 = 0.0E0_realk
    EpT219 = 0.0E0_realk; EpT2110 = 0.0E0_realk; EpT2111 = 0.0E0_realk; EpT2112 = 0.0E0_realk
    EpT221 = 0.0E0_realk; EpT222 = 0.0E0_realk; EpT223 = 0.0E0_realk; EpT224 = 0.0E0_realk
    EpT225 = 0.0E0_realk; EpT226 = 0.0E0_realk; EpT227 = 0.0E0_realk; EpT228 = 0.0E0_realk
    EpT229 = 0.0E0_realk; EpT2210 = 0.0E0_realk; EpT2211 = 0.0E0_realk; EpT2212 = 0.0E0_realk
    energy_matrix_2 = 0.0E0_realk
!test
    energy_matrix_2_test = 0.0E0_realk
    EpTtest = 0.0E0_realk
!testend

    do i=1,nocc
    AtomI = OccOrbitals(i)%CentralAtom
       do j=1,nocc
       AtomJ = OccOrbitals(j)%CentralAtom
          do a=1,nvirt
             do b=1,nvirt
                EpT211(AtomI,AtomJ) = EpT211(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT31%val(a,i,b,j)
                EpT212(AtomI,AtomJ) = EpT212(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT32%val(a,i,b,j)
                EpT213(AtomI,AtomJ) = EpT213(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT33%val(a,i,b,j)
                EpT214(AtomI,AtomJ) = EpT214(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT34%val(a,i,b,j)
                EpT215(AtomI,AtomJ) = EpT215(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT35%val(a,i,b,j)
                EpT216(AtomI,AtomJ) = EpT216(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT36%val(a,i,b,j)
                EpT217(AtomI,AtomJ) = EpT217(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT41%val(a,i,b,j)
                EpT218(AtomI,AtomJ) = EpT218(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT42%val(a,i,b,j)
                EpT219(AtomI,AtomJ) = EpT219(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT43%val(a,i,b,j)
                EpT2110(AtomI,AtomJ) = EpT2110(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT44%val(a,i,b,j)
                EpT2111(AtomI,AtomJ) = EpT2111(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT45%val(a,i,b,j)
                EpT2112(AtomI,AtomJ) = EpT2112(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT46%val(a,i,b,j)
                EpT221(AtomI,AtomJ) = EpT221(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT51%val(a,i,b,j)
                EpT222(AtomI,AtomJ) = EpT222(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT52%val(a,i,b,j)
                EpT223(AtomI,AtomJ) = EpT223(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT53%val(a,i,b,j)
                EpT224(AtomI,AtomJ) = EpT224(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT54%val(a,i,b,j)
                EpT225(AtomI,AtomJ) = EpT225(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT55%val(a,i,b,j)
                EpT226(AtomI,AtomJ) = EpT226(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT56%val(a,i,b,j)
                EpT227(AtomI,AtomJ) = EpT227(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT61%val(a,i,b,j)
                EpT228(AtomI,AtomJ) = EpT228(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT62%val(a,i,b,j)
                EpT229(AtomI,AtomJ) = EpT229(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT63%val(a,i,b,j)
                EpT2210(AtomI,AtomJ) = EpT2210(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT64%val(a,i,b,j)
                EpT2211(AtomI,AtomJ) = EpT2211(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT65%val(a,i,b,j)
                EpT2212(AtomI,AtomJ) = EpT2212(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT66%val(a,i,b,j)
!test
                EpTtest(AtomI,AtomJ) = EpTtest(AtomI,AtomJ) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astTtest%val(a,i,b,j)
!testend
             end do
          end do
       end do
    end do

    ! Total fragment energy matrix

    do AtomI=1,numatoms
       do AtomJ=1,numatoms
          energy_matrix_2(AtomI,AtomJ) = (EpT211(AtomI,AtomJ) + EpT212(AtomI,AtomJ) + EpT213(AtomI,AtomJ) + &
              & EpT214(AtomI,AtomJ) + EpT215(AtomI,AtomJ) + EpT216(AtomI,AtomJ) - &
              & (EpT217(AtomI,AtomJ) + EpT218(AtomI,AtomJ) + EpT219(AtomI,AtomJ) + &
              & EpT2110(AtomI,AtomJ) + EpT2111(AtomI,AtomJ) + EpT2112(AtomI,AtomJ))) - &
              & (EpT221(AtomI,AtomJ) + EpT222(AtomI,AtomJ) + EpT223(AtomI,AtomJ) + &
              & EpT224(AtomI,AtomJ) + EpT225(AtomI,AtomJ) + EpT226(AtomI,AtomJ) - &
              & (EpT227(AtomI,AtomJ) + EpT228(AtomI,AtomJ) + EpT229(AtomI,AtomJ) + &
              & EpT2210(AtomI,AtomJ) + EpT2211(AtomI,AtomJ) + EpT2212(AtomI,AtomJ)))
!test
          energy_matrix_2_test(AtomI,AtomJ) = EpTtest(AtomI,AtomJ)
!          energy_matrix_2_test(AtomI,AtomJ) = (EpT211(AtomI,AtomJ) + EpT212(AtomI,AtomJ) + EpT213(AtomI,AtomJ) + &
!              & EpT214(AtomI,AtomJ) + EpT215(AtomI,AtomJ) + EpT216(AtomI,AtomJ)) - &
!              & (EpT217(AtomI,AtomJ) + EpT218(AtomI,AtomJ) + EpT219(AtomI,AtomJ) + &
!              & EpT2110(AtomI,AtomJ) + EpT2111(AtomI,AtomJ) + EpT2112(AtomI,AtomJ))
!testend
       end do
    end do

    EpT2occ_single = 0.0E0_realk
!test
    EpT2occ_single_test = 0.0E0_realk
!testend
    do i=1,numatoms
       if(orbitals_assigned(i)) then
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.1#', i, EpT211(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.2#', i, EpT212(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.3#', i, EpT213(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.4#', i, EpT214(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.5#', i, EpT215(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.6#', i, EpT216(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.7#', i, -1.0E0_realk * EpT217(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.8#', i, -1.0E0_realk * EpT218(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.9#', i, -1.0E0_realk * EpT219(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.10#', i, -1.0E0_realk * EpT2110(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.11#', i, -1.0E0_realk * EpT2111(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.12#', i, -1.0E0_realk * EpT2112(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.13#', i, -1.0E0_realk * EpT221(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.14#', i, -1.0E0_realk * EpT222(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.15#', i, -1.0E0_realk * EpT223(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.16#', i, -1.0E0_realk * EpT224(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.17#', i, -1.0E0_realk * EpT225(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.18#', i, -1.0E0_realk * EpT226(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.19#', i, EpT227(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.20#', i, EpT228(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.21#', i, EpT229(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.22#', i, EpT2210(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.23#', i, EpT2211(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.24#', i, EpT2212(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#FULL#', i, energy_matrix_2(i,i)
          EpT2occ_single = EpT2occ_single + energy_matrix_2(i,i)
!test
          EpT2occ_single_test = EpT2occ_single_test + energy_matrix_2_test(i,i)
!testend
       end if
    end do

    ! Total pair fragment energy matrix
    ! Only consider pairs IJ where J>I; thus, move contributions

    do AtomI=1,numatoms
       do AtomJ=AtomI+1,numatoms
          energy_matrix_2(AtomI,AtomJ) = energy_matrix_2(AtomI,AtomJ) + energy_matrix_2(AtomJ,AtomI)
!test
          energy_matrix_2_test(AtomI,AtomJ) = energy_matrix_2_test(AtomI,AtomJ) + energy_matrix_2_test(AtomJ,AtomI)
!testend
          EpT211(AtomI,AtomJ) = EpT211(AtomI,AtomJ) + EpT211(AtomJ,AtomI)
          EpT212(AtomI,AtomJ) = EpT212(AtomI,AtomJ) + EpT212(AtomJ,AtomI)
          EpT213(AtomI,AtomJ) = EpT213(AtomI,AtomJ) + EpT213(AtomJ,AtomI)
          EpT214(AtomI,AtomJ) = EpT214(AtomI,AtomJ) + EpT214(AtomJ,AtomI)
          EpT215(AtomI,AtomJ) = EpT215(AtomI,AtomJ) + EpT215(AtomJ,AtomI)
          EpT216(AtomI,AtomJ) = EpT216(AtomI,AtomJ) + EpT216(AtomJ,AtomI)
          EpT217(AtomI,AtomJ) = EpT217(AtomI,AtomJ) + EpT217(AtomJ,AtomI)
          EpT218(AtomI,AtomJ) = EpT218(AtomI,AtomJ) + EpT218(AtomJ,AtomI)
          EpT219(AtomI,AtomJ) = EpT219(AtomI,AtomJ) + EpT219(AtomJ,AtomI)
          EpT2110(AtomI,AtomJ) = EpT2110(AtomI,AtomJ) + EpT2110(AtomJ,AtomI)
          EpT2111(AtomI,AtomJ) = EpT2111(AtomI,AtomJ) + EpT2111(AtomJ,AtomI)
          EpT2112(AtomI,AtomJ) = EpT2112(AtomI,AtomJ) + EpT2112(AtomJ,AtomI)
          EpT221(AtomI,AtomJ) = EpT221(AtomI,AtomJ) + EpT221(AtomJ,AtomI)
          EpT222(AtomI,AtomJ) = EpT222(AtomI,AtomJ) + EpT222(AtomJ,AtomI)
          EpT223(AtomI,AtomJ) = EpT223(AtomI,AtomJ) + EpT223(AtomJ,AtomI)
          EpT224(AtomI,AtomJ) = EpT224(AtomI,AtomJ) + EpT224(AtomJ,AtomI)
          EpT225(AtomI,AtomJ) = EpT225(AtomI,AtomJ) + EpT225(AtomJ,AtomI)
          EpT226(AtomI,AtomJ) = EpT226(AtomI,AtomJ) + EpT226(AtomJ,AtomI)
          EpT227(AtomI,AtomJ) = EpT227(AtomI,AtomJ) + EpT227(AtomJ,AtomI)
          EpT228(AtomI,AtomJ) = EpT228(AtomI,AtomJ) + EpT228(AtomJ,AtomI)
          EpT229(AtomI,AtomJ) = EpT229(AtomI,AtomJ) + EpT229(AtomJ,AtomI)
          EpT2210(AtomI,AtomJ) = EpT2210(AtomI,AtomJ) + EpT2210(AtomJ,AtomI)
          EpT2211(AtomI,AtomJ) = EpT2211(AtomI,AtomJ) + EpT2211(AtomJ,AtomI)
          EpT2212(AtomI,AtomJ) = EpT2212(AtomI,AtomJ) + EpT2212(AtomJ,AtomI)
!test
          EpTtest(AtomI,AtomJ) = EpTtest(AtomI,AtomJ) + EpTtest(AtomJ,AtomI)
!testend
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Pair fragments [EpT2]'
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'
    write(DECinfo%output,'(8X,a)') '   P         Q        R(Ang)           deltaE(PQ) '
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'

    EpT2occ_pair = 0.0E0_realk
    EpT2occ_pair_test = 0.0E0_realk
    do i=1,numatoms
       do j=i+1,numatoms
          ! write increments only if pair interaction energy is nonzero
          if( orbitals_assigned(i) .and. orbitals_assigned(j) ) then
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.1#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT211(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.2#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT212(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.3#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT213(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.4#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT214(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.5#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT215(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.6#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT216(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.7#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT217(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.8#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT218(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.9#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT219(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.10#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT2110(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.11#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT2111(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.12#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT2112(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.13#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT221(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.14#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT222(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.15#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT223(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.16#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT224(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.17#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT225(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.18#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT226(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.19#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT227(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.20#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT228(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.21#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT229(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.22#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT2210(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.23#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT2211(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.24#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT2212(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#FULL#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), energy_matrix_2(i,j)
             EpT2occ_pair = EpT2occ_pair + energy_matrix_2(i,j)
!test
             EpT2occ_pair_test = EpT2occ_pair_test + energy_matrix_2_test(i,j)
!testend
          end if
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Atomic fragment energy [EpT2]   = ', EpT2occ_single
    write(DECinfo%output,'(1X,a,g20.10)') 'Pair atomic fragment en. [EpT2] = ', EpT2occ_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'Total EpT2 corr. energy [EpT2]  = ', EpT2occ_single + EpT2occ_pair
!test
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Atomic fragment energy [TEST]   = ', EpT2occ_single_test
    write(DECinfo%output,'(1X,a,g20.10)') 'Pair atomic fragment en. [TEST] = ', EpT2occ_pair_test
    write(DECinfo%output,'(1X,a,g20.10)') 'Total EpT2-TEST corr. energy [TEST]  = ', &
         & EpT2occ_single_test + EpT2occ_pair_test
!testend
    write(DECinfo%output,'(1X,a)')

    call mem_dealloc(EpT211)
    call mem_dealloc(EpT212)
    call mem_dealloc(EpT213)
    call mem_dealloc(EpT214)
    call mem_dealloc(EpT215)
    call mem_dealloc(EpT216)
    call mem_dealloc(EpT217)
    call mem_dealloc(EpT218)
    call mem_dealloc(EpT219)
    call mem_dealloc(EpT2110)
    call mem_dealloc(EpT2111)
    call mem_dealloc(EpT2112)
    call mem_dealloc(EpT221)
    call mem_dealloc(EpT222)
    call mem_dealloc(EpT223)
    call mem_dealloc(EpT224)
    call mem_dealloc(EpT225)
    call mem_dealloc(EpT226)
    call mem_dealloc(EpT227)
    call mem_dealloc(EpT228)
    call mem_dealloc(EpT229)
    call mem_dealloc(EpT2210)
    call mem_dealloc(EpT2211)
    call mem_dealloc(EpT2212)
    call mem_dealloc(energy_matrix_2)
!test
    call mem_dealloc(energy_matrix_2_test)
    call mem_dealloc(EpTtest)
!testend

    ! Next, we calculate the EpT2 part of the CCSD(T) corr. energy in the unoccupied partitioning scheme

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,'(1X,a)') '*         Full DEC EpT2 calculation is done (unocc. part. scheme)!          *'
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Atomic fragments [EpT2]'
    write(DECinfo%output,'(8X,a)') '------    --------------------'
    write(DECinfo%output,'(8X,a)') ' Atom            Energy '
    write(DECinfo%output,'(8X,a)') '------    --------------------'

    call mem_alloc(EpT211,numatoms,numatoms)
    call mem_alloc(EpT212,numatoms,numatoms)
    call mem_alloc(EpT213,numatoms,numatoms)
    call mem_alloc(EpT214,numatoms,numatoms)
    call mem_alloc(EpT215,numatoms,numatoms)
    call mem_alloc(EpT216,numatoms,numatoms)
    call mem_alloc(EpT217,numatoms,numatoms)
    call mem_alloc(EpT218,numatoms,numatoms)
    call mem_alloc(EpT219,numatoms,numatoms)
    call mem_alloc(EpT2110,numatoms,numatoms)
    call mem_alloc(EpT2111,numatoms,numatoms)
    call mem_alloc(EpT2112,numatoms,numatoms)
    call mem_alloc(EpT221,numatoms,numatoms)
    call mem_alloc(EpT222,numatoms,numatoms)
    call mem_alloc(EpT223,numatoms,numatoms)
    call mem_alloc(EpT224,numatoms,numatoms)
    call mem_alloc(EpT225,numatoms,numatoms)
    call mem_alloc(EpT226,numatoms,numatoms)
    call mem_alloc(EpT227,numatoms,numatoms)
    call mem_alloc(EpT228,numatoms,numatoms)
    call mem_alloc(EpT229,numatoms,numatoms)
    call mem_alloc(EpT2210,numatoms,numatoms)
    call mem_alloc(EpT2211,numatoms,numatoms)
    call mem_alloc(EpT2212,numatoms,numatoms)
    call mem_alloc(energy_matrix_2,numatoms,numatoms)
    EpT211 = 0.0E0_realk; EpT212 = 0.0E0_realk; EpT213 = 0.0E0_realk; EpT214 = 0.0E0_realk
    EpT215 = 0.0E0_realk; EpT216 = 0.0E0_realk; EpT217 = 0.0E0_realk; EpT218 = 0.0E0_realk
    EpT219 = 0.0E0_realk; EpT2110 = 0.0E0_realk; EpT2111 = 0.0E0_realk; EpT2112 = 0.0E0_realk
    EpT221 = 0.0E0_realk; EpT222 = 0.0E0_realk; EpT223 = 0.0E0_realk; EpT224 = 0.0E0_realk
    EpT225 = 0.0E0_realk; EpT226 = 0.0E0_realk; EpT227 = 0.0E0_realk; EpT228 = 0.0E0_realk
    EpT229 = 0.0E0_realk; EpT2210 = 0.0E0_realk; EpT2211 = 0.0E0_realk; EpT2212 = 0.0E0_realk
    energy_matrix_2 = 0.0E0_realk

    do a=1,nvirt
    AtomA = UnoccOrbitals(a)%CentralAtom
       do b=1,nvirt
       AtomB = UnoccOrbitals(b)%CentralAtom
          do i=1,nocc
             do j=1,nocc
                EpT211(AtomA,AtomB) = EpT211(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT31%val(a,i,b,j)
                EpT212(AtomA,AtomB) = EpT212(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT32%val(a,i,b,j)
                EpT213(AtomA,AtomB) = EpT213(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT33%val(a,i,b,j)
                EpT214(AtomA,AtomB) = EpT214(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT34%val(a,i,b,j)
                EpT215(AtomA,AtomB) = EpT215(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT35%val(a,i,b,j)
                EpT216(AtomA,AtomB) = EpT216(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT36%val(a,i,b,j)
                EpT217(AtomA,AtomB) = EpT217(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT41%val(a,i,b,j)
                EpT218(AtomA,AtomB) = EpT218(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT42%val(a,i,b,j)
                EpT219(AtomA,AtomB) = EpT219(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT43%val(a,i,b,j)
                EpT2110(AtomA,AtomB) = EpT2110(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT44%val(a,i,b,j)
                EpT2111(AtomA,AtomB) = EpT2111(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT45%val(a,i,b,j)
                EpT2112(AtomA,AtomB) = EpT2112(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT46%val(a,i,b,j)
                EpT221(AtomA,AtomB) = EpT221(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT51%val(a,i,b,j)
                EpT222(AtomA,AtomB) = EpT222(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT52%val(a,i,b,j)
                EpT223(AtomA,AtomB) = EpT223(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT53%val(a,i,b,j)
                EpT224(AtomA,AtomB) = EpT224(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT54%val(a,i,b,j)
                EpT225(AtomA,AtomB) = EpT225(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT55%val(a,i,b,j)
                EpT226(AtomA,AtomB) = EpT226(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT56%val(a,i,b,j)
                EpT227(AtomA,AtomB) = EpT227(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT61%val(a,i,b,j)
                EpT228(AtomA,AtomB) = EpT228(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT62%val(a,i,b,j)
                EpT229(AtomA,AtomB) = EpT229(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT63%val(a,i,b,j)
                EpT2210(AtomA,AtomB) = EpT2210(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT64%val(a,i,b,j)
                EpT2211(AtomA,AtomB) = EpT2211(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT65%val(a,i,b,j)
                EpT2212(AtomA,AtomB) = EpT2212(AtomA,AtomB) + &
                       & (4.0E0_realk * Taibj%val(a,i,b,j) - 2.0E0_realk * Taibj%val(a,j,b,i)) * &
                       & astT66%val(a,i,b,j)
             end do
          end do
       end do
    end do

    ! Total fragment energy matrix

    do AtomA=1,numatoms
       do AtomB=1,numatoms
          energy_matrix_2(AtomA,AtomB) = (EpT211(AtomA,AtomB) + EpT212(AtomA,AtomB) + EpT213(AtomA,AtomB) + &
              & EpT214(AtomA,AtomB) + EpT215(AtomA,AtomB) + EpT216(AtomA,AtomB) - &
              & (EpT217(AtomA,AtomB) + EpT218(AtomA,AtomB) + EpT219(AtomA,AtomB) + &
              & EpT2110(AtomA,AtomB) + EpT2111(AtomA,AtomB) + EpT2112(AtomA,AtomB))) - &
              & (EpT221(AtomA,AtomB) + EpT222(AtomA,AtomB) + EpT223(AtomA,AtomB) + &
              & EpT224(AtomA,AtomB) + EpT225(AtomA,AtomB) + EpT226(AtomA,AtomB) - &
              & (EpT227(AtomA,AtomB) + EpT228(AtomA,AtomB) + EpT229(AtomA,AtomB) + &
              & EpT2210(AtomA,AtomB) + EpT2211(AtomA,AtomB) + EpT2212(AtomA,AtomB)))
       end do
    end do

    ! These should be dealloc later on if we want to evaluate them individually.
    ! Also, remember to consider the pair in the same way as is done in the case of
    ! energy_matrix_2 below, that is, do, e.g.,
    ! EpT211(AtomI,AtomJ) = EpT211(AtomI,AtomJ) + EpT211(AtomJ,AtomI) for J>I

    EpT2virt_single = 0.0E0_realk
    do i=1,numatoms
       if(orbitals_assigned(i)) then
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.1#', i, EpT211(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.2#', i, EpT212(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.3#', i, EpT213(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.4#', i, EpT214(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.5#', i, EpT215(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.6#', i, EpT216(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.7#', i, -1.0E0_realk * EpT217(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.8#', i, -1.0E0_realk * EpT218(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#NO.9#', i, -1.0E0_realk * EpT219(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.10#', i, -1.0E0_realk * EpT2110(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.11#', i, -1.0E0_realk * EpT2111(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.12#', i, -1.0E0_realk * EpT2112(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.13#', i, -1.0E0_realk * EpT221(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.14#', i, -1.0E0_realk * EpT222(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.15#', i, -1.0E0_realk * EpT223(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.16#', i, -1.0E0_realk * EpT224(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.17#', i, -1.0E0_realk * EpT225(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.18#', i, -1.0E0_realk * EpT226(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.19#', i, EpT227(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.20#', i, EpT228(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.21#', i, EpT229(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.22#', i, EpT2210(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.23#', i, EpT2211(i,i)
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#NO.24#', i, EpT2212(i,i)
          write(DECinfo%output,'(1X,a,i7,4X,g20.10)') '#FULL#', i, energy_matrix_2(i,i)
          EpT2virt_single = EpT2virt_single + energy_matrix_2(i,i)
       end if
    end do

    ! Total pair fragment energy matrix
    ! Only consider pairs IJ where J>I; thus, move contributions

    do AtomA=1,numatoms
       do AtomB=AtomA+1,numatoms
          energy_matrix_2(AtomA,AtomB) = energy_matrix_2(AtomA,AtomB) + energy_matrix_2(AtomB,AtomA)
          EpT211(AtomA,AtomB) = EpT211(AtomA,AtomB) + EpT211(AtomB,AtomA)
          EpT212(AtomA,AtomB) = EpT212(AtomA,AtomB) + EpT212(AtomB,AtomA)
          EpT213(AtomA,AtomB) = EpT213(AtomA,AtomB) + EpT213(AtomB,AtomA)
          EpT214(AtomA,AtomB) = EpT214(AtomA,AtomB) + EpT214(AtomB,AtomA)
          EpT215(AtomA,AtomB) = EpT215(AtomA,AtomB) + EpT215(AtomB,AtomA)
          EpT216(AtomA,AtomB) = EpT216(AtomA,AtomB) + EpT216(AtomB,AtomA)
          EpT217(AtomA,AtomB) = EpT217(AtomA,AtomB) + EpT217(AtomB,AtomA)
          EpT218(AtomA,AtomB) = EpT218(AtomA,AtomB) + EpT218(AtomB,AtomA)
          EpT219(AtomA,AtomB) = EpT219(AtomA,AtomB) + EpT219(AtomB,AtomA)
          EpT2110(AtomA,AtomB) = EpT2110(AtomA,AtomB) + EpT2110(AtomB,AtomA)
          EpT2111(AtomA,AtomB) = EpT2111(AtomA,AtomB) + EpT2111(AtomB,AtomA)
          EpT2112(AtomA,AtomB) = EpT2112(AtomA,AtomB) + EpT2112(AtomB,AtomA)
          EpT221(AtomA,AtomB) = EpT221(AtomA,AtomB) + EpT221(AtomB,AtomA)
          EpT222(AtomA,AtomB) = EpT222(AtomA,AtomB) + EpT222(AtomB,AtomA)
          EpT223(AtomA,AtomB) = EpT223(AtomA,AtomB) + EpT223(AtomB,AtomA)
          EpT224(AtomA,AtomB) = EpT224(AtomA,AtomB) + EpT224(AtomB,AtomA)
          EpT225(AtomA,AtomB) = EpT225(AtomA,AtomB) + EpT225(AtomB,AtomA)
          EpT226(AtomA,AtomB) = EpT226(AtomA,AtomB) + EpT226(AtomB,AtomA)
          EpT227(AtomA,AtomB) = EpT227(AtomA,AtomB) + EpT227(AtomB,AtomA)
          EpT228(AtomA,AtomB) = EpT228(AtomA,AtomB) + EpT228(AtomB,AtomA)
          EpT229(AtomA,AtomB) = EpT229(AtomA,AtomB) + EpT229(AtomB,AtomA)
          EpT2210(AtomA,AtomB) = EpT2210(AtomA,AtomB) + EpT2210(AtomB,AtomA)
          EpT2211(AtomA,AtomB) = EpT2211(AtomA,AtomB) + EpT2211(AtomB,AtomA)
          EpT2212(AtomA,AtomB) = EpT2212(AtomA,AtomB) + EpT2212(AtomB,AtomA)
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Pair fragments [EpT2]'
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'
    write(DECinfo%output,'(8X,a)') '   P         Q        R(Ang)           deltaE(PQ) '
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'

    EpT2virt_pair = 0.0E0_realk
    do i=1,numatoms
       do j=i+1,numatoms
          ! write increments only if pair interaction energy is nonzero
          if( orbitals_assigned(i) .and. orbitals_assigned(j) ) then
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.1#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT211(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.2#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT212(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.3#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT213(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.4#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT214(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.5#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT215(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.6#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT216(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.7#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT217(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.8#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT218(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#NO.9#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT219(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.10#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT2110(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.11#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT2111(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.12#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT2112(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.13#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT221(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.14#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT222(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.15#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT223(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.16#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT224(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.17#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT225(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.18#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), -1.0E0_realk * EpT226(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.19#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT227(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.20#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT228(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.21#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT229(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.22#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT2210(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.23#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT2211(i,j)
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#NO.24#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), EpT2212(i,j)
             write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#FULL#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), energy_matrix_2(i,j)
             EpT2virt_pair = EpT2virt_pair + energy_matrix_2(i,j)
          end if
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Atomic fragment energy [EpT2]   = ', EpT2virt_single
    write(DECinfo%output,'(1X,a,g20.10)') 'Pair atomic fragment en. [EpT2] = ', EpT2virt_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'Total EpT2 corr. energy [EpT2]  = ', EpT2virt_single + EpT2virt_pair
    write(DECinfo%output,'(1X,a)')

    call mem_dealloc(EpT211)
    call mem_dealloc(EpT212)
    call mem_dealloc(EpT213)
    call mem_dealloc(EpT214)
    call mem_dealloc(EpT215)
    call mem_dealloc(EpT216)
    call mem_dealloc(EpT217)
    call mem_dealloc(EpT218)
    call mem_dealloc(EpT219)
    call mem_dealloc(EpT2110)
    call mem_dealloc(EpT2111)
    call mem_dealloc(EpT2112)
    call mem_dealloc(EpT221)
    call mem_dealloc(EpT222)
    call mem_dealloc(EpT223)
    call mem_dealloc(EpT224)
    call mem_dealloc(EpT225)
    call mem_dealloc(EpT226)
    call mem_dealloc(EpT227)
    call mem_dealloc(EpT228)
    call mem_dealloc(EpT229)
    call mem_dealloc(EpT2210)
    call mem_dealloc(EpT2211)
    call mem_dealloc(EpT2212)
    call mem_dealloc(energy_matrix_2)

    ! #############
    ! ## Summary ##
    ! #############

    ECCSDocc = ECCSDocc_single + ECCSDocc_pair
    ECCSDvirt = ECCSDvirt_single + ECCSDvirt_pair
    EpTocc = EpT1_pair + EpT2occ_single + EpT2occ_pair
    EpTvirt = EpT1_pair + EpT2virt_single + EpT2virt_pair

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,'(1X,a)') '*                  Full DEC CCSD(T) calculation is done!                    *'
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '-------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Total CCSD corr. en. (occ. part. scheme)         =', ECCSDocc
    write(DECinfo%output,'(1X,a,g20.10)') 'Total CCSD corr. en. (unocc. part. scheme)       =', ECCSDvirt
    write(DECinfo%output,'(1X,a,g20.10)') 'The E5 singles and triples                       =', EpT1_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'The E4 doubles and triples (occ. part. scheme)   =', &
         & EpT2occ_single + EpT2occ_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'The E4 doubles and triples (unocc. part. scheme) =', &
         & EpT2virt_single + EpT2virt_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'Total CCSD(T) corr. energy (occ. part. scheme)   =', EpTocc
    write(DECinfo%output,'(1X,a,g20.10)') 'Total CCSD(T) corr. energy (unocc. part. scheme) =', EpTvirt
    write(DECinfo%output,'(1X,a)')

    ! Add contributions
!    Energy = ECCSD + EpT

    ! Clean up
    ! ********
    call mem_dealloc(eivalocc)
    call mem_dealloc(eivalvirt)
    call mem_dealloc(DistanceTable)
    do i=1,nocc
       call orbital_free(OccOrbitals(i))
    end do
    call mem_dealloc(OccOrbitals)
    do i=1,nvirt
       call orbital_free(UnoccOrbitals(i))
    end do
    call mem_dealloc(UnoccOrbitals)
    call mem_dealloc(orbitals_assigned)
    call array2_free(Cocc)
    call array2_free(Cvirt)
    call mem_dealloc(AIBJ)
    call mem_dealloc(AIBC)
    call mem_dealloc(AIJK)
    call mem_dealloc(gao)
    call array4_free(Taibj)
    call array4_free(canTaibj)
    call array4_free(canAIBJ)
    call array4_free(canAIBC)
    call array4_free(canAIJK)
    call array4_free(astT31); call array4_free(astT32); call array4_free(astT33)
    call array4_free(astT34); call array4_free(astT35); call array4_free(astT36)
    call array4_free(astT41); call array4_free(astT42); call array4_free(astT43)
    call array4_free(astT44); call array4_free(astT45); call array4_free(astT46)
    call array4_free(astT51); call array4_free(astT52); call array4_free(astT53)
    call array4_free(astT54); call array4_free(astT55); call array4_free(astT56)
    call array4_free(astT61); call array4_free(astT62); call array4_free(astT63)
    call array4_free(astT64); call array4_free(astT65); call array4_free(astT66)
!test
    call array4_free(astTtest)
!testend
    call array2_free(Tai)
    call array2_free(canTai)


  end subroutine full_ccsd_parenthesisT

  !> \brief driver routine for new, optimized CCSD(T) implementation
  !> To begin with, we only test the code on the EpT21 term (i.e. the
  ! individual 12 EpT2X terms) in the occ. part. scheme
  !> \author Janus Juul Eriksen
  !> \date July 2012
  subroutine full_ccsd_parenthesisT_new(MyMolecule,MyLsitem,energy)

    implicit none

    !> Full molecule info
    type(fullmolecule), intent(in) :: MyMolecule
    !> Lsitem structure
    type(lsitem), intent(inout) :: mylsitem
    !> Correlation energy
    real(realk), intent(inout) :: energy
    real(realk), pointer :: gao(:,:,:,:)
    real(realk), pointer :: AIBJ(:,:,:,:)
    real(realk), pointer :: AIBC(:,:,:,:)
    real(realk), pointer :: AIJK(:,:,:,:)
    integer :: ncabs, ncabsAO, nocc,nvirt,nbasis,noccfull, i,j,k,a, p,pdx, tuple_type
!    integer :: ncabs, ncabsAO, nocc,nvirt,nbasis,noccfull, i,j,k,l,a,b,c,d,e,m,p,ix,iy, tuple_type
    type(array2) :: Tai
    type(array4) :: Taibj
    !> orbital input
    integer, dimension(2) :: occdims, virtdims, virtoccdims, numdims
    type(array4) :: canAIBJ, canAIBC, canAIJK, canTaibj
    type(ccorbital), pointer :: OccOrbitals(:)
    type(ccorbital), pointer :: UnoccOrbitals(:)
    real(realk), pointer :: DistanceTable(:,:)
    integer :: AtomA, AtomB, AtomI, AtomJ, my_atom, numatoms,start,end
    logical, pointer :: orbitals_assigned(:)
    !> input for the local-canonical transformation
    type(array4) :: AIBJ_tmp, AIBC_tmp, AIJK_tmp
    type(array4) :: tmp11, tmp12, tmp13, tmp14, tmp21, tmp22, tmp23, tmp24
    real(realk), pointer :: Cocc_data(:,:), Cvirt_data(:,:), Socc(:,:), Svirt(:,:)
    real(realk), pointer :: eivalocc(:), eivalvirt(:)
    type(array2) :: Cocc, Cvirt, tmp01
    integer, dimension(4) :: dims_aiai, dims_iaai, dims_aiaa, dims_iaaa, dims_aaai
    integer, dimension(4) :: dims_aiii, dims_iaii, dims_iiai, dims_aaii, dims_iiaa
    integer, dimension(3) :: dims_aaa
    !> input for the actual triples computation
    type(array2) :: energy_matrix_ccsdpt_1, energy_matrix_ccsdpt_2
    type(array3) :: trip_iii, trip_iik, trip_iki, trip_kii, trip_ijj, trip_jij, trip_jji
    type(array3) :: trip_ijk, trip_kij, trip_jki, trip_ikj, trip_jik, trip_kji
    type(array4) :: T_ast, T_ast_1, T_ast_2, doub_interm
    type(array2) :: T_ast_0, energy_interm_cou, energy_interm_exc, energy_interm_T_ast
    !> time measurements and energy reals
    real(realk) :: energy_res_cou, energy_res_exc, ECCSDpt_1, ECCSDpt_2_single, ECCSDpt_2_pair

    print *, 'Entering *NEW* CCSD(T) toy code'

    ! Init dimensions
    if(DECinfo%FrozenCore) then
       nocc = MyMolecule%nval
       start = MyMolecule%ncore+1  
    else
       nocc = MyMolecule%numocc
       start = 1
    end if
    end = MyMolecule%numocc
    nvirt = MyMolecule%numvirt
    nbasis = MyMolecule%nbasis
    numatoms = MyMolecule%natoms
    noccfull = nocc


    call determine_CABS_nbast(ncabsAO,ncabs,mylsitem%setting,DECinfo%output)

    ! Get full CCSD singles (Tai) and doubles (Taibj) amplitudes
    call full_get_ccsd_singles_and_doubles(MyMolecule,MyLsitem,Tai,Taibj)

    ! Get all AO integrals in regular basis
    call mem_alloc(gao,nbasis,nbasis,nbasis,nbasis)
    gao = 0.0E0_realk
    call get_full_AO_integrals(nbasis,ncabsAO,gao,MyLsitem,'RRRRC')

    ! Transform AO integrals to MO integrals (A I | B J)
    call get_4Center_MO_integrals(mylsitem,DECinfo%output,nbasis,nocc,noccfull,nvirt,&
         & MyMolecule%ypo(1:nbasis,start:end), MyMolecule%ypv,'aiai',gAO,AIBJ)

    ! Transform AO integrals to MO integrals (A I | B C)
    ! equal to (I A | B C), that is, iaaa, and (B C | I A), i.e., aaia
    call get_4Center_MO_integrals(mylsitem,DECinfo%output,nbasis,nocc,noccfull,nvirt,&
         & MyMolecule%ypo(1:nbasis,start:end), MyMolecule%ypv,'aiaa',gAO,AIBC)

    ! Transform AO integrals to MO integrals (A I | J K)
    ! equal to (J K | I A), that is, iiia, and (J K | A I), i.e., iiai
    call get_4Center_MO_integrals(mylsitem,DECinfo%output,nbasis,nocc,noccfull,nvirt,&
         & MyMolecule%ypo(1:nbasis,start:end), MyMolecule%ypv,'aiii',gAO,AIJK)

    ! dealloc gao pointer
    call mem_dealloc(gao)

    ! For locality analysis purposes we need DistanceTable and OccOrbitals/
    ! UnoccOrbitals (adapted from fragment_energy.f90)

    ! -- Calculate distance matrix
    call mem_alloc(DistanceTable,numatoms,numatoms)
    DistanceTable=0.0E0_realk
    call GetDistances(DistanceTable,numatoms,mylsitem,DECinfo%output) ! distances in atomic units

    ! -- Analyze basis and create orbitals
    call mem_alloc(OccOrbitals,nocc)
    call mem_alloc(UnoccOrbitals,nvirt)
    call GenerateOrbitals_driver(MyMolecule,mylsitem,nocc,nvirt,numatoms, &
         & OccOrbitals, UnoccOrbitals, DistanceTable)

    ! Orbital assignment
    call mem_alloc(orbitals_assigned,numatoms)
    orbitals_assigned=.false.
    do p=1,nocc
       pdx = OccOrbitals(p)%centralatom
       orbitals_assigned(pdx) = .true.
    end do
    do p=1,nvirt
       pdx = UnoccOrbitals(p)%centralatom
       orbitals_assigned(pdx) = .true.
    end do

    ! In order to calculate the perturbed triples amplitudes, we need to transform the above
    ! 2-el integral and doubles amplitude quantities into canonical basis.
    ! We end the transformation section by transposing the eigenvectors as we will need to
    ! transform back into local basis when we want to perform our locality analyses.
    !
    ! Transformation stuff adpated from cc_driver.f90 and appropriately modified

    call mem_alloc(Socc,nocc,nocc)
    call mem_alloc(Svirt,nvirt,nvirt)
    call mem_alloc(Cocc_data,nocc,nocc)
    call mem_alloc(Cvirt_data,nvirt,nvirt)
    call mem_alloc(eivalocc,nocc)
    call mem_alloc(eivalvirt,nvirt)

    ! Initialize stuff pt. 1
    ! ****************
    occdims = [nocc,nocc]
    virtdims = [nvirt,nvirt]
    virtoccdims = [nvirt,nocc]
    numdims = [numatoms,numatoms]

    ! make occ-occ and virt-virt identity matrices

    Socc = 0.0E0_realk
    do i=1,nocc
       Socc(i,i) = 1.0E0_realk
    end do
    Svirt = 0.0E0_realk
    do j=1,nvirt
       Svirt(j,j) = 1.0E0_realk
    end do

    ! solve for eivals and C matrices

    call solve_eigenvalue_problem(nocc,MyMolecule%ppfock(start:end,start:end),Socc,eivalocc,Cocc_data)
    call solve_eigenvalue_problem(nvirt,MyMolecule%qqfock,Svirt,eivalvirt,Cvirt_data)

    Cocc = array2_init_data(occdims,Cocc_data)
    Cvirt = array2_init_data(virtdims,Cvirt_data)

    call mem_dealloc(Socc)
    call mem_dealloc(Svirt)
    call mem_dealloc(Cocc_data)
    call mem_dealloc(Cvirt_data)

    ! **********************************************************************************
    ! Transform two-electron integrals, singles and doubles amplitudes to diagonal basis
    ! **********************************************************************************

    ! Using notation that (a,i,b,j) are LCM indices
    ! and (A,I,B,J) are indices in the diagonal basis,
    ! we want to carry out the transformations (for 2-el integrals):
    ! RHS_{AIBJ} = sum_{aibj} C_{aA} C_{iI} C_{bB} C_{jJ} RHS_{aibj} (*)

    ! Transform doubles amplitudes and the three kinds of 2-el integrals

    ! Initialize stuff
    ! ****************
    dims_aiai = [nvirt,nocc,nvirt,nocc]
    dims_iaai = [nocc,nvirt,nvirt,nocc]
    dims_aiaa = [nvirt,nocc,nvirt,nvirt]
    dims_iaaa = [nocc,nvirt,nvirt,nvirt]
    dims_aaai = [nvirt,nvirt,nvirt,nocc]
    dims_aiii = [nvirt,nocc,nocc,nocc]
    dims_iaii = [nocc,nvirt,nocc,nocc]
    dims_iiai = [nocc,nocc,nvirt,nocc]
    dims_aaii = [nvirt,nvirt,nocc,nocc]
    dims_iiaa = [nocc,nocc,nvirt,nvirt]
    dims_aaa = [nvirt,nvirt,nvirt]

    ! 1. Init temporary arrays
    tmp11 = array4_init_standard(dims_aiai)
    tmp12 = array4_init_standard(dims_aiaa)
    tmp13 = array4_init_standard(dims_aiii)
    tmp14 = array4_init_standard(dims_aiai)
    AIBJ_tmp = array4_init_standard(dims_aiai)
    AIBC_tmp = array4_init_standard(dims_aiaa)
    AIJK_tmp = array4_init_standard(dims_aiii)
    call dcopy(nocc**2*nvirt**2,AIBJ,1,AIBJ_tmp%val,1)
    call dcopy(nocc*nvirt**3,AIBC,1,AIBC_tmp%val,1)
    call dcopy(nvirt*nocc**3,AIJK,1,AIJK_tmp%val,1)

    ! dealloc AIBJ, AIBC, and AIJK pointers
    call mem_dealloc(AIBJ)
    call mem_dealloc(AIBC)
    call mem_dealloc(AIJK)

    ! 2. 1st index:
    ! 1. line: AIBJ(a,i,b,j) --> tmp11(A,i,b,j)
    ! 2. line: AIBC(a,i,b,c) --> tmp12(A,i,b,c,)
    ! 3. line: AIJK(a,i,j,k) --> tmp13(A,i,j,k)
    ! 4. line: Taibj(a,i,b,j) --> tmp14(A,i,b,j)
    call array4_contract1(AIBJ_tmp,Cvirt,tmp11,.true.)
    call array4_contract1(AIBC_tmp,Cvirt,tmp12,.true.)
    call array4_contract1(AIJK_tmp,Cvirt,tmp13,.true.)
    call array4_contract1(Taibj,Cvirt,tmp14,.true.)
    call array4_free(AIBJ_tmp)
    call array4_free(AIBC_tmp)
    call array4_free(AIJK_tmp)

    ! 3. 2nd index:
    ! 1. line: tmp11(A,i,b,j) --> tmp11(i,A,b,j) --> tmp21(I,A,b,j)
    ! 2. line: tmp12(A,i,b,c) --> tmp12(i,A,b,c) --> tmp22(I,A,b,c)
    ! 3. line: tmp13(A,i,j,k) --> tmp13(i,A,j,k) --> tmp23(I,A,j,k)
    ! 4. line: tmp14(A,i,b,j) --> tmp14(i,A,b,j) --> tmp24(I,A,b,j)
    call array4_reorder(tmp11,[2,1,3,4])
    call array4_reorder(tmp12,[2,1,3,4])
    call array4_reorder(tmp13,[2,1,3,4])
    call array4_reorder(tmp14,[2,1,3,4])
    tmp21 = array4_init_standard(dims_iaai)
    tmp22 = array4_init_standard(dims_iaaa)
    tmp23 = array4_init_standard(dims_iaii)
    tmp24 = array4_init_standard(dims_iaai)
    call array4_contract1(tmp11,Cocc,tmp21,.true.)
    call array4_contract1(tmp12,Cocc,tmp22,.true.)
    call array4_contract1(tmp13,Cocc,tmp23,.true.)
    call array4_contract1(tmp14,Cocc,tmp24,.true.)
    call array4_free(tmp11)
    call array4_free(tmp12)
    call array4_free(tmp13)
    call array4_free(tmp14)

    ! 4. 3rd index:
    ! 1. line: tmp21(I,A,b,j) --> tmp21(j,b,A,I) --> tmp11(J,b,A,I)
    ! 2. line: tmp22(I,A,b,c) --> tmp22(c,b,A,I) --> tmp12(C,b,A,I)
    ! 3. line: tmp23(I,A,j,k) --> tmp23(k,j,A,I) --> tmp13(K,j,A,I)
    ! 4. line; tmp24(I,A,b,j) --> tmp24(j,b,A,I) --> tmp14(J,b,A,I)
    call array4_reorder(tmp21,[4,3,2,1])
    call array4_reorder(tmp22,[4,3,2,1])
    call array4_reorder(tmp23,[4,3,2,1])
    call array4_reorder(tmp24,[4,3,2,1])
    tmp11 = array4_init_standard(dims_iaai)
    tmp12 = array4_init_standard(dims_aaai)
    tmp13 = array4_init_standard(dims_iiai)
    tmp14 = array4_init_standard(dims_iaai)
    call array4_contract1(tmp21,Cocc,tmp11,.true.)
    call array4_contract1(tmp22,Cvirt,tmp12,.true.)
    call array4_contract1(tmp23,Cocc,tmp13,.true.)
    call array4_contract1(tmp24,Cocc,tmp14,.true.)
    call array4_free(tmp21)
    call array4_free(tmp22)
    call array4_free(tmp23)
    call array4_free(tmp24)

    ! 5. 4th index:
    ! 1. line: tmp11(J,b,A,I) --> tmp11(b,J,A,I) --> canBJAI(B,J,A,I) = canAIBJ (*)
    ! 2. line: tmp12(C,b,A,I) --> tmp12(b,C,A,I) --> canBCAI(B,C,A,I) = canAIBC (**)
    ! 3. line: tmp13(K,j,A,I) --> tmp13(j,K,A,I) --> canJKAI(J,K,A,I) = canAIJK (**)
    ! 4. line: tmp14(J,b,A,I) --> tmp14(b,J,A,I) --> canTbjai(B,J,A,I) = canTaibj (*)
    ! (*) due to permutational symmetry
    ! (**) dimensions of array4 need be reordered
    call array4_reorder(tmp11,[2,1,3,4])
    call array4_reorder(tmp12,[2,1,3,4])
    call array4_reorder(tmp13,[2,1,3,4])
    call array4_reorder(tmp14,[2,1,3,4])
    canAIBJ = array4_init_standard(dims_aiai)
    canAIBC = array4_init_standard(dims_aaai)
    canAIJK = array4_init_standard(dims_iiai)
    canTaibj = array4_init_standard(dims_aiai)
    call array4_contract1(tmp11,Cvirt,canAIBJ,.true.)
    call array4_contract1(tmp12,Cvirt,canAIBC,.true.)
    call array4_contract1(tmp13,Cocc,canAIJK,.true.)
    call array4_contract1(tmp14,Cvirt,canTaibj,.true.)
    call array4_reorder(canAIBC,[3,4,1,2])
    call array4_reorder(canAIJK,[3,4,1,2])
    call array4_free(tmp11)
    call array4_free(tmp12)
    call array4_free(tmp13)
    call array4_free(tmp14)

    ! Now we transpose the eigenvectors as we will need these in the transformation
    ! of the ^{*}T^{a}_{i} and ^{*}T^{ab}_{ij} amplitudes from canonical to local basis
    ! later on
    call array2_transpose(Cocc)
    call array2_transpose(Cvirt)

    ! ***********************************
    ! done with local --> canonical trans
    ! ***********************************

    ! ********************************
    ! begin actual triples calculation
    ! ********************************

    ! in all comments in the below, we employ the notation of eqs. (14.6.60) [with (i,j,k)/(a,c,d)]
    ! and (14.6.64).

    ! objective is four-fold:
    ! 1) calculate triples amplitudes, collect in array3 structures, trip_*** [canonical basis]
    ! 2) calculate ^{*}T^{a}_{i} and ^{*}T^{ab}_{ij} amplitudes in array2 and array4 structures, 
    !    T_ast_0 and T_ast [canonical basis]
    ! 3) transform T_ast_0 and T_ast into local basis [local basis]
    ! 4) calculate CCSD(T) correction to correlation energy [local basis]

    ! *****************************************************
    ! ***************** trip generation *******************
    ! *****************************************************

    ! init T_ast_0 array2 and T_ast_1 and T_ast_2 array4 structures.
    ! we merge T_ast_1 and T_ast_2 at the end into T_ast. 
    ! we dimension T_ast_1 as dims_aaii and T_ast_2 as dims_iaai in order to load in data consecutive 
    ! in memory inside eccsdpt_contract_21 and eccsdpt_contract_22, respectively.
    T_ast_0 = array2_init_plain(virtoccdims)
    T_ast_1 = array4_init_standard(dims_aaii)
    T_ast_2 = array4_init_standard(dims_iaai)

    ! intial reordering of canTaibj, canAIBJ, canAIBC, and canAIJK array4 structures to enable copying
    ! of data stored consecutive in memory. We explicitly reorder these arrays back to
    ! initial sequence once the below driver loop has terminated.
    call array4_reorder(canTaibj,[1,3,4,2]) ! canTaibj(a,i,b,j) --> canTaibj(a,b,j,i)
    call array4_reorder(canAIBJ,[1,3,2,4]) ! canAIBJ(a,i,b,j) --> canAIBJ(a,b,i,j)
    call array4_reorder(canAIBC,[4,3,1,2]) ! canAIBC(a,i,b,c) --> canAIBC(c,b,a,i)
    call array4_reorder(canAIJK,[3,1,2,4]) ! canAIJK(a,i,j,k) --> canAIJK(j,a,i,k)

 irun: do i=1,nocc
    jrun: do j=1,nocc
          if (.not. i .ge. j) cycle irun
       krun: do k=1,nocc
             if (.not. j .ge. k) cycle jrun

                ! select type of tuple
                tuple_type = -1
                ! i == j == k
                if ((i .eq. j) .and. (j .eq. k)) tuple_type = 0
                ! i == j > k
                if ((i .eq. j) .and. (j .gt. k) .and. (i .gt. k)) tuple_type = 1
                ! i > j == k
                if ((i .gt. j) .and. (j .eq. k) .and. (i .gt. k)) tuple_type = 2
                ! i > j > k
                if ((i .gt. j) .and. (j .gt. k) .and. (i .gt. k)) tuple_type = 3

                ! generate tuple(s)
                TypeOfTuple: select case(tuple_type)

                case(0)

                   ! do only one tuple
                   trip_iii = array3_init_standard(dims_aaa)

                   ! generate tuple
                   call trip_ampl2(i,j,k,nocc,nvirt,canTaibj,canAIBC,canAIJK,ampl_iii=trip_iii)

                   ! generate triples amplitudes from trip arrays
                   call trip_denom2(i,j,k,nocc,nvirt,eivalocc,eivalvirt,ampl_iii=trip_iii)

                   ! calculate contribution to T_ast:
                   ! T_ast(i,i)
                   call eccsdpt_contract_21(i,j,k,nvirt,canAIBC,T_ast_1,ampl_iii=trip_iii)

                   ! note: the i == j == k contributions from eccsdpt_contract_1 and
                   ! eccsdpt_contract_22 are zero, thus, no calls from inside here.

                   ! now release trip_iii array3
                   call array3_free(trip_iii)

                case(1)

                   ! do three tuples (t^{***}_{ijk}, t^{***}_{ikj}, and t^{***}_{kij}) as
                   ! t^{***}_{ijk} = t^{***}_{jik}, t^{***}_{ikj} = t^{***}_{jki}, and
                   ! t^{***}_{kij} = t^{***}_{kji}
                   trip_iik = array3_init_standard(dims_aaa)
                   trip_iki = array3_init_standard(dims_aaa)
                   trip_kii = array3_init_standard(dims_aaa)

                   ! generate tuples
                   call trip_ampl2(i,j,k,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_iik=trip_iik,ampl_iki=trip_iki,ampl_kii=trip_kii)
                   call trip_ampl2(i,k,j,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_iik=trip_iik,ampl_iki=trip_iki,ampl_kii=trip_kii)
                   call trip_ampl2(k,i,j,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_iik=trip_iik,ampl_iki=trip_iki,ampl_kii=trip_kii)

                   ! generate triples amplitudes from trip arrays
                   call trip_denom2(i,j,k,nocc,nvirt,eivalocc,eivalvirt,&
                                & ampl_iik=trip_iik,ampl_iki=trip_iki,ampl_kii=trip_kii)

                   ! calculate contributions to T_ast:
                   ! T_ast(i,i), T_ast(i,k), and T_ast(k,i)
                   call eccsdpt_contract_1(i,j,k,nvirt,canAIBJ,T_ast_0,&
                                          & ampl_iik=trip_iik,ampl_iki=trip_iki,ampl_kii=trip_kii)
                   call eccsdpt_contract_21(i,j,k,nvirt,canAIBC,T_ast_1,&
                                          & ampl_iik=trip_iik,ampl_iki=trip_iki,ampl_kii=trip_kii)
                   call eccsdpt_contract_22(i,j,k,nocc,nvirt,canAIJK,T_ast_2,&
                                          & ampl_iik=trip_iik,ampl_iki=trip_iki,ampl_kii=trip_kii)

                   ! now release trip_iik, trip_iki, and trip_kii array3s
                   call array3_free(trip_iik)
                   call array3_free(trip_iki)
                   call array3_free(trip_kii)

                case(2)

                   ! do three tuples (t^{***}_{ijk}, t^{***}_{jik}, and t^{***}_{jki}) as
                   ! t^{***}_{ijk} = t^{***}_{ikj}, t^{***}_{jik} = t^{***}_{kij}, and
                   ! t^{***}_{jki} = t^{***}_{kji}
                   trip_ijj = array3_init_standard(dims_aaa)
                   trip_jij = array3_init_standard(dims_aaa)
                   trip_jji = array3_init_standard(dims_aaa)

                   ! generate tuples
                   call trip_ampl2(i,j,k,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijj=trip_ijj,ampl_jij=trip_jij,ampl_jji=trip_jji)
                   call trip_ampl2(j,i,k,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijj=trip_ijj,ampl_jij=trip_jij,ampl_jji=trip_jji)
                   call trip_ampl2(j,k,i,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijj=trip_ijj,ampl_jij=trip_jij,ampl_jji=trip_jji)

                   ! generate triples amplitudes from trip arrays
                   call trip_denom2(i,j,k,nocc,nvirt,eivalocc,eivalvirt,&
                                & ampl_ijj=trip_ijj,ampl_jij=trip_jij,ampl_jji=trip_jji)

                   ! calculate contributions to T_ast:
                   ! T_ast(i,j), T_ast(j,i), and T_ast(j,j)
                   call eccsdpt_contract_1(i,j,k,nvirt,canAIBJ,T_ast_0,&
                                          & ampl_ijj=trip_ijj,ampl_jij=trip_jij,ampl_jji=trip_jji)
                   call eccsdpt_contract_21(i,j,k,nvirt,canAIBC,T_ast_1,&
                                          & ampl_ijj=trip_ijj,ampl_jij=trip_jij,ampl_jji=trip_jji)
                   call eccsdpt_contract_22(i,j,k,nocc,nvirt,canAIJK,T_ast_2,&
                                          & ampl_ijj=trip_ijj,ampl_jij=trip_jij,ampl_jji=trip_jji)

                   ! now release trip_iik, trip_iki, and trip_kii array3s
                   call array3_free(trip_ijj)
                   call array3_free(trip_jij)
                   call array3_free(trip_jji)

                case(3)

                   ! do all six tuples: t^{***}_{ijk}, t^{***}_{kij}, t^{***}_{jki}
                   !                    t^{***}_{ikj}, t^{***}_{jik}, and t^{***}_{kji}
                   trip_ijk = array3_init_standard(dims_aaa)
                   trip_kij = array3_init_standard(dims_aaa)
                   trip_jki = array3_init_standard(dims_aaa)
                   trip_ikj = array3_init_standard(dims_aaa)
                   trip_jik = array3_init_standard(dims_aaa)
                   trip_kji = array3_init_standard(dims_aaa)

                   ! generate tuples
                   call trip_ampl2(i,j,k,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)
                   call trip_ampl2(k,i,j,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)
                   call trip_ampl2(j,k,i,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)
                   call trip_ampl2(i,k,j,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)
                   call trip_ampl2(j,i,k,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)
                   call trip_ampl2(k,j,i,nocc,nvirt,canTaibj,canAIBC,canAIJK,&
                                & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)

                   ! generate triples amplitudes from trip arrays
                   call trip_denom2(i,j,k,nocc,nvirt,eivalocc,eivalvirt,&
                                & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)

                   ! calculate contributions to T_ast:
                   ! T_ast(i,j), T_ast(k,i), T_ast(j,k), T_ast(i,k), T_ast(j,i), and T_ast(k,j)
                   call eccsdpt_contract_1(i,j,k,nvirt,canAIBJ,T_ast_0,&
                                          & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                          & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)
                   call eccsdpt_contract_21(i,j,k,nvirt,canAIBC,T_ast_1,&
                                          & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                          & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)
                   call eccsdpt_contract_22(i,j,k,nocc,nvirt,canAIJK,T_ast_2,&
                                          & ampl_ijk=trip_ijk,ampl_kij=trip_kij,ampl_jki=trip_jki,&
                                          & ampl_ikj=trip_ikj,ampl_jik=trip_jik,ampl_kji=trip_kji)

                   ! now release trip_ijk, trip_kji, trip_jki, trip_ikj, trip_jik, and trip_kji array3s
                   call array3_free(trip_ijk)
                   call array3_free(trip_kij)
                   call array3_free(trip_jki)
                   call array3_free(trip_ikj)
                   call array3_free(trip_jik)
                   call array3_free(trip_kji)

                end select TypeOfTuple

             end do krun
          end do jrun
       end do irun

    ! reorder canTaibj, canAIBJ, canAIBC, and canAIJK back to original sequences
    call array4_reorder(canTaibj,[1,4,2,3]) ! canTaibj(a,b,j,i) --> canTaibj(a,i,b,j)
    call array4_reorder(canAIBJ,[1,3,2,4]) ! canAIBJ(a,b,i,j) --> canAIBJ(a,i,b,j)
    call array4_reorder(canAIBC,[3,4,2,1]) ! canAIBC(c,b,a,i) --> canAIBC(a,i,b,c)
    call array4_reorder(canAIJK,[2,3,1,4]) ! canAIBC(j,a,i,k) --> canAIJK(a,i,j,k)

    ! *************************************************
    ! *********** done w/ trip generation *************
    ! *************************************************

    ! reorder T_ast_2(j,a,b,i) --> (a,b,i,j) and collect into common T_ast array4 structure
    call array4_reorder(T_ast_2,[2,3,4,1])
    T_ast = array4_add_memory(1.0E0_realk,T_ast_1,1.0E0_realk,T_ast_2)
    ! release T_ast_1 and T_ast_2
    call array4_free(T_ast_1)
    call array4_free(T_ast_2)

    ! *************************************************
    ! ***** do canonical --> local transformation *****
    ! *************************************************

    ! 1a. init temporary array4, tmp11
    tmp11 = array4_init_standard(dims_aaii)
    ! 1b. init temporary array2, tmp01
    tmp01 = array2_init_plain(virtoccdims)

    ! 2. 1st index:
    ! T_ast(A,B,I,J) --> tmp11(a,B,I,J)
    call array4_contract1(T_ast,Cvirt,tmp11,.true.)
    ! T_ast_0(A,I) --> tmp01(a,I)
    call array2_matmul(Cvirt,T_ast_0,tmp01,'t','n',1.0E0_realk,0.0E0_realk)

    ! free T_ast
    call array4_free(T_ast)

    ! 3. 2nd index:
    ! tmp11(a,B,I,J) --> tmp11(B,a,I,J) --> tmp21(b,a,I,J)
    ! tmp01(a,I) --> T_ast_0(a,i)
    call array4_reorder(tmp11,[2,1,3,4])

    ! init temporary array4, tmp21
    tmp21 = array4_init_standard(dims_aaii)

    ! transformation time - T_ast case
    call array4_contract1(tmp11,Cvirt,tmp21,.true.)
    ! T_ast_0 case
    call array2_matmul(tmp01,Cocc,T_ast_0,'n','n',1.0E0_realk,0.0E0_realk)

    ! free tmp11
    call array4_free(tmp11)
    ! free tmp01
    call array2_free(tmp01)

    ! 4. 3rd index:
    ! tmp21(b,a,I,J) --> tmp21(J,I,a,b) --> tmp11(j,I,a,b)
    call array4_reorder(tmp21,[4,3,2,1])

    ! init temporary array4, tmp11, once again
    tmp11 = array4_init_standard(dims_iiaa)

    ! transformation time
    call array4_contract1(tmp21,Cocc,tmp11,.true.)

    ! free tmp21
    call array4_free(tmp21)

    ! 5. 4th index:
    ! tmp11(j,I,a,b) --> tmp11(I,j,a,b) --> T_ast(i,j,a,b)
    call array4_reorder(tmp11,[2,1,3,4])

    ! init T_ast array4 once again
    T_ast = array4_init_standard(dims_iiaa)

    ! transformation time
    call array4_contract1(tmp11,Cocc,T_ast,.true.)

    ! free tmp11
    call array4_free(tmp11)

    ! release Cocc and Cvirt
    call array2_free(Cocc)
    call array2_free(Cvirt)

    ! ****************************************************
    ! *** done with canonical --> local transformation ***
    ! ****************************************************

    ! reorder T_ast back to T_ast(a,b,i,j)
    call array4_reorder(T_ast,[3,4,1,2])

    ! ****************************************************
    ! ********************* Energy ***********************
    ! ****************************************************

    ! **********************
    ! do singles energy part
    ! **********************

    ! init temporary pointers and final energy array
    energy_matrix_ccsdpt_1 = array2_init_plain(numdims)

  ido_0: do i=1,nocc
         AtomI = OccOrbitals(i)%CentralAtom
     ado_0: do a=1,nvirt
            AtomA = UnoccOrbitals(a)%CentralAtom 

               energy_matrix_ccsdpt_1%val(AtomI,AtomA) = energy_matrix_ccsdpt_1%val(AtomI,AtomA) &
                                                     & + 2.0E0_realk * Tai%val(a,i) * T_ast_0%val(a,i)

            end do ado_0
         end do ido_0

    ! release T_ast_0 array2 structure
    call array2_free(T_ast_0)

    ! **********************
    ! do doubles energy part
    ! **********************

    ! init temporary and final arrays
    energy_matrix_ccsdpt_2 = array2_init_plain(numdims)
    energy_interm_cou = array2_init_plain(virtdims)
    energy_interm_exc = array2_init_plain(virtdims)
    energy_interm_T_ast = array2_init_plain(virtdims)

    ! produce coulumb and exchange versions of Taibj
    ! Taibj(a,i,b,j) --> doub_interm(a,b,i,j)
    call array4_reorder(Taibj,[1,3,2,4])
    doub_interm = array4_duplicate(Taibj)
    ! reorder Taibj back to original Taibj(a,i,b,j) sequence
    call array4_reorder(Taibj,[1,3,2,4])

  ido_1: do i=1,nocc
         AtomI = OccOrbitals(i)%CentralAtom
     jdo_1: do j=1,nocc
            AtomJ = OccOrbitals(j)%CentralAtom

               call dcopy(nvirt**2,doub_interm%val(:,:,i,j),1,energy_interm_cou%val,1)
               call dcopy(nvirt**2,doub_interm%val(:,:,j,i),1,energy_interm_exc%val,1)
               call dcopy(nvirt**2,T_ast%val(:,:,i,j),1,energy_interm_T_ast%val,1)
  
               energy_res_cou = array2_dotproduct(energy_interm_T_ast,energy_interm_cou)
               energy_res_exc = array2_dotproduct(energy_interm_T_ast,energy_interm_exc)
  
               energy_matrix_ccsdpt_2%val(AtomI,AtomJ) = energy_matrix_ccsdpt_2%val(AtomI,AtomJ) &
                                         & + 4.0E0_realk * energy_res_cou - 2.0E0_realk * energy_res_exc

          end do jdo_1
       end do ido_1

    ! release T_ast
    call array4_free(T_ast)

    !release temporary arrays
    call array4_free(doub_interm)
    call array2_free(energy_interm_cou)
    call array2_free(energy_interm_exc)
    call array2_free(energy_interm_T_ast)

    ! ***********************************************
    ! ************** done w/ energy *****************
    ! ***********************************************

    ! ***********************************************
    ! *************** print section *****************
    ! ***********************************************

    ! singles energy part

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,'(1X,a)') '*       Full DEC CCSD(T) [NEW] calculation is done (occ. part. scheme)!     *'
    write(DECinfo%output,'(1X,a)') '*****************************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '***************************************************************'
    write(DECinfo%output,'(1X,a)') '*                      Singles E[5] part                      *'
    write(DECinfo%output,'(1X,a)') '***************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(9X,a)') '-- Pair fragments [singles part]'
    write(DECinfo%output,'(9X,a)') '------    -------    ----------    --------------------'
    write(DECinfo%output,'(9X,a)') 'P(occ)    Q(virt)      R(Ang)           deltaE(PQ)     '
    write(DECinfo%output,'(9X,a)') '------    -------    ----------    --------------------'
    write(DECinfo%output,*)

    ! the total singles energy must result from an unrestricted summation over all occ and virt indices
    ! as we are only interested in general orbital interactions and hence not the nature (occ/virt)
    ! of the individual orbitals

    ECCSDpt_1 = 0.0E0_realk
    do i=1,numatoms
       do a=1,numatoms
          ! write increments only if pair interaction energy is nonzero
          if( orbitals_assigned(i) .and. orbitals_assigned(a) ) then
             if (i .eq. a) then
                write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#PAIR#',i,a,&
                     &0.000, energy_matrix_ccsdpt_1%val(i,a)
                ECCSDpt_1 = ECCSDpt_1 + energy_matrix_ccsdpt_1%val(i,a)
             else
                write(DECinfo%output,'(1X,a,i7,4X,i6,4X,g10.4,4X,g20.10)') '#PAIR#',i,a,&
                     &bohr_to_angstrom*DistanceTable(i,j), energy_matrix_ccsdpt_1%val(i,a)
                ECCSDpt_1 = ECCSDpt_1 + energy_matrix_ccsdpt_1%val(i,a)
             end if
          end if
       end do
    end do

    call array2_free(energy_matrix_ccsdpt_1)

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'E5 singles and triples contr. [NEW]      = ', ECCSDpt_1
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a)')

    ! sum up energy contributions

    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '***************************************************************'
    write(DECinfo%output,'(1X,a)') '*                      Doubles E[4] part                      *'
    write(DECinfo%output,'(1X,a)') '***************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Atomic fragments [doubles part]'
    write(DECinfo%output,'(8X,a)') '------    --------------------'
    write(DECinfo%output,'(8X,a)') ' Atom            Energy '
    write(DECinfo%output,'(8X,a)') '------    --------------------'
    write(DECinfo%output,*)

    ECCSDpt_2_single = 0.0E0_realk
    do i=1,numatoms
       if(orbitals_assigned(i)) then
          write(DECinfo%output,'(1X,a,i6,4X,g20.10)') '#SING#', i, energy_matrix_ccsdpt_2%val(i,i)
          ECCSDpt_2_single = ECCSDpt_2_single + energy_matrix_ccsdpt_2%val(i,i)
       end if
    end do

    ! Total pair fragment energy matrix
    ! Only consider pairs IJ where J>I; thus, move contributions

    do AtomI=1,numatoms
       do AtomJ=AtomI+1,numatoms
          energy_matrix_ccsdpt_2%val(AtomI,AtomJ) = energy_matrix_ccsdpt_2%val(AtomI,AtomJ) &
                                              & + energy_matrix_ccsdpt_2%val(AtomJ,AtomI)
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(8X,a)') '-- Pair fragments [doubles part]'
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'
    write(DECinfo%output,'(8X,a)') '   P         Q        R(Ang)           deltaE(PQ) '
    write(DECinfo%output,'(8X,a)') '------    ------    ----------    --------------------'
    write(DECinfo%output,*)

    ECCSDpt_2_pair = 0.0E0_realk
    do i=1,numatoms
       do j=i+1,numatoms
          ! write increments only if pair interaction energy is nonzero
          if( orbitals_assigned(i) .and. orbitals_assigned(j) ) then
             write(DECinfo%output,'(1X,a,i6,4X,i6,4X,g10.4,4X,g20.10)') '#PAIR#',i,j,&
                  &bohr_to_angstrom*DistanceTable(i,j), energy_matrix_ccsdpt_2%val(i,j)
             ECCSDpt_2_pair = ECCSDpt_2_pair + energy_matrix_ccsdpt_2%val(i,j)
          end if
       end do
    end do

    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'Total atomic frag. energy [doub. part]   = ', ECCSDpt_2_single
    write(DECinfo%output,'(1X,a,g20.10)') 'Pair atomic frag. energy [doub. part]    = ', ECCSDpt_2_pair
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,'(1X,a,g20.10)') 'E4 doubles and triples contr. [NEW]      = ', &
                                                         & ECCSDpt_2_single + ECCSDpt_2_pair
    write(DECinfo%output,'(1X,a)')   '------------------------------------------------------'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a)') '******************************************************************'
    write(DECinfo%output,'(1X,a)') '*                      Final CCSD(T) results                     *'
    write(DECinfo%output,'(1X,a)') '******************************************************************'
    write(DECinfo%output,*)
    write(DECinfo%output,*)
    write(DECinfo%output,'(1X,a,g20.10)') 'The E5 singles and triples contr. [NEW]  = ', ECCSDpt_1
    write(DECinfo%output,'(1X,a,g20.10)') 'The E4 doubles and triples contr. [NEW]  = ', &
                                                         & ECCSDpt_2_single + ECCSDpt_2_pair
    write(DECinfo%output,'(1X,a,g20.10)') 'Total CCSD(T) correlation energy  [NEW]  = ', &
                                                         & ECCSDpt_1 + ECCSDpt_2_single + ECCSDpt_2_pair
    write(DECinfo%output,'(1X,a)')

    ! release energy array2 structure
    call array2_free(energy_matrix_ccsdpt_2)

    ! clean up
    call mem_dealloc(eivalocc)
    call mem_dealloc(eivalvirt)
    call mem_dealloc(DistanceTable)
    do i=1,nocc
       call orbital_free(OccOrbitals(i))
    end do
    call mem_dealloc(OccOrbitals)
    do i=1,nvirt
       call orbital_free(UnoccOrbitals(i))
    end do
    call mem_dealloc(UnoccOrbitals)
    call mem_dealloc(orbitals_assigned)
    call array4_free(Taibj)
    call array4_free(canTaibj)
    call array4_free(canAIBJ)
    call array4_free(canAIBC)
    call array4_free(canAIJK)
    call array2_free(Tai)

  end subroutine full_ccsd_parenthesisT_new


  !> \brief: Create triples amplitudes ([a,b,c] tuple) for fixed [i,j,k] tuple, that is, t^{***}_{ijk}
  ! saved as an array3 structure (amplitudes)
  !> \author: Janus Juul Eriksen
  !> \date: July 2012
  !> \param: oindex1, oindex2, and oindex3 are the three occupied indices of the outer loop in the CCSD(T) driver
  !> \param: no and nv are nocc and nvirt, respectively
  !> \param: doub_ampl are CCSD ampltidues, t^{ab}_{ij}
  !> \param: int_virt and int_occ are canAIBC and canAIJK, respectively
  !> \param: amplitudes is the final triples amplitude tuple [a,b,c], that is, of the size (virt) kept in memory
  subroutine trip_ampl2(oindex1,oindex2,oindex3,no,nv,doub_ampl,int_virt,int_occ,&
                     & ampl_iii,ampl_iik,ampl_iki,ampl_kii,ampl_ijj,ampl_jij,ampl_jji,&
                     & ampl_ijk,ampl_kij,ampl_jki,ampl_ikj,ampl_jik,ampl_kji)


    implicit none
    !> input
    integer, intent(in) :: oindex1, oindex2, oindex3, no, nv
    type(array4), intent(in) :: doub_ampl, int_virt, int_occ
    type(array3), optional, intent(inout) :: ampl_iii, ampl_iik, ampl_iki, ampl_kii, ampl_ijj, ampl_jij, ampl_jji
    type(array3), optional, intent(inout) :: ampl_ijk, ampl_kij, ampl_jki, ampl_ikj, ampl_jik, ampl_kji
    !> temporary quantities
    integer :: collection_type
    type(array2) :: tmp_T_1, tmp_g_2
    type(array3) :: tmp_g_1, tmp_T_2, interm_1, interm_2, interm_3

    ! important: notation adapted from eq. (14.6.60) of MEST. herein, 'e' and 'm' are the running indices of the
    ! equation in the book (therein: 'd' and 'l', respectively)

    ! NOTE: incoming array4 structures are ordered according to:
    ! canTaibj(a,b,j,i)
    ! canAIBC(c,b,a,i)
    ! canAIJK(j,a,i,k)

    ! init temporary arrays
    tmp_T_1 = array2_init_plain([nv,nv])
    tmp_T_2 = array3_init_standard([nv,nv,no])
    tmp_g_1 = array3_init_standard([nv,nv,nv])
    tmp_g_2 = array2_init_plain([no,nv])

    ! **************************************************
    ! ******* create temporary amplitude arrays ********
    ! **************************************************

    ! canTaibj(a,e,j,i) --> tmp_T_1(a,e)
    call dcopy(nv**2,doub_ampl%val(:,:,oindex2,oindex1),1,tmp_T_1%val,1)
    ! transpose to get (e,a)
    call array2_transpose(tmp_T_1)

    ! canTaibj(a,b,m,i) --> tmp_T_2(a,b,m)
    call dcopy(no*nv**2,doub_ampl%val(:,:,:,oindex1),1,tmp_T_2%val,1)
    ! reorder to obtain tmp_T_2(m,a,b)
    call array3_reorder(tmp_T_2,[3,1,2])

    ! **************************************************
    ! ***** create temporary 2-el integral arrays ******
    ! **************************************************

    ! canAIBC(e,b,c,k) --> tmp_g_1(e,b,c)
    call dcopy(nv**3,int_virt%val(:,:,:,oindex3),1,tmp_g_1%val,1)

    ! canAIJK(m,c,k,j) --> tmp_g_2(m,c)
    call dcopy(no*nv,int_occ%val(:,:,oindex3,oindex2),1,tmp_g_2%val,1)

    ! ***************************************************
    ! ** contraction time (over the virtual index 'e') **
    ! ***************************************************

    ! interm_1(a,b,c) = tmp_T_1(e,a) * tmp_g_1(e,b,c)
    interm_1 = array3_init_standard([nv,nv,nv])
    call array3_contract1(tmp_g_1,tmp_T_1,interm_1,.true.,.true.)

    ! release temporary arrays
    call array2_free(tmp_T_1)
    call array3_free(tmp_g_1)

    ! ****************************************************
    ! ** contraction time (over the occupied index 'm') **
    ! ****************************************************

    ! interm_2(a,b,c) = tmp_g_2(m,c) * tmp_T_2(m,a,b) = interm_2(c,a,b) --> interm_2(a,b,c)
    interm_2 = array3_init_standard([nv,nv,nv])
    call array3_contract1(tmp_T_2,tmp_g_2,interm_2,.true.,.true.)
    ! reorder from (c,a,b) to (a,b,c)
    call array3_reorder(interm_2,[2,3,1])

    ! release temporary arrays
    call array2_free(tmp_g_2)
    call array3_free(tmp_T_2)

    ! ******************************************************************
    ! *** collect interm_1 and interm_2 in interm_3 array3 structure ***
    ! ******************************************************************

    ! interm_3(a,b,c) = interm_1(a,b,c) - interm_2(a,b,c)
    interm_3 = array3_init_standard([nv,nv,nv])
    call array3_add_memory(1.0E0_realk,interm_1,-1.0E0_realk,interm_2,interm_3,.true.)

    ! release interm_1 and interm_2 array3 structures
    call array3_free(interm_1)
    call array3_free(interm_2)

    ! **************************************************
    ! ******** do permutation of tuple (a,b,c) *********
    ! **************************************************

    ! select type of tuple
    collection_type = -1
    ! diagonal case: in the outer loop in the driver routine, i == j == k
    ! ijk: i == j == k
    if ((oindex1 .eq. oindex2) .and. (oindex2 .eq. oindex3) .and. (oindex1 .eq. oindex3)) then
       if (.not. present(ampl_iii)) then
          call lsquit('triplet amplitude array for (iii) combination not present',-1)
       end if
       collection_type = 0
    end if

    ! special case # 1: in the outer loop in the driver routine, i == j > k
    ! ijk: i == j > k
    if ((oindex1 .eq. oindex2) .and. (oindex2 .gt. oindex3) .and. (oindex1 .gt. oindex3)) then
       if (.not. present(ampl_iik)) then
          call lsquit('triplet amplitude array for (iik) combination not present',-1)
       else if (.not. present(ampl_iki)) then
          call lsquit('triplet amplitude array for (iki) combination not present',-1)
       else if (.not. present(ampl_kii)) then
          call lsquit('triplet amplitude array for (kii) combination not present',-1)
       end if
       collection_type = 1
    end if

    ! ikj: i > k < j .and. i == j
    if ((oindex1 .gt. oindex2) .and. (oindex2 .lt. oindex3) .and. (oindex1 .eq. oindex3)) then
       if (.not. present(ampl_iik)) then
          call lsquit('triplet amplitude array for (iik) combination not present',-1)
       else if (.not. present(ampl_iki)) then
          call lsquit('triplet amplitude array for (iki) combination not present',-1)
       else if (.not. present(ampl_kii)) then
          call lsquit('triplet amplitude array for (kii) combination not present',-1)
       end if
       collection_type = 2
    end if

    ! kij: k < i == j
    if ((oindex1 .lt. oindex2) .and. (oindex2 .eq. oindex3) .and. (oindex1 .lt. oindex3)) then
       if (.not. present(ampl_iik)) then
          call lsquit('triplet amplitude array for (iik) combination not present',-1)
       else if (.not. present(ampl_iki)) then
          call lsquit('triplet amplitude array for (iki) combination not present',-1)
       else if (.not. present(ampl_kii)) then
          call lsquit('triplet amplitude array for (kii) combination not present',-1)
       end if
       collection_type = 3
    end if

    !special case # 2: in the outer loop in the driver routine, i > j == k
    ! ijk: i > j == k .and. i > k
    if ((oindex1 .gt. oindex2) .and. (oindex2 .eq. oindex3) .and. (oindex1 .gt. oindex3)) then
       if (.not. present(ampl_ijj)) then
          call lsquit('triplet amplitude array for (ijj) combination not present',-1)
       else if (.not. present(ampl_jij)) then
          call lsquit('triplet amplitude array for (jij) combination not present',-1)
       else if (.not. present(ampl_jji)) then
          call lsquit('triplet amplitude array for (jji) combination not present',-1)
       end if
       collection_type = 4
    end if

    ! jik: j < i > k .and. j == k
    if ((oindex1 .lt. oindex2) .and. (oindex2 .gt. oindex3) .and. (oindex1 .eq. oindex3)) then
       if (.not. present(ampl_ijj)) then
          call lsquit('triplet amplitude array for (ijj) combination not present',-1)
       else if (.not. present(ampl_jij)) then
          call lsquit('triplet amplitude array for (jij) combination not present',-1)
       else if (.not. present(ampl_jji)) then
          call lsquit('triplet amplitude array for (jji) combination not present',-1)
       end if
       collection_type = 5
    end if

    ! jki: j == k < i .and. j < i
    if ((oindex1 .eq. oindex2) .and. (oindex2 .lt. oindex3) .and. (oindex1 .lt. oindex3)) then
       if (.not. present(ampl_ijj)) then
          call lsquit('triplet amplitude array for (ijj) combination not present',-1)
       else if (.not. present(ampl_jij)) then
          call lsquit('triplet amplitude array for (jij) combination not present',-1)
       else if (.not. present(ampl_jji)) then
          call lsquit('triplet amplitude array for (jji) combination not present',-1)
       end if
       collection_type = 6
    end if

    ! default case: in the outer loop in the driver routine, i > j > k
    ! ijk: i > j > k
    if ((oindex1 .gt. oindex2) .and. (oindex2 .gt. oindex3) .and. (oindex1 .gt. oindex3)) then
       if (.not. present(ampl_ijk)) then
          call lsquit('triplet amplitude array for (ijk) combination not present',-1)
       else if (.not. present(ampl_kij)) then
          call lsquit('triplet amplitude array for (kij) combination not present',-1)
       else if (.not. present(ampl_jki)) then
          call lsquit('triplet amplitude array for (jki) combination not present',-1)
       else if (.not. present(ampl_ikj)) then
          call lsquit('triplet amplitude array for (ikj) combination not present',-1)
       else if (.not. present(ampl_jik)) then
          call lsquit('triplet amplitude array for (jik) combination not present',-1)
       else if (.not. present(ampl_kji)) then
          call lsquit('triplet amplitude array for (kji) combination not present',-1)
       end if
       collection_type = 7
    end if

    ! kij: k < i > j .and. k < j
    if ((oindex1 .lt. oindex2) .and. (oindex2 .gt. oindex3) .and. (oindex1 .lt. oindex3)) then
       if (.not. present(ampl_ijk)) then
          call lsquit('triplet amplitude array for (ijk) combination not present',-1)
       else if (.not. present(ampl_kij)) then
          call lsquit('triplet amplitude array for (kij) combination not present',-1)
       else if (.not. present(ampl_jki)) then
          call lsquit('triplet amplitude array for (jki) combination not present',-1)
       else if (.not. present(ampl_ikj)) then
          call lsquit('triplet amplitude array for (ikj) combination not present',-1)
       else if (.not. present(ampl_jik)) then
          call lsquit('triplet amplitude array for (jik) combination not present',-1)
       else if (.not. present(ampl_kji)) then
          call lsquit('triplet amplitude array for (kji) combination not present',-1)
       end if
       collection_type = 8
    end if

    ! jki: j > k < i .and. j < i
    if ((oindex1 .gt. oindex2) .and. (oindex2 .lt. oindex3) .and. (oindex1 .lt. oindex3)) then
       if (.not. present(ampl_ijk)) then
          call lsquit('triplet amplitude array for (ijk) combination not present',-1)
       else if (.not. present(ampl_kij)) then
          call lsquit('triplet amplitude array for (kij) combination not present',-1)
       else if (.not. present(ampl_jki)) then
          call lsquit('triplet amplitude array for (jki) combination not present',-1)
       else if (.not. present(ampl_ikj)) then
          call lsquit('triplet amplitude array for (ikj) combination not present',-1)
       else if (.not. present(ampl_jik)) then
          call lsquit('triplet amplitude array for (jik) combination not present',-1)
       else if (.not. present(ampl_kji)) then
          call lsquit('triplet amplitude array for (kji) combination not present',-1)
       end if
       collection_type = 9
    end if

    ! ikj: i > k < j .and. i > j
    if ((oindex1 .gt. oindex2) .and. (oindex2 .lt. oindex3) .and. (oindex1 .gt. oindex3)) then
       if (.not. present(ampl_ijk)) then
          call lsquit('triplet amplitude array for (ijk) combination not present',-1)
       else if (.not. present(ampl_kij)) then
          call lsquit('triplet amplitude array for (kij) combination not present',-1)
       else if (.not. present(ampl_jki)) then
          call lsquit('triplet amplitude array for (jki) combination not present',-1)
       else if (.not. present(ampl_ikj)) then
          call lsquit('triplet amplitude array for (ikj) combination not present',-1)
       else if (.not. present(ampl_jik)) then
          call lsquit('triplet amplitude array for (jik) combination not present',-1)
       else if (.not. present(ampl_kji)) then
          call lsquit('triplet amplitude array for (kji) combination not present',-1)
       end if
       collection_type = 10
    end if

    ! jik: j < i > k .and. j > k
    if ((oindex1 .lt. oindex2) .and. (oindex2 .gt. oindex3) .and. (oindex1 .gt. oindex3)) then
       if (.not. present(ampl_ijk)) then
          call lsquit('triplet amplitude array for (ijk) combination not present',-1)
       else if (.not. present(ampl_kij)) then
          call lsquit('triplet amplitude array for (kij) combination not present',-1)
       else if (.not. present(ampl_jki)) then
          call lsquit('triplet amplitude array for (jki) combination not present',-1)
       else if (.not. present(ampl_ikj)) then
          call lsquit('triplet amplitude array for (ikj) combination not present',-1)
       else if (.not. present(ampl_jik)) then
          call lsquit('triplet amplitude array for (jik) combination not present',-1)
       else if (.not. present(ampl_kji)) then
          call lsquit('triplet amplitude array for (kji) combination not present',-1)
       end if
       collection_type = 11
    end if

    ! kji: k < j < i
    if ((oindex1 .lt. oindex2) .and. (oindex2 .lt. oindex3) .and. (oindex1 .lt. oindex3)) then
       if (.not. present(ampl_ijk)) then
          call lsquit('triplet amplitude array for (ijk) combination not present',-1)
       else if (.not. present(ampl_kij)) then
          call lsquit('triplet amplitude array for (kij) combination not present',-1)
       else if (.not. present(ampl_jki)) then
          call lsquit('triplet amplitude array for (jki) combination not present',-1)
       else if (.not. present(ampl_ikj)) then
          call lsquit('triplet amplitude array for (ikj) combination not present',-1)
       else if (.not. present(ampl_jik)) then
          call lsquit('triplet amplitude array for (jik) combination not present',-1)
       else if (.not. present(ampl_kji)) then
          call lsquit('triplet amplitude array for (kji) combination not present',-1)
       end if
       collection_type = 12
    end if

    ! generate tuple(s)
    TypeOfCollection: select case(collection_type)

    ! the difference between interm_1 and interm_2 is stored in interm_3 array3 structure.
    ! in the below, we add the difference in the interm_3 tuple in different permutations to the trip_ampl2
    ! array3 structures. the different permutations are (determining order!):
    ! 1. (abc), 2. (cab), 3. (bca), 4. (acb), 5. (bac), and 6. (cba).
    ! these differences are then reordered back into common (abc) sequence in trip_ampl2 arrays.
    ! since the reordering act NOT on the initial (abc) sequence but on the preceding, we do NOT have
    ! reordering as:
    ! [2,3,1] (cba --> abc), [3,1,2] (bca --> abc), [1,3,2] (acb --> abc),
    ! [2,1,3] (bac --> abc), [3,2,1] (cba --> abc)
    ! but rather as the following
    ! [2,3,1], [2,3,1], [2,1,3], [3,1,2], and [3,1,2] (see ascii art below).
    ! this way we may work with only one array3 structures (with v^3 allocation) instead of two or more.
    !
    ! number in brackets designate reorderings, numbers above the brackets designate number of permutation.
    ! note that the first permutation is common for both reordering schemes.
    !
    ! (abc)            (abc)                   (abc)                  (abc)                  (abc)
    !   |             /     |                 /     |                /     |                /     |
    !   |            /       |               /       |              /       |              /       |
    !   |   1       /  1      |    2        /  2      |    3       /  3      |    4       /  4      |    5
    !   |[2,3,1]   /[2,3,1]    |[3,1,2]    /[3,1,2]    |[1,3,2]   /[1,3,2]    |[2,1,3]   /[2,1,3]    |[3,2,1]
    !   |         /      2      |         /       3     |        /      4      |        /      5      |
    !   |        /    [2,3,1]    |       /     [2,1,3]   |      /    [3,1,2]    |      /    [3,1,2]    |
    ! (bca)   (bca) ----------- (cab)  (cab) ---------- (acb) (acb) ---------- (bac) (bac) ---------- (cba)

    case(0)

       ! do all six permutations of tuple (ijk) where i == j == k
       ! duplicate interm_3
       call array3_add_to_memory(ampl_iii,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b)
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_iii,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a)
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_iii,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b)
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_iii,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c)
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_iii,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a)
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_iii,1.0E0_realk,interm_3)

    case(1)

       ! do all six permutations of tuple (ijk) where i == j > k
       ! duplicate interm_3 - element of iik
       call array3_add_to_memory(ampl_iik,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of iki
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_iki,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of kii
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_kii,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of iki
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_iki,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of iik
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_iik,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of kii
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_kii,1.0E0_realk,interm_3)

    case(2)

       ! do all six permutations of tuple (ikj) where ikj: i > k < j .and. i == j
       ! duplicate interm_3 - element of iki
       call array3_add_to_memory(ampl_iki,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of kii
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_kii,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of iik
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_iik,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of iik
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_iik,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of kii
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_kii,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of iki
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_iki,1.0E0_realk,interm_3)

    case(3)

       ! do all six permutations of tuple (kij) where kij: k < i == j
       ! duplicate interm_3 - element of kii
       call array3_add_to_memory(ampl_kii,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of iik
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_iik,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of iki
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_iki,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of kii
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_kii,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of iki
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_iki,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of iik
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_iik,1.0E0_realk,interm_3)

    case(4)

       ! do all six permutations of tuple (ijk) where i > j == k .and. i > k
       ! duplicate interm_3 - first element of ijj
       call array3_add_to_memory(ampl_ijj,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of jji
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jji,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of jij
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jij,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of ijj
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_ijj,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of jij
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jij,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of jji
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jji,1.0E0_realk,interm_3)

    case(5)

       ! do all six permutations of tuple (jik) where j < i > k .and. j == k
       ! duplicate interm_3 - first element of jij
       call array3_add_to_memory(ampl_jij,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of ijj
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_ijj,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of jji
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jji,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of jji
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_jji,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of ijj
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_ijj,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of jij
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jij,1.0E0_realk,interm_3)

    case(6)

       ! do all six permutations of tuple (jki) where j == k < i .and. j < i
       ! duplicate interm_3 - element of jji
       call array3_add_to_memory(ampl_jji,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of jij
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jij,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of ijj
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_ijj,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of jij
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_jij,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of jji
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jji,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of ijj
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_ijj,1.0E0_realk,interm_3)

    case(7)

       ! do all six permutations of tuple (ijk) where i > j > k
       ! duplicate interm_3 - element of ijk
       call array3_add_to_memory(ampl_ijk,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of jki
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jki,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of kij
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_kij,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of ikj
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_ikj,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of jik
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jik,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of kji
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_kji,1.0E0_realk,interm_3)

    case(8)

       ! do all six permutations of tuple (kij) where k < i > j .and. k < j
       ! duplicate interm_3 - element of kij
       call array3_add_to_memory(ampl_kij,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of ijk
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_ijk,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of jki
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jki,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of kji
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_kji,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of ikj
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_ikj,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of jik
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jik,1.0E0_realk,interm_3)

    case(9)

       ! do all six permutations of tuple (jki) where j > k < i .and. j < i
       ! duplicate interm_3 - element of jki
       call array3_add_to_memory(ampl_jki,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of kij
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_kij,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of ijk
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_ijk,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of jik
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_jik,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of kji
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_kji,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of ikj
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_ikj,1.0E0_realk,interm_3)

    case(10)

       ! do all six permutations of tuple (ikj) where i > k < j .and. i > j
       ! duplicate interm_3 - element of ikj
       call array3_add_to_memory(ampl_ikj,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of kji
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_kji,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of jik
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jik,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of ijk
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_ijk,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of kij
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_kij,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of jki
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jki,1.0E0_realk,interm_3)

    case(11)

       ! do all six permutations of tuple (jik) where j < i > k .and. j > k
       ! duplicate interm_3 - element of jik
       call array3_add_to_memory(ampl_jik,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of ikj
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_ikj,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of kji
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_kji,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of jki
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_jki,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of ijk
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_ijk,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of kij
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_kij,1.0E0_realk,interm_3)

    case(12)

       ! do all six permutations of tuple (kji) where k < j < i
       ! duplicate interm_3 - element of kji
       call array3_add_to_memory(ampl_kji,1.0E0_realk,interm_3)
       ! interm_3(a,b,c) --> interm_3(c,a,b) - element of jik
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_jik,1.0E0_realk,interm_3)
       ! interm_3(c,a,b) --> interm_3(b,c,a) - element of ikj
       call array3_reorder(interm_3,[2,3,1])
       call array3_add_to_memory(ampl_ikj,1.0E0_realk,interm_3)
       ! interm_3(b,c,a) --> interm_3(a,c,b) - element of kij
       call array3_reorder(interm_3,[2,1,3])
       call array3_add_to_memory(ampl_kij,1.0E0_realk,interm_3)
       ! interm_3(a,c,b) --> interm_3(b,a,c) - element of jki
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_jki,1.0E0_realk,interm_3)
       ! interm_3(b,a,c) --> interm_3(c,b,a) - element of ijk
       call array3_reorder(interm_3,[3,1,2])
       call array3_add_to_memory(ampl_ijk,1.0E0_realk,interm_3)

    end select TypeOfCollection

    ! finally, release interm_3 array3
    call array3_free(interm_3)

  end subroutine trip_ampl2

  !> \brief: Multiply the [a,b,c] triples ampl. by the orbital energy diff. We make usage of the fact
  ! that the factor associated with orbital a,b,c is to multiplied onto trip elements:
  ! (a,b,c); (c,a,b); (b,c,a); (a,c,b); (b,a,c); (c,b,a)
  !> \author: Janus Juul Eriksen
  !> \date: July 2012
  !> \param: oindex1, oindex2, and oindex3 are the three occupied indices of the outer loop in the CCSD(T) driver
  !> \param: no and nv are nocc and nvirt, respectively
  !> \param: eigen_occ and eigen_virt are vectors containing occupied and virtual orbital energies, respectively
  !> \param: amplitudes is the final triples amplitude tuple [a,b,c], that is, of the size (virt) kept in memory
  subroutine trip_denom2(oindex1,oindex2,oindex3,no,nv,eigenocc,eigenvirt,ampl_iii,ampl_iik,ampl_iki,&
                      & ampl_kii,ampl_ijj,ampl_jij,ampl_jji,ampl_ijk,ampl_kij,ampl_jki,ampl_ikj,ampl_jik,ampl_kji)

    implicit none
    !> input
    integer, intent(in) :: oindex1, oindex2, oindex3, no, nv
    real(realk) :: eigenocc(no), eigenvirt(nv)
    type(array3), optional, intent(inout) :: ampl_iii, ampl_iik, ampl_iki, ampl_kii, ampl_ijj, ampl_jij, ampl_jji
    type(array3), optional, intent(inout) :: ampl_ijk, ampl_kij, ampl_jki, ampl_ikj, ampl_jik, ampl_kji
    !> temporary quantities
    integer :: trip_type, a, b, c
    real(realk) :: e_orb

    ! determine which type of contraction is to be performed
    trip_type = -1
    ! i == j == k
    if (present(ampl_iii)) trip_type = 0
    ! i == j > k
    if (present(ampl_iik) .and. present(ampl_iki) .and. present(ampl_kii)) trip_type = 1
    ! i > j == k
    if (present(ampl_ijj) .and. present(ampl_jij) .and. present(ampl_jji)) trip_type = 2
    ! i > j > k
    if (present(ampl_ijk) .and. present(ampl_kij) .and. present(ampl_jki) &
       & .and. present(ampl_ikj) .and. present(ampl_jik) .and. present(ampl_kji)) trip_type = 3

    ! when mulitplying the orbital energy denominator, we make usage of the fact the the denominator
    ! that is to be mulitplied element (abc) is also the same as those which are to be mulitplied
    ! the elements (cab), (bca), (acb), (bac), and (cba) IF we do (a .ge. b .ge. c).

    TypeofDenominator: select case(trip_type)

    case(0)

       e_orb = 0.0E0_realk
       arun_0: do a=1,nv
          brun_0: do b=1,nv
                  if (.not. a .ge. b) cycle arun_0
             crun_0: do c=1,nv
                     if (.not. b .ge. c) cycle brun_0

                        e_orb = -1.0E0_realk / (eigenvirt(a) + eigenvirt(b) + eigenvirt(c) &
                                           & - eigenocc(oindex1) - eigenocc(oindex2) - eigenocc(oindex3))

                        if ((a .eq. b) .and. (b .eq. c)) then
                           ampl_iii%val(a,a,a) = ampl_iii%val(a,a,a) * e_orb
                        else if ((a .eq. b) .and. (a .gt. c)) then
                           ampl_iii%val(a,a,c) = ampl_iii%val(a,a,c) * e_orb
                           ampl_iii%val(a,c,a) = ampl_iii%val(a,c,a) * e_orb
                           ampl_iii%val(c,a,a) = ampl_iii%val(c,a,a) * e_orb
                        else if ((a .gt. b) .and. (b .eq. c)) then
                           ampl_iii%val(a,b,b) = ampl_iii%val(a,b,b) * e_orb
                           ampl_iii%val(b,a,b) = ampl_iii%val(b,a,b) * e_orb
                           ampl_iii%val(b,b,a) = ampl_iii%val(b,b,a) * e_orb
                        else if ((a .gt. b) .and. (b .gt. c)) then
                           ampl_iii%val(a,b,c) = ampl_iii%val(a,b,c) * e_orb
                           ampl_iii%val(c,a,b) = ampl_iii%val(c,a,b) * e_orb
                           ampl_iii%val(b,c,a) = ampl_iii%val(b,c,a) * e_orb
                           ampl_iii%val(a,c,b) = ampl_iii%val(a,c,b) * e_orb
                           ampl_iii%val(b,a,c) = ampl_iii%val(b,a,c) * e_orb
                           ampl_iii%val(c,b,a) = ampl_iii%val(c,b,a) * e_orb
                        end if

             end do crun_0
          end do brun_0
       end do arun_0

    case(1)

       e_orb = 0.0E0_realk
       arun_1: do a=1,nv
          brun_1: do b=1,nv
                  if (.not. a .ge. b) cycle arun_1
             crun_1: do c=1,nv
                     if (.not. b .ge. c) cycle brun_1
                        
                        e_orb = -1.0E0_realk / (eigenvirt(a) + eigenvirt(b) + eigenvirt(c) &
                                           & - eigenocc(oindex1) - eigenocc(oindex2) - eigenocc(oindex3))

                        if ((a .eq. b) .and. (b .eq. c)) then
                           ampl_iik%val(a,a,a) = ampl_iik%val(a,a,a) * e_orb
                           ampl_iki%val(a,a,a) = ampl_iki%val(a,a,a) * e_orb
                           ampl_kii%val(a,a,a) = ampl_kii%val(a,a,a) * e_orb
                        else if ((a .eq. b) .and. (a .gt. c)) then
                           ampl_iik%val(a,a,c) = ampl_iik%val(a,a,c) * e_orb
                           ampl_iki%val(a,a,c) = ampl_iki%val(a,a,c) * e_orb
                           ampl_kii%val(a,a,c) = ampl_kii%val(a,a,c) * e_orb
                           ampl_iik%val(a,c,a) = ampl_iik%val(a,c,a) * e_orb
                           ampl_iki%val(a,c,a) = ampl_iki%val(a,c,a) * e_orb
                           ampl_kii%val(a,c,a) = ampl_kii%val(a,c,a) * e_orb
                           ampl_iik%val(c,a,a) = ampl_iik%val(c,a,a) * e_orb
                           ampl_iki%val(c,a,a) = ampl_iki%val(c,a,a) * e_orb
                           ampl_kii%val(c,a,a) = ampl_kii%val(c,a,a) * e_orb
                        else if ((a .gt. b) .and. (b .eq. c)) then
                           ampl_iik%val(a,b,b) = ampl_iik%val(a,b,b) * e_orb
                           ampl_iki%val(a,b,b) = ampl_iki%val(a,b,b) * e_orb
                           ampl_kii%val(a,b,b) = ampl_kii%val(a,b,b) * e_orb
                           ampl_iik%val(b,a,b) = ampl_iik%val(b,a,b) * e_orb
                           ampl_iki%val(b,a,b) = ampl_iki%val(b,a,b) * e_orb
                           ampl_kii%val(b,a,b) = ampl_kii%val(b,a,b) * e_orb
                           ampl_iik%val(b,b,a) = ampl_iik%val(b,b,a) * e_orb
                           ampl_iki%val(b,b,a) = ampl_iki%val(b,b,a) * e_orb
                           ampl_kii%val(b,b,a) = ampl_kii%val(b,b,a) * e_orb             
                        else if ((a .gt. b) .and. (b .gt. c)) then
                           ampl_iik%val(a,b,c) = ampl_iik%val(a,b,c) * e_orb
                           ampl_iki%val(a,b,c) = ampl_iki%val(a,b,c) * e_orb
                           ampl_kii%val(a,b,c) = ampl_kii%val(a,b,c) * e_orb
                           ampl_iik%val(c,a,b) = ampl_iik%val(c,a,b) * e_orb
                           ampl_iki%val(c,a,b) = ampl_iki%val(c,a,b) * e_orb
                           ampl_kii%val(c,a,b) = ampl_kii%val(c,a,b) * e_orb
                           ampl_iik%val(b,c,a) = ampl_iik%val(b,c,a) * e_orb
                           ampl_iki%val(b,c,a) = ampl_iki%val(b,c,a) * e_orb
                           ampl_kii%val(b,c,a) = ampl_kii%val(b,c,a) * e_orb
                           ampl_iik%val(a,c,b) = ampl_iik%val(a,c,b) * e_orb
                           ampl_iki%val(a,c,b) = ampl_iki%val(a,c,b) * e_orb
                           ampl_kii%val(a,c,b) = ampl_kii%val(a,c,b) * e_orb
                           ampl_iik%val(b,a,c) = ampl_iik%val(b,a,c) * e_orb
                           ampl_iki%val(b,a,c) = ampl_iki%val(b,a,c) * e_orb
                           ampl_kii%val(b,a,c) = ampl_kii%val(b,a,c) * e_orb
                           ampl_iik%val(c,b,a) = ampl_iik%val(c,b,a) * e_orb
                           ampl_iki%val(c,b,a) = ampl_iki%val(c,b,a) * e_orb
                           ampl_kii%val(c,b,a) = ampl_kii%val(c,b,a) * e_orb
                        end if

             end do crun_1
          end do brun_1
       end do arun_1

    case(2)

       e_orb = 0.0E0_realk
       arun_2: do a=1,nv
          brun_2: do b=1,nv
                  if (.not. a .ge. b) cycle arun_2
             crun_2: do c=1,nv
                     if (.not. b .ge. c) cycle brun_2

                        e_orb = -1.0E0_realk / (eigenvirt(a) + eigenvirt(b) + eigenvirt(c) &
                                           & - eigenocc(oindex1) - eigenocc(oindex2) - eigenocc(oindex3))

                        if ((a .eq. b) .and. (b .eq. c)) then
                           ampl_ijj%val(a,a,a) = ampl_ijj%val(a,a,a) * e_orb
                           ampl_jij%val(a,a,a) = ampl_jij%val(a,a,a) * e_orb
                           ampl_jji%val(a,a,a) = ampl_jji%val(a,a,a) * e_orb
                        else if ((a .eq. b) .and. (a .gt. c)) then
                           ampl_ijj%val(a,a,c) = ampl_ijj%val(a,a,c) * e_orb
                           ampl_jij%val(a,a,c) = ampl_jij%val(a,a,c) * e_orb
                           ampl_jji%val(a,a,c) = ampl_jji%val(a,a,c) * e_orb
                           ampl_ijj%val(a,c,a) = ampl_ijj%val(a,c,a) * e_orb
                           ampl_jij%val(a,c,a) = ampl_jij%val(a,c,a) * e_orb
                           ampl_jji%val(a,c,a) = ampl_jji%val(a,c,a) * e_orb
                           ampl_ijj%val(c,a,a) = ampl_ijj%val(c,a,a) * e_orb
                           ampl_jij%val(c,a,a) = ampl_jij%val(c,a,a) * e_orb
                           ampl_jji%val(c,a,a) = ampl_jji%val(c,a,a) * e_orb
                        else if ((a .gt. b) .and. (b .eq. c)) then
                           ampl_ijj%val(a,b,b) = ampl_ijj%val(a,b,b) * e_orb
                           ampl_jij%val(a,b,b) = ampl_jij%val(a,b,b) * e_orb
                           ampl_jji%val(a,b,b) = ampl_jji%val(a,b,b) * e_orb
                           ampl_ijj%val(b,a,b) = ampl_ijj%val(b,a,b) * e_orb
                           ampl_jij%val(b,a,b) = ampl_jij%val(b,a,b) * e_orb
                           ampl_jji%val(b,a,b) = ampl_jji%val(b,a,b) * e_orb
                           ampl_ijj%val(b,b,a) = ampl_ijj%val(b,b,a) * e_orb
                           ampl_jij%val(b,b,a) = ampl_jij%val(b,b,a) * e_orb
                           ampl_jji%val(b,b,a) = ampl_jji%val(b,b,a) * e_orb
                        else if ((a .gt. b) .and. (b .gt. c)) then
                           ampl_ijj%val(a,b,c) = ampl_ijj%val(a,b,c) * e_orb
                           ampl_jij%val(a,b,c) = ampl_jij%val(a,b,c) * e_orb
                           ampl_jji%val(a,b,c) = ampl_jji%val(a,b,c) * e_orb
                           ampl_ijj%val(c,a,b) = ampl_ijj%val(c,a,b) * e_orb
                           ampl_jij%val(c,a,b) = ampl_jij%val(c,a,b) * e_orb
                           ampl_jji%val(c,a,b) = ampl_jji%val(c,a,b) * e_orb
                           ampl_ijj%val(b,c,a) = ampl_ijj%val(b,c,a) * e_orb
                           ampl_jij%val(b,c,a) = ampl_jij%val(b,c,a) * e_orb
                           ampl_jji%val(b,c,a) = ampl_jji%val(b,c,a) * e_orb
                           ampl_ijj%val(a,c,b) = ampl_ijj%val(a,c,b) * e_orb
                           ampl_jij%val(a,c,b) = ampl_jij%val(a,c,b) * e_orb
                           ampl_jji%val(a,c,b) = ampl_jji%val(a,c,b) * e_orb
                           ampl_ijj%val(b,a,c) = ampl_ijj%val(b,a,c) * e_orb
                           ampl_jij%val(b,a,c) = ampl_jij%val(b,a,c) * e_orb
                           ampl_jji%val(b,a,c) = ampl_jji%val(b,a,c) * e_orb
                           ampl_ijj%val(c,b,a) = ampl_ijj%val(c,b,a) * e_orb
                           ampl_jij%val(c,b,a) = ampl_jij%val(c,b,a) * e_orb
                           ampl_jji%val(c,b,a) = ampl_jji%val(c,b,a) * e_orb
                        end if

             end do crun_2
          end do brun_2
       end do arun_2

    case(3)

       e_orb = 0.0E0_realk
       arun_3: do a=1,nv
          brun_3: do b=1,nv
                  if (.not. a .ge. b) cycle arun_3
             crun_3: do c=1,nv
                     if (.not. b .ge. c) cycle brun_3

                        e_orb = -1.0E0_realk / (eigenvirt(a) + eigenvirt(b) + eigenvirt(c) &
                                           & - eigenocc(oindex1) - eigenocc(oindex2) - eigenocc(oindex3))

                        if ((a .eq. b) .and. (b .eq. c)) then
                           ampl_ijk%val(a,a,a) = ampl_ijk%val(a,a,a) * e_orb
                           ampl_kij%val(a,a,a) = ampl_kij%val(a,a,a) * e_orb
                           ampl_jki%val(a,a,a) = ampl_jki%val(a,a,a) * e_orb
                           ampl_ikj%val(a,a,a) = ampl_ikj%val(a,a,a) * e_orb
                           ampl_jik%val(a,a,a) = ampl_jik%val(a,a,a) * e_orb
                           ampl_kji%val(a,a,a) = ampl_kji%val(a,a,a) * e_orb
                        else if ((a .eq. b) .and. (a .gt. c)) then
                           ampl_ijk%val(a,a,c) = ampl_ijk%val(a,a,c) * e_orb
                           ampl_kij%val(a,a,c) = ampl_kij%val(a,a,c) * e_orb
                           ampl_jki%val(a,a,c) = ampl_jki%val(a,a,c) * e_orb
                           ampl_ikj%val(a,a,c) = ampl_ikj%val(a,a,c) * e_orb
                           ampl_jik%val(a,a,c) = ampl_jik%val(a,a,c) * e_orb
                           ampl_kji%val(a,a,c) = ampl_kji%val(a,a,c) * e_orb
                           ampl_ijk%val(a,c,a) = ampl_ijk%val(a,c,a) * e_orb
                           ampl_kij%val(a,c,a) = ampl_kij%val(a,c,a) * e_orb
                           ampl_jki%val(a,c,a) = ampl_jki%val(a,c,a) * e_orb
                           ampl_ikj%val(a,c,a) = ampl_ikj%val(a,c,a) * e_orb
                           ampl_jik%val(a,c,a) = ampl_jik%val(a,c,a) * e_orb
                           ampl_kji%val(a,c,a) = ampl_kji%val(a,c,a) * e_orb
                           ampl_ijk%val(c,a,a) = ampl_ijk%val(c,a,a) * e_orb
                           ampl_kij%val(c,a,a) = ampl_kij%val(c,a,a) * e_orb
                           ampl_jki%val(c,a,a) = ampl_jki%val(c,a,a) * e_orb
                           ampl_ikj%val(c,a,a) = ampl_ikj%val(c,a,a) * e_orb
                           ampl_jik%val(c,a,a) = ampl_jik%val(c,a,a) * e_orb
                           ampl_kji%val(c,a,a) = ampl_kji%val(c,a,a) * e_orb                        
                        else if ((a .gt. b) .and. (b .eq. c)) then
                           ampl_ijk%val(a,b,b) = ampl_ijk%val(a,b,b) * e_orb
                           ampl_kij%val(a,b,b) = ampl_kij%val(a,b,b) * e_orb
                           ampl_jki%val(a,b,b) = ampl_jki%val(a,b,b) * e_orb
                           ampl_ikj%val(a,b,b) = ampl_ikj%val(a,b,b) * e_orb
                           ampl_jik%val(a,b,b) = ampl_jik%val(a,b,b) * e_orb
                           ampl_kji%val(a,b,b) = ampl_kji%val(a,b,b) * e_orb
                           ampl_ijk%val(b,a,b) = ampl_ijk%val(b,a,b) * e_orb
                           ampl_kij%val(b,a,b) = ampl_kij%val(b,a,b) * e_orb
                           ampl_jki%val(b,a,b) = ampl_jki%val(b,a,b) * e_orb
                           ampl_ikj%val(b,a,b) = ampl_ikj%val(b,a,b) * e_orb
                           ampl_jik%val(b,a,b) = ampl_jik%val(b,a,b) * e_orb
                           ampl_kji%val(b,a,b) = ampl_kji%val(b,a,b) * e_orb
                           ampl_ijk%val(b,b,a) = ampl_ijk%val(b,b,a) * e_orb
                           ampl_kij%val(b,b,a) = ampl_kij%val(b,b,a) * e_orb
                           ampl_jki%val(b,b,a) = ampl_jki%val(b,b,a) * e_orb
                           ampl_ikj%val(b,b,a) = ampl_ikj%val(b,b,a) * e_orb
                           ampl_jik%val(b,b,a) = ampl_jik%val(b,b,a) * e_orb
                           ampl_kji%val(b,b,a) = ampl_kji%val(b,b,a) * e_orb
                        else if ((a .gt. b) .and. (b .gt. c)) then
                           ampl_ijk%val(a,b,c) = ampl_ijk%val(a,b,c) * e_orb
                           ampl_kij%val(a,b,c) = ampl_kij%val(a,b,c) * e_orb
                           ampl_jki%val(a,b,c) = ampl_jki%val(a,b,c) * e_orb
                           ampl_ikj%val(a,b,c) = ampl_ikj%val(a,b,c) * e_orb
                           ampl_jik%val(a,b,c) = ampl_jik%val(a,b,c) * e_orb
                           ampl_kji%val(a,b,c) = ampl_kji%val(a,b,c) * e_orb
                           ampl_ijk%val(c,a,b) = ampl_ijk%val(c,a,b) * e_orb
                           ampl_kij%val(c,a,b) = ampl_kij%val(c,a,b) * e_orb
                           ampl_jki%val(c,a,b) = ampl_jki%val(c,a,b) * e_orb
                           ampl_ikj%val(c,a,b) = ampl_ikj%val(c,a,b) * e_orb
                           ampl_jik%val(c,a,b) = ampl_jik%val(c,a,b) * e_orb
                           ampl_kji%val(c,a,b) = ampl_kji%val(c,a,b) * e_orb
                           ampl_ijk%val(b,c,a) = ampl_ijk%val(b,c,a) * e_orb
                           ampl_kij%val(b,c,a) = ampl_kij%val(b,c,a) * e_orb
                           ampl_jki%val(b,c,a) = ampl_jki%val(b,c,a) * e_orb
                           ampl_ikj%val(b,c,a) = ampl_ikj%val(b,c,a) * e_orb
                           ampl_jik%val(b,c,a) = ampl_jik%val(b,c,a) * e_orb
                           ampl_kji%val(b,c,a) = ampl_kji%val(b,c,a) * e_orb
                           ampl_ijk%val(a,c,b) = ampl_ijk%val(a,c,b) * e_orb
                           ampl_kij%val(a,c,b) = ampl_kij%val(a,c,b) * e_orb
                           ampl_jki%val(a,c,b) = ampl_jki%val(a,c,b) * e_orb
                           ampl_ikj%val(a,c,b) = ampl_ikj%val(a,c,b) * e_orb
                           ampl_jik%val(a,c,b) = ampl_jik%val(a,c,b) * e_orb
                           ampl_kji%val(a,c,b) = ampl_kji%val(a,c,b) * e_orb
                           ampl_ijk%val(b,a,c) = ampl_ijk%val(b,a,c) * e_orb
                           ampl_kij%val(b,a,c) = ampl_kij%val(b,a,c) * e_orb
                           ampl_jki%val(b,a,c) = ampl_jki%val(b,a,c) * e_orb
                           ampl_ikj%val(b,a,c) = ampl_ikj%val(b,a,c) * e_orb
                           ampl_jik%val(b,a,c) = ampl_jik%val(b,a,c) * e_orb
                           ampl_kji%val(b,a,c) = ampl_kji%val(b,a,c) * e_orb
                           ampl_ijk%val(c,b,a) = ampl_ijk%val(c,b,a) * e_orb
                           ampl_kij%val(c,b,a) = ampl_kij%val(c,b,a) * e_orb
                           ampl_jki%val(c,b,a) = ampl_jki%val(c,b,a) * e_orb
                           ampl_ikj%val(c,b,a) = ampl_ikj%val(c,b,a) * e_orb
                           ampl_jik%val(c,b,a) = ampl_jik%val(c,b,a) * e_orb
                           ampl_kji%val(c,b,a) = ampl_kji%val(c,b,a) * e_orb
                        end if

             end do crun_3
          end do brun_3
       end do arun_3

    end select TypeofDenominator

  end subroutine trip_denom2


  !> brief: do the two contractions over 'cdkl' (here: 'c' and 'd', 'k' and 'l' are summations in driver routine)
  !  in eq. (14.6.63) of MEST
  !> author: Janus Juul Eriksen
  !> date: August 2012
  !> param: oindex1-oindex3 are outside loop indices of driver routine. int_normal is canAIBJ of driver.
  !> nv is nvirt and T_star is T_ast_0 of driver. ampl_xxx are (optional) amplitude arrays.
  subroutine eccsdpt_contract_1(oindex1,oindex2,oindex3,nv,int_normal,T_star,ampl_iik,&
       & ampl_iki,ampl_kii,ampl_ijj,ampl_jij,ampl_jji,ampl_ijk,ampl_kij,ampl_jki,ampl_ikj,&
       & ampl_jik,ampl_kji)

    implicit none
    !> input
    integer, intent(in) :: oindex1, oindex2, oindex3, nv
    type(array2), intent(inout) :: T_star
    type(array4), intent(inout) :: int_normal
    type(array3), optional, intent(inout) :: ampl_iik, ampl_iki, ampl_kii, ampl_ijj, ampl_jij, ampl_jji
    type(array3), optional, intent(inout) :: ampl_ijk, ampl_kij, ampl_jki, ampl_ikj, ampl_jik, ampl_kji
    !> temporary quantities
    integer :: contraction_type, idx, p0(5), p1(6), p2(6), p3(6)
    integer(kind=long) :: copy_size
    type(array2) :: tmp_g_1, tmp_g_2
    real(realk), pointer :: interm_cou(:), interm_exc(:), interm_cou_2(:), interm_exc_2(:)
    type(array3) :: temp, temp2

    ! NOTE: incoming array4 structures are ordered according to:
    ! canAIBJ(c,d,k,l) (MEST nomenclature)
    ! T_ast_0(a,i)

    ! initiate the loop index vectors, p0, p1, p2, and p3
    p0(1:5) = (/ oindex1, oindex2, oindex3, oindex1, oindex2 /)

    p1(1:6) = (/ oindex1, oindex3, oindex2, oindex1, oindex2, oindex3 /)
    p2(1:6) = (/ oindex3, oindex2, oindex1, oindex2, oindex3, oindex1 /)
    p3(1:6) = (/ oindex2, oindex1, oindex3, oindex3, oindex1, oindex2 /)

    ! define copy_size
    copy_size = nv**3

    ! determine which type of contraction is to be performed
    contraction_type = -1
    ! i == j == k
    ! this (i .eq. j .eq. k) contribution is zero!
    ! i == j > k
    if (present(ampl_iik) .and. present(ampl_iki) .and. present(ampl_kii)) contraction_type = 1
    ! i > j == k
    if (present(ampl_ijj) .and. present(ampl_jij) .and. present(ampl_jji)) contraction_type = 2
    ! i > j > k
    if (present(ampl_ijk) .and. present(ampl_kij) .and. present(ampl_jki) &
       & .and. present(ampl_ikj) .and. present(ampl_jik) .and. present(ampl_kji)) contraction_type = 3

    ! contraction time (here: over virtual indices 'c' and 'd') with "coulumb minus exchange"
    ! version of canAIBJ (2 * canAIJK(c,k,d,l) - canAIBC(c,l,d,k)) using temp and temp2

    TypeofContraction_1: select case(contraction_type)

    case(1)

       ! init temporary arrays, tmp_g_1 and tmp_g_2 array2s in addition to interm_cou, interm_exc,
       ! interm_cou_2, and interm_exc_2 1d pointers. also, init temp and temp2 array3s
       tmp_g_1 = array2_init_plain([nv,nv])
       tmp_g_2 = array2_init_plain([nv,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       call mem_alloc(interm_cou,nv)
       call mem_alloc(interm_cou_2,nv)
       call mem_alloc(interm_exc,nv)
       call mem_alloc(interm_exc_2,nv)

       do idx=1,3

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_iik%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kii%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_iki%val,1,temp%val,1)
             call dcopy(copy_size,ampl_iki%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_kii%val,1,temp%val,1)
             call dcopy(copy_size,ampl_iik%val,1,temp2%val,1)
          end if

          ! canAIBJ(c,d,k,l) --> tmp_g_1(c,d) (coulumb)
          call dcopy(nv**2,int_normal%val(:,:,p0(idx+1),p0(idx+2)),1,tmp_g_1%val,1)
          ! canAIBJ(c,d,l,k) --> tmp_g_2(c,d) (exchange)
          call dcopy(nv**2,int_normal%val(:,:,p0(idx+2),p0(idx+1)),1,tmp_g_2%val,1)

          ! now contract coulumb term over both indices into interm_cou(_2)(a) 1d pointer
          call dgemm('n','n',temp%dims(1),1,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 1.0E0_realk,temp%val,temp%dims(1),tmp_g_1%val,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 0.0E0_realk,interm_cou,temp%dims(1))
          call dgemm('n','n',temp2%dims(1),1,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 1.0E0_realk,temp2%val,temp2%dims(1),tmp_g_1%val,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 0.0E0_realk,interm_cou_2,temp2%dims(1))

          ! now contract exchange term over both indices into interm_exc(_2)(a) 1d pointer
          call dgemm('n','n',temp%dims(1),1,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 1.0E0_realk,temp%val,temp%dims(1),tmp_g_2%val,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 0.0E0_realk,interm_exc,temp%dims(1))
          call dgemm('n','n',temp2%dims(1),1,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 1.0E0_realk,temp2%val,temp2%dims(1),tmp_g_2%val,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 0.0E0_realk,interm_exc_2,temp2%dims(1))

          ! now collect in T_star array2 structure
          T_star%val(:,p0(idx)) = T_star%val(:,p0(idx)) + 2.0E0_realk * (interm_cou - interm_cou_2) &
                                & - (interm_exc - interm_exc_2)

       end do

       ! release temporary array2s and array3s
       call array2_free(tmp_g_1)
       call array2_free(tmp_g_2)
       call array3_free(temp)
       call array3_free(temp2)
       call mem_dealloc(interm_cou)
       call mem_dealloc(interm_cou_2)
       call mem_dealloc(interm_exc)
       call mem_dealloc(interm_exc_2)

    case(2)

       ! init temporary arrays, tmp_g_1 and tmp_g_2 array2s in addition to interm_cou, interm_exc,
       ! interm_cou_2, and interm_exc_2 1d pointers. also, init temp and temp2 array3s
       tmp_g_1 = array2_init_plain([nv,nv])
       tmp_g_2 = array2_init_plain([nv,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       call mem_alloc(interm_cou,nv)
       call mem_alloc(interm_cou_2,nv)
       call mem_alloc(interm_exc,nv)
       call mem_alloc(interm_exc_2,nv)

       do idx=1,3

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_ijj%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jji%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_jji%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ijj%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_jij%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jij%val,1,temp2%val,1)
          end if

          ! canAIBJ(c,d,k,l) --> tmp_g_1(c,d) (coulumb)
          call dcopy(nv**2,int_normal%val(:,:,p0(idx+1),p0(idx+2)),1,tmp_g_1%val,1)
          ! canAIBJ(c,d,l,k) --> tmp_g_2(c,d) (exchange)
          call dcopy(nv**2,int_normal%val(:,:,p0(idx+2),p0(idx+1)),1,tmp_g_2%val,1)

          ! now contract coulumb term over both indices into interm_cou(_2)(a) 1d pointer
          call dgemm('n','n',temp%dims(1),1,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 1.0E0_realk,temp%val,temp%dims(1),tmp_g_1%val,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 0.0E0_realk,interm_cou,temp%dims(1))
          call dgemm('n','n',temp2%dims(1),1,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 1.0E0_realk,temp2%val,temp2%dims(1),tmp_g_1%val,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 0.0E0_realk,interm_cou_2,temp2%dims(1))

          ! now contract exchange term over both indices into interm_exc(_2)(a) 1d pointer
          call dgemm('n','n',temp%dims(1),1,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 1.0E0_realk,temp%val,temp%dims(1),tmp_g_2%val,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 0.0E0_realk,interm_exc,temp%dims(1))
          call dgemm('n','n',temp2%dims(1),1,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 1.0E0_realk,temp2%val,temp2%dims(1),tmp_g_2%val,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 0.0E0_realk,interm_exc_2,temp2%dims(1))

          ! now collect in T_star array2 structure
          ! load interm_cou, interm_exc, and interm_cou_2 into T_star_interm(j,a,b) array3
          T_star%val(:,p0(idx)) = T_star%val(:,p0(idx)) + 2.0E0_realk * (interm_cou - interm_cou_2) &
                                & - (interm_exc - interm_exc_2)

       end do

       ! release temporary array2s and array3s
       call array2_free(tmp_g_1)
       call array2_free(tmp_g_2)
       call array3_free(temp)
       call array3_free(temp2)
       call mem_dealloc(interm_cou)
       call mem_dealloc(interm_cou_2)
       call mem_dealloc(interm_exc)
       call mem_dealloc(interm_exc_2)

    case(3)

       ! init temporary arrays, tmp_g_1 and tmp_g_2 array2s in addition to interm_cou, interm_exc,
       ! interm_cou_2, and interm_exc_2 1d pointers. also, init temp and temp2 array3s
       tmp_g_1 = array2_init_plain([nv,nv])
       tmp_g_2 = array2_init_plain([nv,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       call mem_alloc(interm_cou,nv)
       call mem_alloc(interm_cou_2,nv)
       call mem_alloc(interm_exc,nv)
       call mem_alloc(interm_exc_2,nv)

       do idx=1,6

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_ijk%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kji%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_kij%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jik%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_jki%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ikj%val,1,temp2%val,1)
          else if (idx .eq. 4) then
             call dcopy(copy_size,ampl_ikj%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jki%val,1,temp2%val,1)
          else if (idx .eq. 5) then
             call dcopy(copy_size,ampl_jik%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kij%val,1,temp2%val,1)
          else if (idx .eq. 6) then
             call dcopy(copy_size,ampl_kji%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ijk%val,1,temp2%val,1)
          end if

          ! canAIBJ(c,d,k,l) --> tmp_g_1(c,d) (coulumb)
          call dcopy(nv**2,int_normal%val(:,:,p3(idx),p2(idx)),1,tmp_g_1%val,1)
          ! canAIBJ(c,d,l,k) --> tmp_g_2(c,d) (exchange)
          call dcopy(nv**2,int_normal%val(:,:,p2(idx),p3(idx)),1,tmp_g_2%val,1)

          ! now contract coulumb term over both indices into interm_cou(_2)(a) 1d pointer
          call dgemm('n','n',temp%dims(1),1,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 1.0E0_realk,temp%val,temp%dims(1),tmp_g_1%val,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 0.0E0_realk,interm_cou,temp%dims(1))
          call dgemm('n','n',temp2%dims(1),1,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 1.0E0_realk,temp2%val,temp2%dims(1),tmp_g_1%val,tmp_g_1%dims(1)*tmp_g_1%dims(2),&
                   & 0.0E0_realk,interm_cou_2,temp2%dims(1))

          ! now contract exchange term over both indices into interm_exc(_2)(a) 1d pointer
          call dgemm('n','n',temp%dims(1),1,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 1.0E0_realk,temp%val,temp%dims(1),tmp_g_2%val,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 0.0E0_realk,interm_exc,temp%dims(1))
          call dgemm('n','n',temp2%dims(1),1,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 1.0E0_realk,temp2%val,temp2%dims(1),tmp_g_2%val,tmp_g_2%dims(1)*tmp_g_2%dims(2),&
                   & 0.0E0_realk,interm_exc_2,temp2%dims(1))

          ! now collect in T_star array2 structure
          ! load interm_cou, interm_exc, and interm_cou_2 into T_star_interm(j,a,b) array3
          T_star%val(:,p1(idx)) = T_star%val(:,p1(idx)) + 2.0E0_realk * (interm_cou - interm_cou_2) &
                                & - (interm_exc - interm_exc_2)

       end do

       ! release temporary array2s and array3s
       call array2_free(tmp_g_1)
       call array2_free(tmp_g_2)
       call array3_free(temp)
       call array3_free(temp2)
       call mem_dealloc(interm_cou)
       call mem_dealloc(interm_cou_2)
       call mem_dealloc(interm_exc)
       call mem_dealloc(interm_exc_2)

    end select TypeofContraction_1

  end subroutine eccsdpt_contract_1



  !> brief: do the two contractions over 'cdk' (here: 'cd', 'k' is the summation in driver routine)
  !  in eq. (14.6.64) of MEST
  !> author: Janus Juul Eriksen
  !> date: August 2012
  !> param: oindex1-oindex3 are outside loop indices of driver routine.
  !> nv is nvirt and T_star is T_ast_1 of driver. ampl_xxx are (optional) amplitude arrays.
  subroutine eccsdpt_contract_21(oindex1,oindex2,oindex3,nv,int_virt,T_star,ampl_iii,ampl_iik,&
       & ampl_iki,ampl_kii,ampl_ijj,ampl_jij,ampl_jji,ampl_ijk,ampl_kij,ampl_jki,ampl_ikj,&
       & ampl_jik,ampl_kji)

    implicit none
    !> input
    integer, intent(in) :: oindex1, oindex2, oindex3, nv
    type(array4), intent(inout) :: int_virt, T_star
    type(array3), optional, intent(inout) :: ampl_iii, ampl_iik, ampl_iki, ampl_kii, ampl_ijj, ampl_jij, ampl_jji
    type(array3), optional, intent(inout) :: ampl_ijk, ampl_kij, ampl_jki, ampl_ikj, ampl_jik, ampl_kji
    !> temporary quantities
    integer :: contraction_type, idx, p0(5), p1(6), p2(6), p3(6)
    integer(kind=long) :: copy_size
    type(array2) :: interm_cou, interm_cou_2, interm_exc, T_star_interm
    type(array3) :: temp, temp2, tmp_g

    ! NOTE: incoming array4 structures are ordered according to:
    ! canAIBC(c,b,a,i)
    ! T_ast_1(a,b,i,j)

    ! initiate the loop index vectors, p0, p1, p2, and p3
    p0(1:5) = (/ oindex1, oindex2, oindex3, oindex1, oindex2 /)

    p1(1:6) = (/ oindex1, oindex3, oindex2, oindex1, oindex2, oindex3 /)
    p2(1:6) = (/ oindex2, oindex1, oindex3, oindex3, oindex1, oindex2 /)
    p3(1:6) = (/ oindex3, oindex2, oindex1, oindex2, oindex3, oindex1 /)

    ! define copy_size
    copy_size = nv**3

    ! determine which type of contraction is to be performed
    contraction_type = -1
    ! i == j == k
    if (present(ampl_iii)) contraction_type = 0
    ! i == j > k
    if (present(ampl_iik) .and. present(ampl_iki) .and. present(ampl_kii)) contraction_type = 1
    ! i > j == k
    if (present(ampl_ijj) .and. present(ampl_jij) .and. present(ampl_jji)) contraction_type = 2
    ! i > j > k
    if (present(ampl_ijk) .and. present(ampl_kij) .and. present(ampl_jki) &
       & .and. present(ampl_ikj) .and. present(ampl_jik) .and. present(ampl_kji)) contraction_type = 3

    ! contraction time (here: over virtual indices 'c' and 'd') with "coulumb minus exchange"
    ! version of canAIBC (2 * canAIBC(b,c,k,d) - canAIBC(b,d,k,c)) using temp and canAIBC(b,c,k,d)
    ! using temp2

    TypeofContraction_21: select case(contraction_type)

    case(0)

       ! note: temp and temp2 (both ampl_iii) are alike, so we collect contract over L_{dkbc}
       ! and g_{dkbc} in one go.

       ! init temporary arrays, tmp_g array3 in addition to interm_cou and interm_exc array2s
       tmp_g = array3_init_standard([nv,nv,nv])
       interm_cou = array2_init_plain([nv,nv])
       interm_exc = array2_init_plain([nv,nv])

       ! canAIBC(c,b,d,k) --> tmp_g(c,b,d) (coulumb)
       call dcopy(nv**3,int_virt%val(:,:,:,oindex1),1,tmp_g%val,1) ! i == j == k
       ! reorder to obtain tmp_g(c,d,b)
       call array3_reorder(tmp_g,[1,3,2])

       ! now contract coulumb term over 2 first indices into interm_cou(a,b) array2
       ! first, reorder trip(a,c,d) --> trip(c,d,a)
       call array3_reorder(ampl_iii,[2,3,1])
       call array3_contract2(ampl_iii,tmp_g,interm_cou)

       ! reorder tmp_g to obtain exchange term, i.e., tmp_g(c,d,b) --> tmp_g(d,c,b)
       call array3_reorder(tmp_g,[2,1,3])

       ! now contract exchange term over 2 first indices into interm_exc(a,b) array2
       call array3_contract2(ampl_iii,tmp_g,interm_exc)

       ! release tmp_g array3 structure
       call array3_free(tmp_g)

       ! now collect in T_star array4 structure
       ! first, load interm_cou and interm_exc into T_star_interm(a,b) array2
       T_star_interm = array2_add_scale(1.0E0_realk,interm_cou,-1.0E0_realk,interm_exc)

       ! release interm_cou and interm_exc
       call array2_free(interm_cou)
       call array2_free(interm_exc)

       ! load T_star_interm into T_star array4 structure
       T_star%val(:,:,oindex1,oindex1) = T_star%val(:,:,oindex1,oindex1) + T_star_interm%val ! i == j == k

       ! release T_star_interm array2
       call array2_free(T_star_interm)

    case(1)

       ! init temporary array3s, tmp_g, temp, and temp2 in addition to 
       ! interm_cou, interm_exc, interm_cou_2 and T_star_interm array2s
       tmp_g = array3_init_standard([nv,nv,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       interm_cou = array2_init_plain([nv,nv])
       interm_cou_2 = array2_init_plain([nv,nv])
       interm_exc = array2_init_plain([nv,nv])
       T_star_interm = array2_init_plain([nv,nv])

       do idx=1,3

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_iik%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kii%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_iki%val,1,temp%val,1)
             call dcopy(copy_size,ampl_iki%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_kii%val,1,temp%val,1)
             call dcopy(copy_size,ampl_iik%val,1,temp2%val,1)
          end if

          ! canAIBC(c,b,d,k) --> tmp_g(c,b,d) (coulumb)
          call dcopy(nv**3,int_virt%val(:,:,:,p0(idx+2)),1,tmp_g%val,1)
          ! reorder to obtain tmp_g(c,d,b)
          call array3_reorder(tmp_g,[1,3,2])

          ! now contract coulumb term over 2 first indices into interm_cou(_2)(a,b) array2
          ! first, reorder trip(a,c,d) --> trip(c,d,a)
          call array3_reorder(temp,[2,3,1])
          call array3_reorder(temp2,[2,3,1])
          call array3_contract2(temp,tmp_g,interm_cou)
          call array3_contract2(temp2,tmp_g,interm_cou_2)

          ! reorder tmp_g to obtain exchange term, i.e., tmp_g(c,d,b) --> tmp_g(d,c,b)
          call array3_reorder(tmp_g,[2,1,3])

          ! now contract exchange term over 2 first indices into interm_exc(a,b) array2
          call array3_contract2(temp,tmp_g,interm_exc)

          ! now collect in T_star array4 structure
          ! 1. load interm_cou and interm_exc into T_star_interm(a,b) array2 
          ! which is now an L_{bckd}-contracted quantity
          ! 2. subtract g_{dkbc} term
          T_star_interm%val = 2.0E0_realk * interm_cou%val - 1.0E0_realk * interm_exc%val
          T_star_interm%val = 1.0E0_realk * T_star_interm%val - 1.0E0_realk * interm_cou_2%val

          ! load T_star_interm into T_star array4 structure
          T_star%val(:,:,p0(idx),p0(idx+1)) = T_star%val(:,:,p0(idx),p0(idx+1)) + T_star_interm%val

       end do

       ! release temporary array2s and array3s
       call array3_free(tmp_g)
       call array3_free(temp)
       call array3_free(temp2)
       call array2_free(interm_cou)
       call array2_free(interm_cou_2)
       call array2_free(interm_exc)
       call array2_free(T_star_interm)

    case(2)

       ! init temporary array3s, tmp_g, temp, and temp2 in addition to 
       ! interm_cou, interm_exc, interm_cou_2 and T_star_interm array2s
       tmp_g = array3_init_standard([nv,nv,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       interm_cou = array2_init_plain([nv,nv])
       interm_cou_2 = array2_init_plain([nv,nv])
       interm_exc = array2_init_plain([nv,nv])
       T_star_interm = array2_init_plain([nv,nv])

       do idx=1,3

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_ijj%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jji%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_jji%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ijj%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_jij%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jij%val,1,temp2%val,1)
          end if

          ! canAIBC(c,b,d,k) --> tmp_g(c,b,d) (coulumb)
          call dcopy(nv**3,int_virt%val(:,:,:,p0(idx+2)),1,tmp_g%val,1)
          ! reorder to obtain tmp_g(c,d,b)
          call array3_reorder(tmp_g,[1,3,2])

          ! now contract coulumb term over 2 first indices into interm_cou(_2)(a,b) array2
          ! first, reorder trip(a,c,d) --> trip(c,d,a)
          call array3_reorder(temp,[2,3,1])
          call array3_reorder(temp2,[2,3,1])
          call array3_contract2(temp,tmp_g,interm_cou)
          call array3_contract2(temp2,tmp_g,interm_cou_2)

          ! reorder tmp_g to obtain exchange term, i.e., tmp_g(c,d,b) --> tmp_g(d,c,b)
          call array3_reorder(tmp_g,[2,1,3])

          ! now contract exchange term over 2 first indices into interm_exc(a,b) array2
          call array3_contract2(temp,tmp_g,interm_exc)

          ! now collect in T_star array4 structure
          ! 1. load interm_cou and interm_exc into T_star_interm(a,b) array2 
          ! which is now an L_{bckd}-contracted quantity
          ! 2. subtract g_{dkbc} term
          T_star_interm%val = 2.0E0_realk * interm_cou%val - 1.0E0_realk * interm_exc%val
          T_star_interm%val = 1.0E0_realk * T_star_interm%val - 1.0E0_realk * interm_cou_2%val

          ! load T_star_interm into T_star array4 structure
          T_star%val(:,:,p0(idx),p0(idx+1)) = T_star%val(:,:,p0(idx),p0(idx+1)) + T_star_interm%val

       end do

       ! release temporary array2s and array3s
       call array3_free(tmp_g)
       call array3_free(temp)
       call array3_free(temp2)
       call array2_free(interm_cou)
       call array2_free(interm_cou_2)
       call array2_free(interm_exc)
       call array2_free(T_star_interm)

    case(3)

       ! init temporary array3s, tmp_g, temp, and temp2 in addition to 
       ! interm_cou, interm_exc, interm_cou_2 and T_star_interm array2s
       tmp_g = array3_init_standard([nv,nv,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       interm_cou = array2_init_plain([nv,nv])
       interm_cou_2 = array2_init_plain([nv,nv])
       interm_exc = array2_init_plain([nv,nv])
       T_star_interm = array2_init_plain([nv,nv])

       do idx=1,6

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_ijk%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kji%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_kij%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jik%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_jki%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ikj%val,1,temp2%val,1)
          else if (idx .eq. 4) then
             call dcopy(copy_size,ampl_ikj%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jki%val,1,temp2%val,1)
          else if (idx .eq. 5) then
             call dcopy(copy_size,ampl_jik%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kij%val,1,temp2%val,1)
          else if (idx .eq. 6) then
             call dcopy(copy_size,ampl_kji%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ijk%val,1,temp2%val,1)
          end if

          ! canAIBC(c,b,d,k) --> tmp_g(c,b,d) (coulumb)
          call dcopy(nv**3,int_virt%val(:,:,:,p3(idx)),1,tmp_g%val,1)
          ! reorder to obtain tmp_g(c,d,b)
          call array3_reorder(tmp_g,[1,3,2])

          ! now contract coulumb term over 2 first indices into interm_cou(_2)(a,b) array2
          ! first, reorder trip(a,c,d) --> trip(c,d,a)
          call array3_reorder(temp,[2,3,1])
          call array3_reorder(temp2,[2,3,1])
          call array3_contract2(temp,tmp_g,interm_cou)
          call array3_contract2(temp2,tmp_g,interm_cou_2)

          ! reorder tmp_g to obtain exchange term, i.e., tmp_g(c,d,b) --> tmp_g(d,c,b)
          call array3_reorder(tmp_g,[2,1,3])

          ! now contract exchange term over 2 first indices into interm_exc(a,b) array2
          call array3_contract2(temp,tmp_g,interm_exc)

          ! now collect in T_star array4 structure
          ! 1. load interm_cou and interm_exc into T_star_interm(a,b) array2 
          ! which is now an L_{bckd}-contracted quantity
          ! 2. subtract g_{dkbc} term
          T_star_interm%val = 2.0E0_realk * interm_cou%val - 1.0E0_realk * interm_exc%val
          T_star_interm%val = 1.0E0_realk * T_star_interm%val - 1.0E0_realk * interm_cou_2%val

          ! load T_star_interm into T_star array4 structure
          T_star%val(:,:,p1(idx),p2(idx)) = T_star%val(:,:,p1(idx),p2(idx)) + T_star_interm%val

       end do

       ! release temporary array2s and array3s
       call array3_free(tmp_g)
       call array3_free(temp)
       call array3_free(temp2)
       call array2_free(interm_cou)
       call array2_free(interm_cou_2)
       call array2_free(interm_exc)
       call array2_free(T_star_interm)

    end select TypeofContraction_21

  end subroutine eccsdpt_contract_21


  !> brief: do the two contractions over 'ckl' (here: 'c', 'k' and 'l' are summations in driver routine)
  !  in eq. (14.6.64) of MEST
  !> author: Janus Juul Eriksen
  !> date: August 2012
  !> param: oindex1-oindex3 are outside loop indices of driver routine.
  !> nv is nvirt and T_star is T_ast_2 of driver. ampl_xxx are (optional) amplitude arrays.
  subroutine eccsdpt_contract_22(oindex1,oindex2,oindex3,no,nv,int_occ,T_star,ampl_iik,&
       & ampl_iki,ampl_kii,ampl_ijj,ampl_jij,ampl_jji,ampl_ijk,ampl_kij,ampl_jki,ampl_ikj,&
       & ampl_jik,ampl_kji)

    implicit none
    !> input
    integer, intent(in) :: oindex1, oindex2, oindex3, no, nv
    type(array4), intent(inout) :: int_occ, T_star
    type(array3), optional, intent(inout) :: ampl_iik, ampl_iki, ampl_kii, ampl_ijj, ampl_jij, ampl_jji
    type(array3), optional, intent(inout) :: ampl_ijk, ampl_kij, ampl_jki, ampl_ikj, ampl_jik, ampl_kji
    !> temporary quantities
    integer :: contraction_type, idx, p0(5), p1(6), p2(6), p3(6)
    integer(kind=long) :: copy_size
    type(array2) :: tmp_g_1, tmp_g_2
    type(array3) :: interm_cou, interm_exc, interm_cou_2, T_star_interm
    type(array3) :: temp, temp2

    ! NOTE: incoming array4 structures are ordered according to:
    ! canAIJK(j,c,l,k) (MEST nomenclature)
    ! T_ast_2(j,a,b,i)

    ! initiate the loop index vectors, p0, p1, p2, and p3
    p0(1:5) = (/ oindex1, oindex2, oindex3, oindex1, oindex2 /)

    p1(1:6) = (/ oindex1, oindex3, oindex2, oindex1, oindex2, oindex3 /)
    p2(1:6) = (/ oindex3, oindex2, oindex1, oindex2, oindex3, oindex1 /)
    p3(1:6) = (/ oindex2, oindex1, oindex3, oindex3, oindex1, oindex2 /)

    ! define copy_size
    copy_size = nv**3

    ! determine which type of contraction is to be performed
    contraction_type = -1
    ! i == j == k
    ! this (i .eq. j .eq. k) contribution is zero!
    ! i == j > k
    if (present(ampl_iik) .and. present(ampl_iki) .and. present(ampl_kii)) contraction_type = 1
    ! i > j == k
    if (present(ampl_ijj) .and. present(ampl_jij) .and. present(ampl_jji)) contraction_type = 2
    ! i > j > k
    if (present(ampl_ijk) .and. present(ampl_kij) .and. present(ampl_jki) &
       & .and. present(ampl_ikj) .and. present(ampl_jik) .and. present(ampl_kji)) contraction_type = 3

    ! contraction time (here: over virtual index 'c') with "coulumb minus exchange"
    ! version of canAIBC (2 * canAIJK(k,j,l,c) - canAIBC(l,j,k,c)) using temp and canAIBC(k,j,l,c)
    ! using temp2

    TypeofContraction_22: select case(contraction_type)

    case(1)

       ! init temporary arrays, tmp_g_1 and tmp_g_2 array2s in addition to interm_cou, interm_exc, and
       ! interm_cou_2 array3s. also, temp, temp2, and T_star_interm array3s
       tmp_g_1 = array2_init_plain([no,nv])
       tmp_g_2 = array2_init_plain([no,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       interm_cou = array3_init_standard([no,nv,nv])
       interm_cou_2 = array3_init_standard([no,nv,nv])
       interm_exc = array3_init_standard([no,nv,nv])
       T_star_interm = array3_init_standard([no,nv,nv])

       do idx=1,3

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_iik%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kii%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_iki%val,1,temp%val,1)
             call dcopy(copy_size,ampl_iki%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_kii%val,1,temp%val,1)
             call dcopy(copy_size,ampl_iik%val,1,temp2%val,1)
          end if

          ! canAIJK(j,c,l,k) --> tmp_g_1(j,c) (coulumb)
          call dcopy(no*nv,int_occ%val(:,:,p0(idx+2),p0(idx+1)),1,tmp_g_1%val,1)
          ! canAIJK(j,c,k,l) --> tmp_g_2(j,c) (exchange)
          call dcopy(no*nv,int_occ%val(:,:,p0(idx+1),p0(idx+2)),1,tmp_g_2%val,1)

          ! now contract coulumb term over first index into interm_cou(_2)(j,a,b) array3
          ! first, reorder trip(a,b,c) --> trip(c,a,b)
          call array3_reorder(temp,[3,1,2])
          call array3_reorder(temp2,[3,1,2])
          call array3_contract1(temp,tmp_g_1,interm_cou,.true.,.false.)
          call array3_contract1(temp2,tmp_g_1,interm_cou_2,.true.,.false.)

          ! now contract exchange term over first index into interm_exc(j,a,b) array3
          call array3_contract1(temp,tmp_g_2,interm_exc,.true.,.false.)

          ! now collect in T_star array4 structure
          ! load interm_cou, interm_exc, and interm_cou_2 into T_star_interm(j,a,b) array3
          call array3_add_memory(2.0E0_realk,interm_cou,-1.0E0_realk,interm_exc,&
                               & T_star_interm,.true.,zeta=-1.0E0_realk,Z=interm_cou_2)

          ! load T_star_interm into T_star array4 structure
          T_star%val(:,:,:,p0(idx)) = T_star%val(:,:,:,p0(idx)) - T_star_interm%val

       end do

       ! release temporary array2s and array3s
       call array2_free(tmp_g_1)
       call array2_free(tmp_g_2)
       call array3_free(temp)
       call array3_free(temp2)
       call array3_free(interm_cou)
       call array3_free(interm_cou_2)
       call array3_free(interm_exc)
       call array3_free(T_star_interm)

    case(2)

       ! init temporary arrays, tmp_g_1 and tmp_g_2 array2s in addition to interm_cou, interm_exc, and
       ! interm_cou_2 array3s. also, temp, temp2, and T_star_interm array3s
       tmp_g_1 = array2_init_plain([no,nv])
       tmp_g_2 = array2_init_plain([no,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       interm_cou = array3_init_standard([no,nv,nv])
       interm_cou_2 = array3_init_standard([no,nv,nv])
       interm_exc = array3_init_standard([no,nv,nv])
       T_star_interm = array3_init_standard([no,nv,nv])

       do idx=1,3

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_ijj%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jji%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_jji%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ijj%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_jij%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jij%val,1,temp2%val,1)
          end if

          ! canAIJK(j,c,l,k) --> tmp_g_1(j,c) (coulumb)
          call dcopy(no*nv,int_occ%val(:,:,p0(idx+2),p0(idx+1)),1,tmp_g_1%val,1)
          ! canAIJK(j,c,k,l) --> tmp_g_2(j,c) (exchange)
          call dcopy(no*nv,int_occ%val(:,:,p0(idx+1),p0(idx+2)),1,tmp_g_2%val,1)

          ! now contract coulumb term over first index into interm_cou(_2)(j,a,b) array3
          ! first, reorder trip(a,b,c) --> trip(c,a,b)
          call array3_reorder(temp,[3,1,2])
          call array3_reorder(temp2,[3,1,2])
          call array3_contract1(temp,tmp_g_1,interm_cou,.true.,.false.)
          call array3_contract1(temp2,tmp_g_1,interm_cou_2,.true.,.false.)

          ! now contract exchange term over first index into interm_exc(j,a,b) array3
          call array3_contract1(temp,tmp_g_2,interm_exc,.true.,.false.)

          ! now collect in T_star array4 structure
          ! load interm_cou, interm_exc, and interm_cou_2 into T_star_interm(j,a,b) array3
          call array3_add_memory(2.0E0_realk,interm_cou,-1.0E0_realk,interm_exc,&
                               & T_star_interm,.true.,zeta=-1.0E0_realk,Z=interm_cou_2)

          ! load T_star_interm into T_star array4 structure
          T_star%val(:,:,:,p0(idx)) = T_star%val(:,:,:,p0(idx)) - T_star_interm%val

       end do

       ! release temporary array2s and array3s
       call array2_free(tmp_g_1)
       call array2_free(tmp_g_2)
       call array3_free(temp)
       call array3_free(temp2)
       call array3_free(interm_cou)
       call array3_free(interm_cou_2)
       call array3_free(interm_exc)
       call array3_free(T_star_interm)

    case(3)

       ! init temporary arrays, tmp_g_1 and tmp_g_2 array2s in addition to interm_cou, interm_exc, and
       ! interm_cou_2 array3s. also, temp, temp2, and T_star_interm array3s
       tmp_g_1 = array2_init_plain([no,nv])
       tmp_g_2 = array2_init_plain([no,nv])
       temp = array3_init_standard([nv,nv,nv])
       temp2 = array3_init_standard([nv,nv,nv])
       interm_cou = array3_init_standard([no,nv,nv])
       interm_cou_2 = array3_init_standard([no,nv,nv])
       interm_exc = array3_init_standard([no,nv,nv])
       T_star_interm = array3_init_standard([no,nv,nv])

       do idx=1,6

          if (idx .eq. 1) then
             call dcopy(copy_size,ampl_ijk%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kji%val,1,temp2%val,1)
          else if (idx .eq. 2) then
             call dcopy(copy_size,ampl_kij%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jik%val,1,temp2%val,1)
          else if (idx .eq. 3) then
             call dcopy(copy_size,ampl_jki%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ikj%val,1,temp2%val,1)
          else if (idx .eq. 4) then
             call dcopy(copy_size,ampl_ikj%val,1,temp%val,1)
             call dcopy(copy_size,ampl_jki%val,1,temp2%val,1)
          else if (idx .eq. 5) then
             call dcopy(copy_size,ampl_jik%val,1,temp%val,1)
             call dcopy(copy_size,ampl_kij%val,1,temp2%val,1)
          else if (idx .eq. 6) then
             call dcopy(copy_size,ampl_kji%val,1,temp%val,1)
             call dcopy(copy_size,ampl_ijk%val,1,temp2%val,1)
          end if

          ! canAIJK(j,c,l,k) --> tmp_g_1(j,c) (coulumb)
          call dcopy(no*nv,int_occ%val(:,:,p2(idx),p3(idx)),1,tmp_g_1%val,1)
          ! canAIJK(j,c,k,l) --> tmp_g_2(j,c) (exchange)
          call dcopy(no*nv,int_occ%val(:,:,p3(idx),p2(idx)),1,tmp_g_2%val,1)

          ! now contract coulumb term over first index into interm_cou(_2)(j,a,b) array3
          ! first, reorder trip(a,b,c) --> trip(c,a,b)
          call array3_reorder(temp,[3,1,2])
          call array3_reorder(temp2,[3,1,2])
          call array3_contract1(temp,tmp_g_1,interm_cou,.true.,.false.)
          call array3_contract1(temp2,tmp_g_1,interm_cou_2,.true.,.false.)

          ! now contract exchange term over first index into interm_exc(j,a,b) array3
          call array3_contract1(temp,tmp_g_2,interm_exc,.true.,.false.)

          ! now collect in T_star array4 structure
          ! load interm_cou, interm_exc, and interm_cou_2 into T_star_interm(j,a,b) array3
          call array3_add_memory(2.0E0_realk,interm_cou,-1.0E0_realk,interm_exc,&
                               & T_star_interm,.true.,zeta=-1.0E0_realk,Z=interm_cou_2)

          ! load T_star_interm into T_star array4 structure
          T_star%val(:,:,:,p1(idx)) = T_star%val(:,:,:,p1(idx)) - T_star_interm%val

       end do

       ! release temporary array2s and array3s
       call array2_free(tmp_g_1)
       call array2_free(tmp_g_2)
       call array3_free(temp)
       call array3_free(temp2)
       call array3_free(interm_cou)
       call array3_free(interm_cou_2)
       call array3_free(interm_exc)
       call array3_free(T_star_interm)

    end select TypeofContraction_22

  end subroutine eccsdpt_contract_22
