module loc_utils
!##########################################################
!#             LOCALIZATION UTILITIES                     #
!# Routines that are used both in orbspread localization  #
!# and charge localization.                               #
!#                                                        #
!##########################################################
use TYPEDEF,only: count_ncore
use davidson_settings
use matrix_module, only: matrix
use matrix_operations 
use matrix_operations_aux, only: matrix_exponential
!use typedef
use typedefTYPE
use Integralparameters
use memory_handling, only: mem_alloc,mem_dealloc
use IntegralInterfaceMOD, only: II_get_carmom, II_get_single_carmom
use diagonalization, only: redspaceitem
contains

function idmax(n,vec)
 implicit none
 integer :: idmax
 integer, intent(in) :: n
 real(realk), intent(in) :: vec(n)
 real(realk)         :: mxvec
 integer             :: i

 mxvec=vec(1); idmax=1
 do i=2,n
    if(vec(i).gt.mxvec) then
       mxvec=vec(i)
       idmax=i
    endif
 enddo

 return
endfunction


subroutine updatecmo(CMO,X)
implicit none
type(Matrix), intent(inout) :: CMO
type(Matrix), intent(in)    :: X

integer    ::  norb,nbas
type(Matrix) :: expX, tmp

    norb=CMO%ncol
    nbas=CMO%nrow

    call mat_init(expX,norb,norb)
 
    call matrix_exponential(X,expX,1E-12_realk)

    call mat_init(tmp,nbas,norb)

    call mat_mul(CMO,expX,'n','n',1E0_realk,0E0_realk,tmp)

    call mat_free(expX)

    call mat_assign(CMO,tmp)

    call mat_free(tmp)

end subroutine updatecmo



subroutine get_core_info(ls,core_info,natoms)
implicit none
type(lsitem)  :: ls
integer       :: natoms 
integer       :: core_info(nAtoms,2)
integer       :: number_bas(nAtoms)
integer       :: A,Acharge,ncore

ncore = 0

do A=1,natoms
   Acharge = INT(ls%setting%MOLECULE(1)%p%ATOM(A)%charge)
   if (Acharge < 3 )    ncore =  0
   if (Acharge .gt. 2)  ncore =  1
   if (Acharge .gt. 10) ncore =  5
   if (Acharge .gt. 18) ncore =  9
   if (Acharge .gt. 30) ncore =  15

   core_info(A,2) = ncore
end do

do A=1,natoms
   number_bas(A) = ls%setting%Molecule(1)%p%Atom(A)%nContOrbREG
   if (A==1) core_info(A,1)=1
   if (A>1) core_info(A,1)=core_info(A-1,1)+number_bas(A-1)
end do

end subroutine get_core_info

subroutine optimloc_mix_randomly(Cmo)
implicit none
type(Matrix) :: Cmo
type(Matrix) :: X, U, tmp
real(realk),pointer  :: Xf(:,:)
real(realk),parameter    :: eps=10e0_realk
real(realk)              :: r
integer      :: i,j,n

   !get n, num of orbs in Cmo
   n=Cmo%ncol

   !get random antisymm matrix Xf
   call mem_alloc(Xf,n,n)
   Xf = 0.0_realk
   do i=1,n
    do j=i+1,n
    call random_number(r)
    Xf(i,j)=eps*(0.1+r)
    Xf(j,i)=-Xf(i,j)
    end do
   end do

   !set Xf to matrix type 
   call mat_init(X,n,n)
   call mat_set_from_full(Xf,1.0_realk,X)

   call mem_dealloc(Xf)

   !get U=exp(X)
   call mat_init(U,n,n)
   call matrix_exponential(X,U,1e-12_realk)
   call mat_free(X)

   !mix orbitals and set the results
   call mat_init(tmp,Cmo%nrow,Cmo%ncol)
   call mat_mul(Cmo,U,'n','n',1.0_realk,0.0_realk,tmp)
   call mat_assign(Cmo,tmp)

   !free memory
   call mat_free(tmp)
   call mat_free(U)

end subroutine optimloc_mix_randomly

subroutine update_trustradius_david(CFG,r,ls,macroiter)
implicit none
type(RedSpaceItem)      :: CFG
real(realk), intent(in) :: r
type(lsitem), intent(in)   :: ls
integer,intent(in)         :: macroiter


 if (r.lt.0d0) then
    CFG%step_accepted = .false.
    return
 endif

 if(r.gt.0.75d0) then
         CFG%Stepsize = min(CFG%Stepsize*2.5d0,CFG%max_stepsize)
 end if

 if(r.gt.0.25d0 .and. r.lt.0.75d0)  write(ls%lupri,*) 'Keep stepsize', r

 if (r.gt.0.0d0 .and. r.lt.0.25d0) then
    CFG%Stepsize = CFG%Stepsize*0.7d0
 endif

 CFG%step_accepted = .true.

end subroutine update_trustradius_david

end module loc_utils
!############ END UTILITIES MODULE #######################


module orbspread_module
!##########################################################
!#              ORBSPREAD MODULE                          #
!# Routines that are specific for orbspread localization  #
!# Routines called by solver (lin.trans. and precond.)    #
!# are not included in module.                            #
!#                                                        #
!##########################################################
use loc_utils
use typedef
!use typedeftype
use loc_types
use matrix_module, only: matrix
use matrix_operations 
use matrix_operations_aux, only: matrix_exponential
!use matrix_module
!use matrix_operations
!use matrix_operations_aux
use arhDensity
use kurtosis
use davidson_settings
use driver
use LSTIMING
use ARHmodule
use trustradius_mod, only: update_trustradius
use integralInterfaceMod
!type orbspread_data
! integer :: norb
! integer :: m
! real(realk), allocatable :: spread2(:)
! type(Matrix) :: R(3)
! type(Matrix) :: Q
! type(Matrix), pointer :: G
! type(Matrix) :: propint(10)
! type(Matrix) :: tmpM(4)
!end type orbspread_data

contains

subroutine kurtosis_localize_davidson(CFG,CMO,m,ls)
implicit none
type(RedSpaceItem)           :: CFG
type(Matrix) , intent(inout ):: CMO
TYPE(lsitem) , intent(inout) :: ls
integer      , intent(in)    :: m
real(realk)                  :: tcpu,twall
type(orbspread_data) :: orbspread_input
real(realk)                  :: tcpu1,twall1
logical :: lower2
type(Matrix) :: Xsav,CMOsav
type(Matrix), target  :: Start, X, P, G,expX
integer :: norb, i, imx, ii,nbas
real(realk) :: nrmG, oVal,old_oVal, qn, r, mui, max_step,avg_kurt
real(realk) :: nrm_thresh,stepsize
real(realk) :: trial(1,1)
  
  write(CFG%lupri,'(a)') '***** KURTOSIS SETTINGS *****'
  write(CFG%lupri,'(a,i4)') ' m =        ', m
  write(CFG%lupri,'(a,l4)') ' Crossterms ', CFG%KURT%crossterms
  write(CFG%lupri,'(a)') '*****************************'
  
  
  r=0.d0
  norb=CMO%ncol
  nbas=CMO%nrow
  call mat_init(X,norb,norb)
  call mat_init(G,norb,norb)
  call mat_init(P,norb,norb)
  call mat_init(CMOsav,CMO%nrow,CMO%ncol)
  call mat_init(expX,CMO%ncol,CMO%ncol)
  call kurt_initMO(CFG%KURT,cmo)
  call kurt_value(CFG%KURT)
  call compute_gradient(CFG%KURT,G,norb)
  oVal = CFG%KURT%kurt_val

!  call diagonal_hessian(CFG%KURT,P)
  call kurtosis_precond_matrix(CFG%KURT,P)
  CFG%KURT%P => P
  CFG%P => CFG%KURT%P
  
  CFG%mu = 0.0_realk
  if (norb < 15) CFG%macro_thresh = CFG%macro_thresh*10.0d0 
  
  lower2= .true.
  stepsize=0d0
  do i=1,200
    CFG%old_mu = CFG%mu
    old_oVal = oVal
    nrmG = dsqrt(mat_sqnorm2(G))/real(norb)
    avg_kurt=maxval(CFG%KURT%omega)
    write (ls%lupri,'(X,I3,X,A,X,ES10.2,X,A,X,ES10.3,X,A,X,ES10.2,X,A,X,ES10.2,X,A,X,ES10.3,X,A,X,I3,A,f10.3,A,f10.3)') &
   &i, 'Pred=',CFG%r_denom,'avg kurt=',avg_kurt,&
   &   'r=',r,'mu=',CFG%mu,'grd=', nrmG, 'it=',CFG%it, ' step ', CFG%stepsize ,' totstep',stepsize
    
    if( nrmG.le. CFG%macro_thresh*100.0) then
       exit
    end if
   
   call solver(CFG,G,X)

   ! global and local thresholds defined in CFG settings
   if (dabs(CFG%mu)> 1.0) CFG%conv_thresh=CFG%global_conv_thresh
   if (dabs(CFG%mu)< 1.0)  CFG%conv_thresh=CFG%local_conv_thresh

   if (dabs(CFG%mu)<100.0 .and. lower2) then
      CFG%max_stepsize = 0.5d0*CFG%max_stepsize
      lower2 = .false.
   end if
   call mat_copy(1d0,cmo,cmosav)

   call linesearch_kurtosis(CFG,cmo,X,stepsize,oval) 
   
   ! COMPUTE r FOR value where factor =1d0
   r=2.0d0*(oVal-old_oVal)/CFG%r_denom
    oVal=CFG%KURT%kurt_val
    
    if ( r> 0) then 
       write(CFG%lupri,*) "Pred: step accepted"
       !CMOS are updated in linesearch
    else
       write(CFG%lupri,*) "Pred: step rejected"
       call mat_copy(1d0,cmosav,cmo)
       call kurt_updateAO(CFG%kurt,cmo)
       call kurt_value(CFG%KURT)
       CFG%stepsize = 0.5d0*CFG%stepsize
       old_oVal=CFG%KURT%kurt_val
       oVal=CFG%KURT%kurt_val
       if (CFG%stepsize < 0.001) then
           write(CFG%lupri,'(a)') 'WARNING: Too many rejections for localization. We exit..' 
	   exit
       end if
       cycle
    end if
    call update_trustradius_david(CFG,r,ls,i) 
    !new gradient
    call compute_gradient(CFG%KURT,G,norb)

    !new preconditioning matrix 
    call kurtosis_precond_matrix(CFG%KURT,P)
    !call diagonal_hessian(CFG%KURT,P)
    CFG%KURT%P => P
    CFG%P => CFG%KURT%P


  enddo


  call kurt_freeMO(CFG%KURT)
  call mat_free(X)
  call mat_free(expX)
  call mat_free(G)
  call mat_free(P)
  call mat_free(CMOsav)

end subroutine kurtosis_localize_davidson


subroutine orbspread_localize_davidson(CFG,CMO,m,orbspread_input,ls)
implicit none
type(RedSpaceItem)           :: CFG
type(Matrix) , intent(inout ):: CMO
TYPE(lsitem) , intent(inout) :: ls
integer      , intent(in)    :: m
real(realk)                  :: tcpu,twall
real(realk)                  :: tcpu1,twall1

type(orbspread_data), target :: orbspread_input
type(Matrix) :: CMOsav
type(Matrix), target  :: Start, X, P, G
integer :: norb, i, imx, ii
real(realk) :: nrmG, oVal,old_oVal, qn, r, mui, max_step
integer, external :: idamax
real(realk) :: nrm_thresh,stepsize,orig_Eval

!start guess related declarations
integer, pointer    :: kl(:,:)
real(realk),pointer :: emin(:)
integer                 :: nstart

  r=0.d0
  norb=CMO%ncol
  CFG%orbspread_input=>orbspread_input

  call mat_init(X,norb,norb)
  call mat_init(G,norb,norb)
  call mat_init(P,norb,norb)
  call mat_init(Start,norb,norb)
  call mat_init(CMOsav,CMO%nrow,CMO%ncol)


  call orbspread_init(orbspread_input,m,norb)
  call orbspread_update(orbspread_input,CMO)
  call orbspread_gradx(G,norb,orbspread_input)
  call orbspread_value(oVal,orbspread_input)

  nstart=min(5,norb) !!HERE
  call mem_alloc(kl,2,nstart)
  call mem_alloc(emin,nstart)
 



  call orbspread_precond_matrix2(orbspread_input,P,norb)
  !call orbspread_precond_matrix(P,emin,kl,nstart,CFG%mu,norb,orbspread_input)
  orbspread_input%P => P
  CFG%P => orbspread_input%P

  stepsize = CFG%stepsize
  CFG%mu = 0.0_realk
  if (norb < 10) CFG%macro_thresh = CFG%macro_thresh*10.0d0 
  stepsize=0d0
  do i=1,400
    CFG%old_mu = CFG%mu
    old_oVal = oVal
    imx  =  idamax(norb,orbspread_input%spread2,1)
    nrmG = dsqrt(mat_sqnorm2(G))/real(norb)

    write (ls%lupri,'(X,I3,X,A,X,ES9.2,X,A,X,f8.3,X,A,X,f8.3,X,A,X,ES9.2,X,A,X,ES9.2,X,A,X,I3,X,A,f6.3,A,f6.3)') &
   &i, 'Pred=',CFG%r_denom,'max_o=',dsqrt(orbspread_input%spread2(imx)),&
   &   'r=',r,'mu=',CFG%mu,'grd=', nrmG, 'it=',CFG%it, 'step',CFG%stepsize,' tot step ', stepsize
    if(nrmG .le. CFG%macro_thresh) exit

   
   call solver(CFG,G,X)

   ! global and local thresholds defined in CFG settings
   if (dabs(CFG%mu)> 1.0) CFG%conv_thresh=CFG%global_conv_thresh
   if (dabs(CFG%mu)< 1.0)  CFG%conv_thresh=CFG%local_conv_thresh

    call mat_copy(1.0_realk,CMO,CMOsav)
 
    stepsize = CFG%stepsize
    call linesearch_orbspread2(CFG,cmo,X,stepsize,old_oval,orig_Eval)
    !call linesearch_orbspread(CMO,X,orbspread_input,ls,stepsize,orig_Eval)    
    !call orbspread_update(orbspread_input,CMO)
    call orbspread_value(oVal,orbspread_input)
    
    r=2.0d0*(orig_Eval-old_oVal)/CFG%r_denom

  !    call update_trustradius_david(CFG,r,ls,i)
    if (r< 0) then
       write(ls%lupri,*) 'Step not accepted. Go back'
       call mat_copy(1.0d0,CMOsav,CMO)
       call orbspread_update(orbspread_input,CMO)
       call orbspread_value(oVal,orbspread_input)
       CFG%Stepsize = CFG%Stepsize/2.0d0
       if (CFG%stepsize < 0.001) then
           write(CFG%lupri,'(a)') 'WARNING: Too many rejections for localization. We exit..' 
	   exit
       end if
	cycle
    else
     call update_trustradius_david(CFG,r,ls,i)
    endif

   if (CFG%stepsize < 0.001) then
           write(CFG%lupri,'(a)') 'WARNING: Too many rejections for localization. We exit..' 
	   exit
   end if
    !new gradient
    call orbspread_gradx(G,norb,orbspread_input)


   call orbspread_precond_matrix2(orbspread_input,P,norb)
   ! call orbspread_precond_matrix(P,emin,kl,nstart,CFG%mu,norb,orbspread_input)
    orbspread_input%P => P
    CFG%P =>orbspread_input%P


  enddo





  call mem_dealloc(kl)
  call mem_dealloc(emin)

  call orbspread_free(orbspread_input)
  call mat_free(X)
  call mat_free(G)
  call mat_free(P)
  call mat_free(Start)
  call mat_free(CMOsav)

end subroutine orbspread_localize_davidson





function orbspread_select_gt(CMO,eps,inp)
implicit none
integer, pointer :: orbspread_select_gt(:)
Type(Matrix), intent(in) :: CMO
real(realk), intent(in)  :: eps
type(orbspread_data), intent(inout) :: inp
integer :: ncol,norb, i, j

    ncol=CMO%ncol
    call orbspread_init(inp,-1,ncol)
    call orbspread_update(inp,CMO)

    norb=0
    do i=1,ncol
     if (sqrt(inp%spread2(i)).gt.eps) norb = norb+1
    enddo

    call mem_alloc(orbspread_select_gt,norb)

    j=0
    do i=1,ncol
     if (sqrt(inp%spread2(i)).gt.eps) then
      j=j+1
      orbspread_select_gt(j) = i
     endif
    enddo

    call orbspread_free(inp)

    return
end function orbspread_select_gt

function orbspread_build_selection(selected,CMO)
implicit none
Type(Matrix), pointer :: orbspread_build_selection
integer, pointer      :: selected(:)
Type(Matrix)          :: CMO
    
integer               :: i, nrow, ncol
real(realk),pointer     :: tmp(:)

    nrow = CMO%nrow
    ncol = size(selected)
    allocate(orbspread_build_selection)
    call mem_alloc(tmp,nrow)
    call mat_init(orbspread_build_selection,nrow,ncol)

    do i=1,ncol    
       call mat_retrieve_block(CMO,tmp,nrow,1,1,selected(i))
       call mat_create_block(orbspread_build_selection,tmp,nrow,1,1,i)
    enddo

    call mem_dealloc(tmp)
 
return
end function orbspread_build_selection

subroutine orbspread_set_selection(CMO,CMOs,selected)
implicit none
Type(Matrix), intent(inout) :: CMO
Type(Matrix), intent(inout) :: CMOs
integer, pointer            :: selected(:) 

integer                     :: i, nrow, ncol
real(realk),pointer     :: tmp(:)

    nrow = CMO%nrow
    ncol = size(selected)

    call mem_alloc(tmp,nrow)

    do i=1,ncol    
       call mat_retrieve_block(CMOs,tmp,nrow,1,1,i)
       call mat_create_block(CMO,tmp,nrow,1,1,selected(i))
    enddo

    call mem_dealloc(tmp)

end subroutine orbspread_set_selection


subroutine orbspread_free(orbspread_input)
implicit none
type(orbspread_data) :: orbspread_input
integer :: i

     call mem_dealloc(orbspread_input%spread2) 
 
     call mat_free(orbspread_input%Q)

     do i=1,3
      call mat_free(orbspread_input%R(i))
     enddo

     do i=1,4
      call mat_free(orbspread_input%tmpM(i))
     enddo

end subroutine orbspread_free

subroutine orbspread_propint_free(orbspread_input)
implicit none
type(orbspread_data) :: orbspread_input
integer :: i

     do i=2,5
      call mat_free(orbspread_input%propint(i))
     enddo

end subroutine orbspread_propint_free


subroutine orbspread_propint(orbspread_input,ls)
implicit none
type(orbspread_data), intent(inout) :: orbspread_input
TYPE(lsitem), intent(inout) :: ls !ls%setting is changed in the II_something routines

integer, parameter  :: nderiv=2, nMAT=10
integer i,n

! init and compute propint property integrals
! propint(2:4) -> DIPX,DIPY,DIPZ
! propint(5)   -> SECX+SECY+SECZ 

!     n   = ls%setting%BASIS(1)%p%REGULAR%nbast
     n = getNbasis(AORdefault,Contractedinttype,ls%SETTING%MOLECULE(1)%p,ls%lupri)
     DO i=1,nMAT
        call mat_init(orbspread_input%propint(I),n,n)
     ENDDO

     IF(.FALSE.)THEN !speed optimized version
        call II_get_carmom(6,6,ls%setting,orbspread_input%propint,nMAT,nderiv,0E0_realk,0E0_realk,0E0_realk)
     ELSE !memory optimized version
        do I=1,nMat
           call II_get_single_carmom(6,6,ls%setting,orbspread_input%propint(i),i,nderiv,0E0_realk,0E0_realk,0E0_realk)
        enddo
     ENDIF
     call mat_free(orbspread_input%propint(1))
     call mat_free(orbspread_input%propint(6))
     call mat_free(orbspread_input%propint(7))
     call mat_free(orbspread_input%propint(9))

! propint(5)   -> SECX+SECY+SECZ 
     call mat_daxpy(1E0_realk,orbspread_input%propint(8),orbspread_input%propint(5))
     call mat_free(orbspread_input%propint(8))
     call mat_daxpy(1E0_realk,orbspread_input%propint(10),orbspread_input%propint(5))
     call mat_free(orbspread_input%propint(10))

end subroutine orbspread_propint



subroutine orbspread_init(orbspread_input,m,norb)
implicit none
type(orbspread_data), intent(inout) :: orbspread_input
integer             , intent(in) :: norb, m
TYPE(lsitem) :: ls
integer   :: i

! init R Q and tmpM matrices
     call mat_init(orbspread_input%Q,norb,norb)
     do i=1,3
     call mat_init(orbspread_input%R(i),norb,norb)
     enddo
     do i=1,4
     call mat_init(orbspread_input%tmpM(i),norb,norb)
     enddo

! set norb
     orbspread_input%norb =  norb

! set m power
     orbspread_input%m = m

! allocate spread2

     call mem_alloc(orbspread_input%spread2,norb)

end subroutine orbspread_init


subroutine orbspread_update(orbspread_input,CMO)
implicit none
type(orbspread_data), intent(inout) :: orbspread_input
type(Matrix), intent(in) :: CMO

type(Matrix) :: tmp
integer :: nbas,norb,i
real(realk), pointer :: tmpv(:)

     nbas=CMO%nrow
     norb=CMO%ncol

     call mat_init(tmp,nbas,norb)

!   R(1:3)
    do i=1,3
     call mat_mul(orbspread_input%propint(i+1),CMO,'n','n',1E0_realk,0E0_realk,tmp)
     call mat_mul(CMO,tmp,'t','n',1E0_realk,0E0_realk,orbspread_input%R(i))
    enddo

!   Q
     call mat_mul(orbspread_input%propint(5),CMO,'n','n',1E0_realk,0E0_realk,tmp)
     call mat_mul(CMO,tmp,'t','n',1E0_realk,0E0_realk,orbspread_input%Q)

     call mat_free(tmp)

!   spread2
    call mem_alloc(tmpv,norb)

    call mat_extract_diagonal(orbspread_input%spread2,orbspread_input%Q)

    do i=1,3
    call mat_extract_diagonal(tmpv,orbspread_input%R(i))
    tmpv=tmpv**2
    call daxpy(norb,-1E0_realk,tmpv,1,orbspread_input%spread2,1)
    enddo
   
    !write(6,*) sqrt(orbspread_input%spread2)
    call mem_dealloc(tmpv)

end subroutine orbspread_update

subroutine orbspread_value(oVal, inp)
real(realk), intent(out) :: oVal
type(orbspread_data), intent(in)  :: inp

integer  :: i

 oVal = 0E0_realk
 do i=1,inp%Q%ncol
   oVal = oVal + inp%spread2(i)**inp%m
 enddo


end subroutine orbspread_value


subroutine orbspread_localize_CROP(CMO,m,orbspread_input,ls)
implicit none
type(Matrix) , intent(inout ):: CMO
TYPE(lsitem) , intent(inout) :: ls
integer      , intent(in)    :: m

type(orbspread_data), target :: orbspread_input
type(Matrix) :: CMOsav
type(Matrix), target  :: Start, X, P, G
integer :: norb, i, imx, ii
real(realk) :: nrmG, oVal, qn, r, mui, max_step
integer, external :: idamax

!start guess related declarations
integer, pointer    :: kl(:,:)
real(realk),pointer :: emin(:)
integer                 :: nstart

!solver related declarations
type(decompItem)   :: decomp
type(solverItem)   :: arh
type(debugItem)    :: debug
TYPE(modFIFO)      :: queue

!DD_solver declarations
type(DDitem)       :: DD
type(matrix),allocatable  :: iniguess(:)

! KK fix, "r" needs to be initialized. Otherwise ifort complains...
r=0E0_realk


  norb=CMO%ncol

! solver inits
  call arh_set_default_config(arh)
  call decomp_set_default_config(decomp)
  arh%cfg_orbspread = .true.
  decomp%cfg_orbspread = .true.
  arh%orbspread_input => orbspread_input
  !arh%cfg_arh_truncate = .false.
  arh%cfg_arh_truncate = .true.
  arh%cfg_arh_microvecs = 12
  !arh%cfg_noprec = .false.
  !arh%cfg_noprec = .true.
  arh%lupri = ls%lupri
  !arh%cfg_micro_thresh=1E-1_realk
  !arh%info_levelshift = .true.
  arh%set_local = .true.
  !max_step         = 0.4E0_realk
  max_step         = 0.8E0_realk
  arh%cfg_max_step = max_step
  arh%cfg_max_element = 0.2E0_realk
  !arh%cfg_max_element = 0.4E0_realk
! end solver inits
  arh%lshift_by_hlgap = .false.


!  arh%nits_check = arh%cfg_arh_microvecs + 1
!  arh%error_decrease = 1e-2


#if 0
!For DD_solver
  decomp%lupri = ls%lupri
  DD%cfg_orbspread = .true.
  DD%orbspread_input => orbspread_input
  decomp%orbspread_input => orbspread_input
  decomp%info_stability = .true.
  decomp%cfg_check_maxit = 500
#endif

  call mat_init(X,norb,norb)
  call mat_init(G,norb,norb)
  call mat_init(P,norb,norb)
  call mat_init(Start,norb,norb)
  call mat_init(CMOsav,CMO%nrow,CMO%ncol)

  call orbspread_init(orbspread_input,m,norb)

  call orbspread_update(orbspread_input,CMO)

  call orbspread_gradx(G,norb,orbspread_input)

  call orbspread_value(oVal, orbspread_input)

  nstart=min(5,norb) !!HERE
  call mem_alloc(kl,2,nstart)
  call mem_alloc(emin,nstart)
  allocate(iniguess(nstart))

  call orbspread_precond_matrix(P,emin,kl,nstart,0E0_realk,norb,orbspread_input)
  orbspread_input%P => P
  call orbspread_precond(Start,G,0E0_realk,orbspread_input)
  !call mat_dotmul(G,P,1E0_realk,0E0_realk,Start)
  arh%starting_guess => Start; arh%starting_guess_defined = .true.

   !call dumpmat('CMO.bin',CMO%elms,CMO%nrow*CMO%ncol*8)
   !i=orbspread_input%propint(2)%nrow
   !call dumpmat('RX.bin',orbspread_input%propint(2)%elms,i*i*8)
   !call dumpmat('RY.bin',orbspread_input%propint(3)%elms,i*i*8)
   !call dumpmat('RZ.bin',orbspread_input%propint(4)%elms,i*i*8)
   !call dumpmat('Q.bin',orbspread_input%propint(5)%elms,i*i*8)
   !stop 'Dump Data'
arh%denom=1d0
arh%newton_it=1
  do i=1,200
 
    imx  =  idamax(norb,orbspread_input%spread2,1) 
    nrmG = sqrt(mat_sqnorm2(G))/real(norb)

    write (ls%lupri,'(X,I3,X,A,X,E9.2,X,A,X,F6.3,X,A,X,F5.2,X,A,X,F8.2,X,A,X,E8.2,X,A,X,I3)') &
   &i, 'Pred=',arh%denom,'max_o=',sqrt(orbspread_input%spread2(imx)),&
   &   'r=',r,'mu=',arh%current_mu,'grd=', nrmG, 'Nit=',arh%newton_it
    if((sqrt(mat_sqnorm2(G))/norb).le. 1E-6_realk) exit



#if 0
    !Call DD_solver to determine lowest Hessian eigenvalue
    do ii=1,nstart
     call mat_init(iniguess(ii),norb,norb)
    enddo
    call orbspread_set_initguess(iniguess,kl,nstart)
    call DD_solver(decomp, DD, iniguess,nstart, emin(1), queue)
    do ii=1,nstart
     call mat_free(iniguess(ii))
    enddo
#endif



    call arh_crop_solver(decomp,arh,debug,G,2,X,queue)

    call mat_scal(-1E0_realk,X) !emulates -G in solver input

    call mat_copy(1E0_realk,CMO,CMOsav)
    call updatecmo(CMO,X)

    call orbspread_update(orbspread_input,CMO)


    !update trustradius
    arh%old_energy = oVal
    call orbspread_value(oVal, orbspread_input)


    arh%denom=0.25E0_realk*arh%denom
    if (abs(oVal-arh%old_energy).lt. 1E-5_realk) arh%denom=(oVal-arh%old_energy)
    r = (oVal-arh%old_energy)/arh%denom
  
    call update_trustradius(arh, ls, i, oVal, 0)

    arh%Nrejections = min(arh%Nrejections,6) ! work around too many rejections
    arh%cfg_min_lshift = 0E0_realk
    arh%cfg_fixed_shift = .false.

    if (.not.arh%step_accepted) then
       
       !arh%cfg_fixed_shift = .true.
       !arh%cfg_fixed_shift_param = abs(arh%current_mu*3E0_realk) + 10E0_realk
       
       call mat_copy(1E0_realk,CMOsav,CMO)

       call orbspread_update(orbspread_input,CMO)

    endif

    !exit in troubles
    !if (arh%newton_it.gt. 50) exit

    !new gradient
    call orbspread_gradx(G,norb,orbspread_input)

    !new preconditioning matrix 
    call orbspread_precond_matrix(P,emin,kl,nstart,0E0_realk,norb,orbspread_input)
    orbspread_input%P => P

    !new starting guess
    call mat_copy(-1E0_realk,X,Start)
    arh%starting_guess => Start

    !
    !

  enddo


  call mem_dealloc(kl)
  call mem_dealloc(emin)
  deallocate(iniguess)

  call orbspread_free(orbspread_input)

  call mat_free(X)
  call mat_free(G)
  call mat_free(P)
  call mat_free(Start)
  call mat_free(CMOsav)
  

  
end subroutine orbspread_localize_CROP


subroutine orbspread_update_trustradius(arh,r)
type(solverItem), intent(inout)   :: arh
real(realk)     , intent(in)      :: r

real(realk)                       :: nom, denom

 !nom =   (oVal - arh%old_energy)
 !denom=  arh%denom

 !r = nom/denom 

 if (r.lt. 0E0_realk) then 
    arh%set_max_element = arh%set_max_element/2.0E0_realk
    arh%set_max_step = arh%set_max_step/2.0E0_realk
    arh%step_accepted = .false.
    write (6,*) 'Reject and contract *0.5'
    return
 endif

 if(r.gt. 0.75E0_realk) then
    arh%set_max_element = arh%set_max_element*1.2E0_realk
    arh%set_max_step = arh%set_max_step*1.2E0_realk
    write(6,*) 'Expand *1.2', r
 else if(r.gt. 0.25) then
    write(6,*) 'Keep', r
    continue
 else 
    arh%set_max_element = arh%set_max_element*0.7E0_realk
    arh%set_max_step = arh%set_max_step*0.7E0_realk
    write(6,*) 'Contract *0.7', r
 endif

 arh%step_accepted = .true.

end subroutine orbspread_update_trustradius




subroutine orbspread_gradx(G,norb,inp)
implicit none
Type(Matrix) , target, intent(inout) :: G
integer                              :: norb
type(orbspread_data), intent(inout)  :: inp

real(realk)  :: diagR(norb,3), tmp(norb)
integer      :: x, m

  m=inp%m

  do x=1, 3
  call mat_extract_diagonal(diagR(:,x),inp%R(x))
  enddo

  tmp =  (inp%spread2**(m-1))
  call mat_zero(G)
  call mat_dmul(tmp,inp%Q,'n',-2E0_realk*m,0E0_realk,G)

  do x=1,3
  tmp = diagR(:,x)*(inp%spread2**(m-1))
  call mat_dmul(tmp,inp%R(x),'n',4E0_realk*m,1E0_realk,G)
  enddo

  call mat_trans(G,inp%tmpM(1))
  call mat_daxpy(-1E0_realk,inp%tmpM(1),G)

  !call mat_scal(0.5E0_realk,G)

  inp%G => G

end subroutine  orbspread_gradx
  
subroutine orbspread_precond_matrix(Pout,emin,kl,nstart,mu,norb,inp)
implicit none
type(Matrix), intent(inout) :: Pout
integer, intent(in)         :: nstart
real(realk), intent(out)    :: emin(nstart)
integer, intent(out)        :: kl(2,nstart)
real(realk), intent(in)   :: mu
integer, intent(in)       :: norb
type(orbspread_data), intent(in) :: inp

real(realk)  :: P(norb,norb)
real(realk)  :: diagQ(norb), diagR(norb,3), spm2(norb),spm1(norb)
real(realk)  :: Qkl, Rklx, elm, tmpk, tmpl
integer      :: x,k,l,m,i

  m=inp%m


  call mat_extract_diagonal(diagQ,inp%Q)

  do x=1, 3
  call mat_extract_diagonal(diagR(:,x),inp%R(x))
  enddo

 spm1 = inp%spread2**(m-1)
 spm2 = inp%spread2**(m-2)
 
 P=0E0_realk
 if(nstart.gt. 0) emin=huge(emin(1))

 do l=1,norb
 do k=(l+1),norb
     call mat_get_elm(inp%Q,k,l,Qkl) 

     P(k,l) = 4*m*(m-1)*(spm2(k) +  spm2(l))*Qkl*Qkl

     P(k,l) = P(k,l) + 2*m*(diagQ(k)-diagQ(l))*(spm1(l) - spm1(k));

     tmpk = 0E0_realk; tmpl= 0E0_realk

     do x=1,3
     call mat_get_elm(inp%R(x),k,l,Rklx) 
     P(k,l) = P(k,l) + 4*m*spm1(k)*(diagR(k,x)*diagR(k,x)-diagR(k,x)*diagR(l,x));
     P(k,l) = P(k,l) + 4*m*spm1(l)*(diagR(l,x)*diagR(l,x)-diagR(k,x)*diagR(l,x));

      P(k,l) = P(k,l) - 8*m*(spm1(k) + spm1(l))*Rklx*Rklx
      P(k,l) = P(k,l) -16*m*(m-1)*Qkl*(spm2(k)*diagR(k,x) + spm2(l)*diagR(l,x))*Rklx

      tmpk = tmpk + diagR(k,x)*Rklx;
      tmpl = tmpl + diagR(l,x)*Rklx;

     enddo

     P(k,l) = P(k,l) + 16*m*(m-1)*(spm2(k)*tmpk*tmpk + spm2(l)*tmpl*tmpl)

   
     !find nstart lowest diagonal elements
     if (nstart.gt. 0) then 
       i=idmax(nstart,emin)
       if (P(k,l).lt.emin(i)) then
          emin(i)=P(k,l)
          kl(1,i)=k;kl(2,i)=l
       endif
     endif


     P(l,k)=P(k,l)
    
 enddo
 enddo

 !if (mu.ne. 0E0_realk) P=P-mu

 !do l=1,norb
 ! do k=1,norb
 !   P(k,l) = P(k,l) -mu
 ! enddo
 !enddo
 !endif


 !invert elements
 !do l=1,norb
 !do k=1,norb
 !   if (P(k,l).ne. 0E0_realk) P(k,l)=1E0_realk/P(k,l)
 !enddo
 !enddo

 call mat_set_from_full(P,1E0_realk,Pout)

end subroutine orbspread_precond_matrix


subroutine orbspread_precond_matrix2(inp,P,norb)
implicit none
type(orbspread_data), intent(in) :: inp
type(matrix) :: P
integer :: m,norb
real(realk) :: diagQ(norb),diagR(norb,3)
real(realk) :: spm1(norb),spm2(norb)
integer :: i,x
type(matrix) :: tmp,tmp1
real(realk),pointer :: tmpvec(:)

call mat_zero(P)
m=inp%m

call mat_extract_diagonal(diagQ,inp%Q)
do x=1,3
  call mat_extract_diagonal(diagR(:,x),inp%R(x))
end do

spm1= inp%spread2**(m-1)
if (m>1) spm2=inp%spread2**(m-2)
call mat_dger(dble(2*m),diagQ,spm1,P)

do x=1,3
  call mat_dger(-dble(4*m),spm1*diagR(:,x),diagR(:,x),P)
end do

call mat_init(tmp,P%nrow,P%ncol)
call mat_zero(tmp)
if (m>1) then
  call mat_hmul(1d0,inp%Q,inp%Q,0d0,tmp)
  call mat_dmul(spm2,tmp,'n',dble(4*m*(m-1)),1d0,P)
end if
do x=1,3
  call mat_hmul(1d0,inp%R(x),inp%R(x),0d0,tmp)
  call mat_dmul(spm1,tmp,'n',-dble(8*m),1d0,P)
  if (m>1) then
    call mat_hmul(1d0,inp%Q,inp%R(x),0d0,tmp)
    call mat_dmul(spm2*diagR(:,x),tmp,'n',-dble(16*m*(m-1)),1d0,P)
  end if
end do

call mat_zero(tmp)
if (m>1) then
   do x=1,3
     call mat_dmul(diagR(:,x),inp%R(x),'n',1d0,1d0,tmp)
   end do
   call mat_init(tmp1,P%nrow,P%ncol)
   call mat_dmul(spm2,tmp,'n',dble(16*m*(m-1)),0d0,tmp1)
   call mat_hmul(1d0,tmp,tmp1,1d0,P)
   call mat_free(tmp1)
end if

call mem_alloc(tmpvec,norb)
tmpvec=1.0d0
call mat_dger(-dble(2*m),diagQ*spm1,tmpvec,P)

do x=1,3
   call mat_dger(dble(4*m),spm1*diagR(:,x)*diagR(:,x),tmpvec,P)
end do
call mem_dealloc(tmpvec)

call mat_trans(P,tmp)
call mat_daxpy(1d0,tmp,P)
call mat_free(tmp)
call mat_scal_dia(0d0,P)

end subroutine orbspread_precond_matrix2


subroutine orbspread_set_initguess(X,kl,nstart)
implicit none
integer     , intent(in)    :: nstart
type(Matrix), intent(inout) :: X(nstart)
integer     , intent(in)    :: kl(2,nstart)
integer                     :: i
 
 do i=1,nstart
 call mat_zero(X(i))
 call mat_create_elm(kl(1,i),kl(2,i), 1E0_realk,X(i))
 call mat_create_elm(kl(2,i),kl(1,i),-1E0_realk,X(i))
 enddo

end subroutine orbspread_set_initguess

subroutine linesearch_kurtosis(CFG,cmo,X,stepsize,oval)
implicit none
type(RedSpaceItem) :: CFG
type(matrix)  :: cmo,X
integer :: i,numb,nmats
type(matrix)  :: cmotemp(15),Xtemp(15)
real(realk) :: old_funcval,factor,step(15),stepsize,oval

numb=15
factor = 1.0d0
step = 1.0d0
step(1)=0.0d0
step(11)=1.50
step(12)=1.50
step(13)=1.50
step(14)=1.50
step(15)=1.50
    old_funcval = CFG%KURT%kurt_val
    write(CFG%lupri,'(a,I4,a,ES13.3)') 'Linesearch number :', 0, ' Original function value: ', CFG%KURT%kurt_val
do i=1,numb
    call mat_init(Xtemp(i),X%nrow,X%ncol)
    call mat_copy(1.0d0,X,Xtemp(i))
    call mat_init(cmotemp(i),cmo%nrow,cmo%ncol)
    call mat_copy(1.0d0,cmo,cmotemp(i))
    factor = factor + step(i)
    call mat_scal(factor,Xtemp(i))
    call updatecmo(CMOtemp(i),Xtemp(i))      
    call kurt_updateAO(CFG%kurt,CMOtemp(i))
    call kurt_value(CFG%KURT)
    write(CFG%lupri,'(a,I4,a,ES13.3)') 'Linesearch number :', i, ' Change ', CFG%KURT%kurt_val-old_funcval
    if (i==1) oVal= CFG%KURT%kurt_val
    if ((CFG%KURT%kurt_val > old_funcVal) .and. i>1) then
           cmo = cmotemp(i-1)  
	   stepsize = dsqrt(mat_dotproduct(xtemp(i-1),xtemp(i-1)))
	   nmats=i
           exit
    end if
    if (i==numb .or. dabs(CFG%KURT%kurt_val-old_funcval)<1d0) then
      cmo = cmotemp(i)
      stepsize = dsqrt(mat_dotproduct(xtemp(i),xtemp(i)))
      nmats=i
      exit
    end if
    old_funcval=CFG%KURT%kurt_val
end do

call kurt_updateAO(CFG%KURT,CMO)
call kurt_value(CFG%KURT)
do i=1,nmats
  call  mat_free(CMOtemp(i))
  call  mat_free(Xtemp(i))
end do
end subroutine linesearch_kurtosis


subroutine linesearch_orbspread(CMO,X,inp,ls,stepsize,orig_Eval)
implicit none
type(matrix) :: CMO,X
type(lsitem) :: ls
type(orbspread_data) :: inp
integer,parameter :: numb=10
real(realk) :: step(numb)
real(realk) :: stepsize,orig_Eval
type(matrix) :: Xtemp(numb)
type(matrix) :: CMOtemp(numb)
real(realk) :: factor(numb)
real(realk) :: FuncValue(numb)
integer :: i,j,indx(1)
real(realk) :: min_funcval

factor(1) = 1.0d0;factor(2)=3.0d0
factor(3) =5.0d0

do i=1,numb
    call mat_init(CMOtemp(i),CMO%nrow,CMO%ncol)
    call mat_init(Xtemp(i),X%nrow,X%ncol)
end do

do j=1,4
   do i=1,3
       call mat_copy(1.0d0,CMO,CMOtemp(i))
       call mat_copy(1.0d0,X,Xtemp(i))
       call mat_scal(factor(i),Xtemp(i))
       call updatecmo(CMOtemp(i),Xtemp(i))
       call orbspread_update(inp,CMOtemp(i))
       call orbspread_value(FuncValue(i),inp)
   end do

   min_funcval  = Minval(FuncValue(1:3))
   indx         = minloc(FuncValue(1:3))
   FuncValue(5) = FuncValue(indx(1))
   factor(5)    = factor(indx(1))
   CMOtemp(5)   = CMOtemp(indx(1))
   Xtemp(5)     = Xtemp(indx(1))


   if (j==1) then
       factor(1)=factor(5)
       factor(2)=factor(5)+1.0d0
       factor(3)=factor(5)+2.0d0
       orig_Eval=FuncValue(1)
   elseif ((indx(1) < 3 .and. j>1) .or. j==5) then
      exit
   elseif (j.ne.1) then
      factor(1) = factor(1)+3.0d0;factor(2)=factor(2)+3.0d0
      factor(3) = factor(3)+3.0d0
   end if
end do


do i=1,numb
   if (i==5) cycle
   call mat_zero(CMOtemp(i));call mat_zero(Xtemp(i))
   call mat_copy(1.0d0,CMO,CMOtemp(i));call mat_copy(1.0d0,X,Xtemp(i))
   call mat_scal(factor(i),Xtemp(i))
   call updatecmo(CMOtemp(i),Xtemp(i))
   call orbspread_update(inp,CMOtemp(i))
   call orbspread_value(FuncValue(i),inp)
end do


min_funcval  = Minval(FuncValue)
indx         = minloc(FuncValue)
call mat_copy(1.0d0,CMOtemp(indx(1)),CMO)
call mat_copy(1.0d0,Xtemp(indx(1)),X)
stepsize = dsqrt(mat_sqnorm2(X))

do i=1,numb
   call mat_free(CMOtemp(i))
   call mat_free(Xtemp(i))
end do
end subroutine linesearch_orbspread

subroutine linesearch_orbspread2(CFG,cmo,X,stepsize,value_last_macro,orig_eival)
implicit none
type(RedSpaceItem) :: CFG
type(matrix)  :: cmo,X
real(realk),intent(in) :: value_last_macro
integer :: i,numb=15,nmats
type(matrix)  :: cmotemp(15),Xtemp(15)
real(realk) :: old_funcval,factor,step(15),stepsize,oval
real(realk) :: orig_eival

old_funcval = value_last_macro

factor = 1.0d0
step = 1.0d0
step(1)=0.0d0
step(11)=1.50
step(12)=1.50
step(13)=1.50
step(14)=1.50
step(15)=1.50
write(CFG%lupri,'(a,I4,a,f15.1)') 'Linesearch number :', 0, ' Original function value: ', old_funcval
do i=1,numb
    call mat_init(Xtemp(i),X%nrow,X%ncol)
    call mat_copy(1.0d0,X,Xtemp(i))
    call mat_init(cmotemp(i),cmo%nrow,cmo%ncol)
    call mat_copy(1.0d0,cmo,cmotemp(i))
    factor = factor + step(i)
    call mat_scal(factor,Xtemp(i))
    call updatecmo(CMOtemp(i),Xtemp(i))
    call orbspread_update(CFG%orbspread_input,CMOtemp(i))
    call orbspread_value(oVal,CFG%orbspread_input)
    if (i==1) orig_eival = oval
    write(CFG%lupri,'(a,I4,a,f15.4)') 'Linesearch number :', i, ' Change ', oVal-old_funcval
    if (i==1 .and. oVal > old_funcVal) then
       nmats=i
       exit
    endif
    if (oVal > old_funcVal) then
           call mat_copy(1d0,cmotemp(i-1),cmo)
           stepsize = dsqrt(mat_dotproduct(xtemp(i-1),xtemp(i-1)))
	   nmats=i
           exit
    end if
    if (i==numb .or. dabs(oVal-old_funcval)< 1.0) then
      call mat_copy(1d0,cmotemp(i),cmo)
      stepsize = dsqrt(mat_dotproduct(xtemp(i),xtemp(i)))
      nmats=i
      exit
    end if
    old_funcval=oVal
end do


call orbspread_update(CFG%orbspread_input,CMO)
call orbspread_value(oVal,CFG%orbspread_input)

do i=1,nmats
  call  mat_free(CMOtemp(i))
  call  mat_free(Xtemp(i))
end do
end subroutine linesearch_orbspread2







end module orbspread_module
!########### END OF ORBSPREAD MODULE ############



module charge_module
use precision
use loc_utils
use Pipek
use matrix_module
use matrix_operations
use davidson_settings
use orbspread_module
use memory_handling
use TYPEDEF
use TYPEDEFTYPE
use driver
use LSTIMING
use loc_types
!use linesearch
!##########################################################
!#              CHARGE MODULE                             #
!# Routines that are specific for charge localization.    #
!# Routines called by solver (lin.trans. and precond.)    #
!# are not included in module.                            #
!#                                                        #
!##########################################################
contains

!> Takes in overlap S, reshuffle to core/rest blocks
!> separately localizes core/rest blocks (top power -1/2)
!> merges blocks to give optimized S^{-1/2}
subroutine localize_lowdin_orb(ls,S,Sminussqrt,natoms)
implicit none
type(RedSpaceItem) :: CFG
type(lsitem)       :: ls
type(matrix)       ::Sminussqrt,Sc,Sr
integer            :: nbas,ncore,nrest,natoms
integer            :: core_info(natoms,2)!,count_ncore
type(matrix),intent(in) :: S
real(realk),pointer :: Smat(:,:),Smat_core(:,:),Smat_rest(:,:)
real(realk),pointer :: Smat_minussqrt(:,:),Smat_sqrt(:,:)
type(orbspread_data),target :: inp
integer :: TrackVec(S%nrow),k,i
real(realk),pointer :: blockS(:,:),ID(:,:)

write(ls%lupri,*) 'LOCALIZING LOWDIN ORBITALS' 

natoms=ls%setting%MOLECULE(1)%p%nAtoms
nbas  = S%nrow
ncore = count_ncore(ls)
nrest = nbas-ncore

call davidson_settings_default(CFG)
CFG%orbspread    = .true.
CFG%macro_thresh = 1E-2_realk
CFG%linesearch   =.true.
CFG%lupri        = ls%lupri
CFG%global_conv_thresh = 0.1_realk
CFG%local_conv_thresh  = 0.01_realk


call mem_alloc(Smat,nbas,nbas)
call mem_alloc(Smat_sqrt,nbas,nbas)
call mem_alloc(Smat_minussqrt,nbas,nbas)
!allocate(Smat_core(nbas,ncore),Smat_rest(nbas,nrest))
!
call mat_to_full(S,1.0_realk,Smat)
call lowdin_diag(nbas,Smat,Smat_sqrt,Smat_minussqrt,6)
!
call mat_set_from_full(Smat_minussqrt,1.0_realk,Sminussqrt)

call mem_dealloc(Smat)
call mem_dealloc(Smat_sqrt)
call mem_dealloc(Smat_minussqrt)
!deallocate(Smat_core,Smat_rest)
!********* IDA HACK *******
!call charge_localize_davidson(CFG,Sminussqrt,2,ls)

!STOP 'LOCALIZED LOWDIN ORBS'
!********* END IDA HACK ****
!call get_core_info(ls,core_info,natoms)
!
!call shuffle_S(Sminussqrt,core_info,TrackVec,natoms)
!
!!Smat_core(:,:) = Smat_minussqrt(:,1:ncore)  
!!Smat_rest(:,1:nrest) = Smat_minussqrt(:,ncore+1:nbas)  
!
!call mat_retrieve_block(Sminussqrt,Smat_core,nbas,ncore,1,1)
!call mat_retrieve_block(Sminussqrt,Smat_rest,nbas,nrest,1,ncore+1)
!
!call mat_init(Sc,nbas,ncore)
!call mat_init(Sr,nbas,nrest)
!
!call mat_set_from_full(Smat_core,1.0_realk,Sc)
!call mat_set_from_full(Smat_rest,1.0_realk,Sr)
!!NOTE: Sc and Sr are really (S^{-1/2})_c and (S^{-1/2})_r
!
!call orbspread_propint(inp,ls)
!call shuffle_orbspread_data(inp,TrackVec,natoms)
!call orbspread_localize_davidson(CFG,Sc,1,inp,ls)
!call orbspread_propint_free(inp)
!
!call orbspread_propint(inp,ls)
!call shuffle_orbspread_data(inp,TrackVec,natoms)
!call orbspread_localize_davidson(CFG,Sr,2,inp,ls)
!call orbspread_propint_free(inp)
!
!!merge core/rest into collective S
!call mat_to_full(Sc,1.0_realk,Smat_core) 
!call mat_to_full(Sr,1.0_realk,Smat_rest) 
!
!call mat_zero(Sminussqrt)
!call mat_create_block(Sminussqrt,Smat_core,nbas,ncore,1,1)
!call mat_create_block(Sminussqrt,Smat_rest,nbas,nrest,1,ncore+1)
!call reshuffle_S(Sminussqrt,TrackVec)
!
!!> Now: Sminussqrt will give the optimized lowdin orbitals
!deallocate(Smat,Smat_sqrt,Smat_minussqrt,Smat_core,Smat_rest)

!IDA HACK
call orbspread_propint(inp,ls)
call orbspread_localize_davidson(CFG,Sminussqrt,2,inp,ls)
!call orbspread_localize_CROP(Sminussqrt,2,inp,ls)
call orbspread_propint_free(inp)



end subroutine localize_lowdin_orb

subroutine shuffle_orbspread_data(inp,TrackVec,M)
implicit none
type(orbspread_data) :: inp
integer              :: M
integer,intent(in)   :: TrackVec(M)
real(realk),pointer :: temp(:,:)
integer :: row,col,j,i,indx


do j=2,5  !only matrices 2-5
   row = inp%propint(j)%nrow !should be nbas
   col = inp%propint(j)%ncol !should be nbas
   call mem_alloc(temp,row,col)
  
   call mat_to_full(inp%propint(j),1.0_realk,temp)
   call mat_zero(inp%propint(j))
   
   do i=1,row
       indx = TrackVec(i)
       call mat_create_block(inp%propint(j),temp(:,i),row,1,1,indx) 
   end do

   call mat_to_full(inp%propint(j),1.0_realk,temp)
   call mat_zero(inp%propint(j))

   do i=1,col
       indx = TrackVec(i)
       call mat_create_block(inp%propint(j),temp(i,:),1,col,indx,1) 
   end do
   call mem_dealloc(temp)
end do

end subroutine shuffle_orbspread_data


subroutine shuffle_S(S,core_info,TrackVec,natoms)
implicit none
type(matrix) :: S,Stemp
integer      :: natoms
integer      :: core_info(natoms,2)
logical      :: core
integer      :: nbas,corecount,restcount,i
integer      :: ncore
real(realk),pointer  :: tmpblock(:,:)
integer      :: TrackVec(S%nrow)

nbas= S%nrow

ncore = sum(core_info(:,2))

call mat_init(Stemp,nbas,nbas)
call mem_alloc(tmpblock,nbas,1)
! Reshuffle columns
corecount=1
restcount=ncore+1
do i=1,nbas
      call mat_retrieve_block(S,tmpblock,nbas,1,1,i)
      call is_block_core(i,core_info,core,natoms)
      if (core) then
          call mat_create_block(Stemp,tmpblock,nbas,1,1,corecount)
          TrackVec(i)=corecount
          corecount=corecount+1
      else
          call mat_create_block(Stemp,tmpblock,nbas,1,1,restcount)
          TrackVec(i)=restcount
          restcount=restcount+1
      endif
end do 
call mem_dealloc(tmpblock)
call mem_alloc(tmpblock,1,nbas)
!Reshuffle rows
corecount=1
restcount=ncore+1
do i=1,nbas
      call mat_retrieve_block(Stemp,tmpblock,1,nbas,i,1)
      call is_block_core(i,core_info,core,natoms)
      if (core) then
          call mat_create_block(S,tmpblock,1,nbas,corecount,1)
          corecount=corecount+1
      else
          call mat_create_block(S,tmpblock,1,nbas,restcount,1)
          restcount=restcount+1
      endif
end do 
call mem_dealloc(tmpblock)
call mat_free(Stemp)

end subroutine shuffle_S

subroutine reshuffle_S(S,TrackVec)
implicit none
type(matrix) :: S,Stemp
integer :: TrackVec(S%nrow)
integer :: nbas,i,indx
real(realk) :: blocktmp(1,S%nrow)

call mat_init(Stemp,S%nrow,S%ncol)
call mat_copy(1.0_realk,S,Stemp)
call mat_zero(S)
nbas=S%nrow
do i=1,nbas
   indx = TrackVec(i)
   call mat_retrieve_block(Stemp,blocktmp,1,nbas,indx,1)
   call mat_create_block(S,blocktmp,1,nbas,i,1)
end do

call mat_free(Stemp)

end subroutine

subroutine is_block_core(i,core_info,core,natoms)
implicit none
integer,intent(in) :: i,natoms
integer,intent(in) :: core_info(natoms,2)
logical :: core
integer :: A,k
integer :: startcore,stopcore

core = .false.
do A=1,natoms
   if (core_info(A,2)==0) cycle
   startcore = core_info(A,1)
   stopcore  = core_info(A,1) + core_info(A,2) - 1
   do k=startcore,stopcore
      if (k  == i) then
         core =.true.
         exit
      end if
   end do
end do

end subroutine is_block_core

subroutine get_correct_S(CFG,ls,nbas)
implicit none
type(lsitem) :: ls
type(matrix) :: S,Sminussqrt,Stemp
integer      :: nbas,natoms
type(redspaceitem) :: CFG
real(realk),dimension(nbas,nbas) :: Smat,Smat_minussqrt,Smat_sqrt

natoms = ls%setting%MOLECULE(1)%p%nAtoms

call mat_init(S,nbas,nbas)
call mat_init(Sminussqrt,nbas,nbas)
call II_get_overlap(6,6,ls%setting,S)
call mat_to_full(S,1.0_realk,Smat)
call lowdin_diag(nbas,Smat,Smat_sqrt,Smat_minussqrt,6)


if (CFG%OrbLoc%opt_lowdin) then
    call mat_init(Stemp,S%nrow,S%ncol)
    call mat_copy(1.0_realk,S,Stemp)
    call localize_lowdin_orb(ls,Stemp,Sminussqrt,nAtoms)
    call mat_free(Stemp)
    call mat_mul(S,Sminussqrt,'n','n',1.0_realk,0.0_realk,CFG%OrbLoc%SU)
else
    if (CFG%OrbLoc%ChargeLocMulliken) then
         CFG%OrbLoc%SU=S
    elseif(CFG%OrbLoc%ChargeLocLowdin) then
         call mat_set_from_full(Smat_sqrt,1d0,CFG%OrbLoc%SU)
    elseif (CFG%OrbLoc%PipekMezeyLowdin) then
         call mat_set_from_full(Smat_sqrt,1.0_realk,CFG%OrbLoc%SU)
    elseif (CFG%OrbLoc%PipekMezeyMull) then
         call mat_copy(1d0,S,CFG%OrbLoc%SU)
    end if    
end if

call mat_free(S)
call mat_free(Sminussqrt)
end subroutine get_correct_S



subroutine charge_localize_davidson(CFG,CMO,m,ls)
implicit none
type(RedSpaceItem)           :: CFG
type(Matrix) , target        :: CMO
TYPE(lsitem) , intent(in)    :: ls
integer      , intent(in)    :: m
real(realk)                  :: tcpu,twall
real(realk)                  :: tcpu1,twall1
type(Matrix) :: CMOsav
type(Matrix), target  ::  X, P, G
type(matrix) :: XT,zero
integer :: norb, i, imx, ii,A,j
real(realk) :: nrmG, oVal,old_oVal, qn, r, mui, max_step
real(realk) :: fVal,old_fVal !function values
real(realk) :: stepsize
integer, external :: idamax
real(realk) :: max_loc,orig_Eval
integer :: nel
real(realk) :: minel
integer :: minel_pos(2)

!**** PRINT INFO ****
write(ls%lupri,*)
write(ls%lupri,'(a)')    '====================================='
write(ls%lupri,'(a,l3)') 'INFO Pipek-Mezey, Lowdin   :', CFG%OrbLoc%PipekMezeyLowdin
write(ls%lupri,'(a,l3)') 'INFO Pipek-Mezey, Mulliken :', CFG%OrbLoc%PipekMezeyMull
write(ls%lupri,'(a,l3)') 'INFO Charge loc., Lowdin   :', CFG%OrbLoc%ChargeLocLowdin
write(ls%lupri,'(a,l3)') 'INFO Charge loc., Mulliken :', CFG%OrbLoc%ChargeLocMulliken
write(ls%lupri,'(a,i3)') 'INFO Power, m              :', m
write(ls%lupri,'(a)')    '====================================='
write(ls%lupri,*)
!end print info

  CFG%OrbLoc%cmo=>CMO
  r=0.d0
  norb=CMO%ncol
  call mat_init(X,norb,norb)
  call mat_zero(X)
  call mat_init(G,norb,norb)
  call mat_init(P,norb,norb)
  call mat_init(CMOsav,CMO%nrow,CMO%ncol)
  call initialize_OrbLoc(CMO,CFG%OrbLoc,ls,dble(m))
  call update_OrbLoc(CFG%Orbloc,CMO,ls)
  call Gradient_ChargeLoc(G,CFG%OrbLoc)
  call Precond_ChargeLoc(P,CFG%OrbLoc)
  CFG%OrbLoc%P => P
  CFG%P=>CFG%OrbLoc%P
  
  fVal=CFG%OrbLoc%funcVal
  CFG%mu = 0.0_realk
  stepsize = CFG%stepsize
  if (norb < 10) CFG%macro_thresh=CFG%macro_thresh*10.0d0

  do i=1,100
    CFG%old_mu = CFG%mu
    old_fVal = fVal
    nrmG = dsqrt(mat_sqnorm2(G))/real(norb)
    max_loc = fVal/real(norb)

  write (ls%lupri,'(X,I3,X,A,X,ES10.3,X,A,X,ES10.2,f5.2,X,A,X,f6.2,X,A,X,ES10.2,X,A,X,ES10.2,X,A,X,I3,A,f8.3)') &
 &i, 'Pred=',CFG%r_denom,'max_loc=',max_loc, CFG%OrbLoc%loc_degree,&
 &   'r=',r,'mu=',CFG%mu,'grd=', nrmG, 'Nit=',CFG%it, ' step ', stepsize


   if( nrmG .le. CFG%macro_thresh) exit
   
   call solver(CFG,G,X)
   if (CFG%OrbLoc%PipekMezeyMull) call mat_scal(-1d0,X)
   if (CFG%OrbLoc%PipekMezeyLowdin) call mat_scal(-1d0,X)
   if (CFG%OrbLoc%ChargeLocMulliken) call mat_scal(-1d0,X)

   !Dynamic convergence thresh
   if (dabs(CFG%mu)> 1.0) CFG%conv_thresh=CFG%global_conv_thresh
   if (dabs(CFG%mu)< 1.0)  CFG%conv_thresh=CFG%local_conv_thresh


   call mat_copy(1d0,CMO,CMOsav)

   call linesearch_charge(CFG%OrbLoc,cmo,X,stepsize,orig_eval,ls)
   nullify(CFG%OrbLoc%CMO)
   CFG%OrbLoc%CMO=>CMO
  ! Compute r
  !call updatecmo(CMO,X)
  call update_OrbLoc(CFG%OrbLoc,CMO,ls)
  write(ls%lupri,*) 'CHECK: Qii =', sum(CFG%OrbLoc%Q(:,:))
  fval = CFG%OrbLoc%funcVal
  ! Magic factor of 2.0d0
   !r=2.0d0*(orig_Eval-old_fVal)/CFG%r_denom
  r=2.0d0*(orig_eval-old_fVal)/CFG%r_denom

  ! call update_trustradius_david(CFG,r,ls,i) !change name
  if (r<0) then
       write(ls%lupri,*) 'Step not accepted. Go back'
       call mat_copy(1.0d0,CMOsav,CMO)
       call update_OrbLoc(CFG%OrbLoc,CMO,ls)
       fval = CFG%OrbLoc%funcVal
       CFG%stepsize = CFG%stepsize/2.0
   else
       CFG%stepsize = min(CFG%stepsize*1.2,CFG%max_stepsize)
   endif

   if (CFG%stepsize < 0.001) then
         write(CFG%lupri,'(a)') 'WARNING: Too many rejections for localization. We exit..' 
	 exit
    end if

    !new gradient
    call Gradient_ChargeLoc(G,CFG%OrbLoc)
    call Precond_ChargeLoc(P,CFG%OrbLoc)
    CFG%OrbLoc%P => P
    CFG%P=>CFG%OrbLoc%P

  !END OF LOCALIZATION LOOP
  enddo

  call FreeOrbLoc(CFG%OrbLoc)
  call mat_free(X)
  call mat_free(G)
  call mat_free(P)
  call mat_free(CMOsav)
end subroutine charge_localize_davidson


subroutine linesearch_charge(OrbLoc,cmo,X,stepsize,orig_eival,ls)
implicit none
type(OrbitalLoc) :: OrbLoc
type(lsitem) :: ls
type(matrix)  :: cmo,X
integer :: i,nmats,numb
type(matrix),target  :: cmotemp(15)
type(matrix) :: Xtemp(15)
real(realk) :: old_funcval,factor,step(15),stepsize,oval
real(realk) :: orig_eival

numb=15
old_funcval = OrbLoc%funcval

factor = 1.0d0
step = 1.0d0
step(1)=0.0d0
step(11)=1.50
step(12)=1.50
step(13)=1.50
step(14)=1.50
step(15)=1.50
write(ls%lupri,'(a,I4,a,f15.1)') 'Linesearch number :', 0, ' Original function value: ', old_funcval
do i=1,numb
    call mat_init(Xtemp(i),X%nrow,X%ncol)
    call mat_copy(1.0d0,X,Xtemp(i))
    call mat_init(cmotemp(i),cmo%nrow,cmo%ncol)
    call mat_copy(1.0d0,cmo,cmotemp(i))
    factor = factor + step(i)
    call mat_scal(factor,Xtemp(i))
    call updatecmo(CMOtemp(i),Xtemp(i))
    nullify(OrbLoc%cmo)
    OrbLoc%cmo=>CMOtemp(i)
    call update_OrbLoc(OrbLoc,CMOtemp(i),ls)
    oVal = OrbLoc%funcVal
    if (i==1) orig_eival = oval
    write(ls%lupri,'(a,I4,a,f15.4)') 'Linesearch number :', i, ' Change ', oVal-old_funcval
    if (i==1 .and. oVal > old_funcVal) then
       nmats=i
       stepsize = sqrt(mat_sqnorm2(Xtemp(i)))
       exit
    endif
    if (oVal > old_funcVal) then
           call mat_copy(1d0,cmotemp(i-1),cmo)
           stepsize = sqrt(mat_sqnorm2(Xtemp(i-1)))
	   nmats=i
           exit
    end if
    if (i==numb ) then
      stepsize = sqrt(mat_sqnorm2(Xtemp(i)))
      call mat_copy(1d0,cmotemp(i),cmo)
      nmats=i
      exit
    end if
    old_funcval=oVal
end do


do i=1,nmats
  call  mat_free(CMOtemp(i))
  call  mat_free(Xtemp(i))
end do

end subroutine linesearch_charge





subroutine LinesearchCharge(CMO,X,Orbloc,ls,stepsize,orig_Eval)
implicit none
type(matrix) :: CMO,X
type(lsitem) :: ls
type(OrbitalLoc)  :: OrbLoc
integer,parameter :: numb=10
real(realk)  step(numb)
real(realk) :: stepsize
type(matrix) :: Xtemp(numb)
type(matrix) :: CMOtemp(numb)
real(realk) :: factor(numb)
real(realk) :: FuncValue(numb)
integer :: i,indx(1),j
real(realk) :: min_funcval,orig_Eval

factor(1) = 1.0d0;factor(2)=2.0d0
factor(3) =3.0d0


do i=1,10
    call mat_init(CMOtemp(i),CMO%nrow,CMO%ncol)
    call mat_init(Xtemp(i),X%nrow,X%ncol)
end do

do j=1,3 
   do i=1,3 
       call mat_copy(1.0d0,CMO,CMOtemp(i))
       call mat_copy(-1.0d0,X,Xtemp(i))
       call mat_scal(factor(i),Xtemp(i))
       call updatecmo(CMOtemp(i),Xtemp(i))
       call update_Orbloc(OrbLoc,CMOtemp(i),ls)
       FuncValue(i)=Orbloc%funcval
   end do
   
   min_funcval  = Minval(FuncValue(1:3))
   indx         = minloc(FuncValue(1:3))
   FuncValue(5) = FuncValue(indx(1))
   factor(5)    = factor(indx(1)) 
   CMOtemp(5)   = CMOtemp(indx(1))
   Xtemp(5)     = Xtemp(indx(1))
   
   if (j==1) then
       orig_Eval = FuncValue(1)
   end if
   if ((indx(1) < 3) .or. j==3) then
      exit
   else
      factor(1) = factor(1)+3.0d0;factor(2)=factor(2)+3.0d0
      factor(3) = factor(3)+3.0d0
   end if
end do
do i=1,numb
   if (i==5) cycle
   call mat_zero(CMOtemp(i));call mat_zero(Xtemp(i))
   call mat_copy(1.0d0,CMO,CMOtemp(i));call mat_copy(-1.0d0,X,Xtemp(i))
   call mat_scal(factor(i),Xtemp(i))
   call updatecmo(CMOtemp(i),Xtemp(i))
   call update_Orbloc(OrbLoc,CMOtemp(i),ls)
   FuncValue(i)=Orbloc%funcval
end do


min_funcval = Minval(FuncValue)
indx        = minloc(FuncValue)
call mat_copy(1.0d0,CMOtemp(indx(1)),CMO)
call mat_copy(-1.0d0,Xtemp(indx(1)),X)
print*, "Minimum function value found for factor:", factor(indx(1))
stepsize=dsqrt(mat_sqnorm2(X))

do i=1,numb
   call mat_free(CMOtemp(i))
   call mat_free(Xtemp(i))
end do
end subroutine LinesearchCharge



end module charge_module
!########### END OF CHARGE MODULE ############



!##########################################################
!#            GENERAL INTERFACE ROUTINES                  #
!# Below are routine that are kept outside modules.       #
!# They are interface routines to solvers (precond/       #
!# linear trans.) and lsdalton main program (optimloc).   #
!#                                                        #
!##########################################################


subroutine LocalityMeasure(CFG,ls,cmo,ncore,nval,nvirt)
use precision
use Pipek
use orbspread_module
use charge_module
use davidson_settings
use matrix_util
use loc_utils
use typedeftype
use matrix_module, only: matrix
use matrix_operations 
use matrix_operations_aux, only: matrix_exponential
!use matrix_module
!use matrix_operations
!use matrix_operations_aux
use memory_handling
implicit none
type(RedSpaceItem) :: CFG
type(orbspread_data)  :: orbspread_input
type(lsitem) :: ls
type(matrix) :: cmo,CMOblock
integer :: i,ncore,nval,nvirt,nbas 
real(realk), pointer :: kurtvec(:),tmp(:)

nbas = cmo%nrow

  ! *** COMPUTE FOURTH MOMENT FOR ORBITALS ***
  CFG%KURT%crossterms=.true.
  CFG%KURT%m=1
  call kurt_initAO(CFG%KURT,ls,cmo%nrow)
  call orbspread_propint(orbspread_input,ls)
if (ncore > 0) then
!######### CORE #############
  CFG%KURT%norb=ncore
  !get core block
  call mat_init(CMOblock,nbas,ncore)
  call mem_alloc(tmp,nbas*ncore)
  call mat_retrieve_block(CMO,tmp,nbas,ncore,1,1)
  call mat_set_from_full(tmp,1d0,CMOblock)
  call mem_dealloc(tmp)
  call kurt_initMO(CFG%KURT,CMOblock)
  call orbspread_init(orbspread_input,1,ncore)
  call orbspread_update(orbspread_input,CMOblock)
  write(ls%lupri,'(a)') '**** CORE LOCALITY  ****'
  do i=1,ncore
     write(ls%lupri, '(a,i5,f15.3,f15.3)') 'FINAL: orbspread, fourth orbspread :'&
     &, i,dsqrt(orbspread_input%spread2(i))
  end do
  write(CFG%lupri,*)
  write(CFG%lupri,'(a)') 'Maximum **************** CORE **********************'
  write(CFG%lupri,'(a,f7.3,i5)') 'Maximum orbspread and orb.number    : ',&
  &dsqrt(maxval(orbspread_input%spread2))&
  &,maxloc(orbspread_input%spread2)
  call mem_alloc(kurtvec,ncore)
  kurtvec= dsqrt(dsqrt(CFG%KURT%omega))
  write(ls%lupri,'(a,f7.3,i5)') 'Maximum fourth spread and orb.number : ',&
  &maxval(kurtvec),maxloc(kurtvec)
  write(CFG%lupri,'(a)') 'Maximum *********************************************'
  write(CFG%lupri,'(a)') 'Minimum *********************************************'
  write(CFG%lupri,'(a,f7.3,i5)') 'Minimum orbspread and orb.number     : ',&
  &dsqrt(minval(orbspread_input%spread2))&
  &,minloc(orbspread_input%spread2)
  kurtvec= dsqrt(dsqrt(CFG%KURT%omega))
  write(ls%lupri,'(a,f7.3,i5)') 'Minimum fourth spread and orb.number : ',&
  &minval(kurtvec),minloc(kurtvec)
  write(CFG%lupri,'(a)') 'Minimum ********************************************'
  call mem_dealloc(kurtvec)
  call kurt_freeMO(CFG%KURT)
  call orbspread_free(orbspread_input)
  call mat_free(CMOblock)
end if
!######### VALENCE #############
if (nval > 0) then
  CFG%KURT%norb = nval
  call mat_init(CMOblock,nbas,nval)
  call mem_alloc(tmp,nbas*nval)
  call mat_retrieve_block(CMO,tmp,nbas,nval,1,ncore+1)
  call mat_set_from_full(tmp,1d0,CMOblock)
  call mem_dealloc(tmp)
  call kurt_initMO(CFG%KURT,CMOblock)
  call orbspread_init(orbspread_input,1,nval)
  call orbspread_update(orbspread_input,CMOblock)
  write(CFG%lupri,'(a)') '**** VALENCE LOCALITY  ****'
  do i=1,nval
     write(CFG%lupri, '(a,i5,f15.3,f15.3)') 'FINAL: orbspread, fourth orbspread :'&
     &, i+ncore,dsqrt(orbspread_input%spread2(i)),&
     &dsqrt(dsqrt(CFG%KURT%omega(i)))
  end do
  write(CFG%lupri,*)
  write(CFG%lupri,'(a)') 'Maximum *************** VALENCE ********************'
  write(CFG%lupri,'(a,f7.3,i5)') 'Maximum orbspread and orb.number    : ',&
  &dsqrt(maxval(orbspread_input%spread2))&
  &,maxloc(orbspread_input%spread2)+ncore
  call mem_alloc(kurtvec,nval)
  kurtvec= dsqrt(dsqrt(CFG%KURT%omega))
  write(ls%lupri,'(a,f7.3,i5)') 'Maximum fourth spread and orb.number : ',&
  &maxval(kurtvec),maxloc(kurtvec)+ncore
  write(CFG%lupri,'(a)') 'Maximum *********************************************'
  write(CFG%lupri,'(a)') 'Minimum *********************************************'
  write(CFG%lupri,'(a,f7.3,i5)') 'Minimum orbspread and orb.number     : ',&
  &dsqrt(minval(orbspread_input%spread2))&
  &,minloc(orbspread_input%spread2)+ncore
  kurtvec= dsqrt(dsqrt(CFG%KURT%omega))
  write(ls%lupri,'(a,f7.3,i5)') 'Minimum fourth spread and orb.number : ',&
  &(minval(kurtvec)),minloc(kurtvec)+ncore
  write(CFG%lupri,'(a)') 'Minimum ********************************************'
  write(CFG%lupri,*)
  call mem_dealloc(kurtvec)
  call kurt_freeMO(CFG%KURT)
  call orbspread_free(orbspread_input)
  call  mat_free(CMOblock)
end if

!######### VIRTUAL #############
if (nvirt > 0) then
  CFG%KURT%norb = nvirt
  call mat_init(CMOblock,nbas,nvirt)
  call mem_alloc(tmp,nbas*nvirt)
  call mat_retrieve_block(CMO,tmp,nbas,nvirt,1,ncore+nval+1)
  call mat_set_from_full(tmp,1d0,CMOblock)
  call mem_dealloc(tmp)
  call kurt_initMO(CFG%KURT,CMOblock)
  call orbspread_init(orbspread_input,1,nvirt)
  call orbspread_update(orbspread_input,CMOblock)
  write(CFG%lupri,'(a)') '**** VIRTUAL LOCALITY  ****'
  do i=1,nvirt
     write(CFG%lupri, '(a,i5,f15.3,f15.3)') 'FINAL: orbspread, fourth orbspread :'&
     &, i+ncore+nval,dsqrt(orbspread_input%spread2(i)),&
     &dsqrt(dsqrt(CFG%KURT%omega(i)))
  end do
  write(CFG%lupri,*)
  write(CFG%lupri,'(a)') 'Maximum **************** VIRTUAL *******************'
  write(CFG%lupri,'(a,f7.3,i5)') 'Maximum orbspread and orb.number     : ',&
  &dsqrt(maxval(orbspread_input%spread2))&
  &,maxloc(orbspread_input%spread2)+ncore+nval
  call mem_alloc(kurtvec,nvirt)
  kurtvec= dsqrt(dsqrt(CFG%KURT%omega))
  write(ls%lupri,'(a,f7.3,i5)') 'Maximum fourth spread and orb.number : ',&
  &maxval(kurtvec),maxloc(kurtvec)+ncore+nval
  write(CFG%lupri,'(a)') 'Maximum *********************************************'
  write(CFG%lupri,'(a)') 'Minimum *********************************************'
  write(CFG%lupri,'(a,f7.3,i5)') 'Minimum orbspread and orb.number    : ',&
  &dsqrt(minval(orbspread_input%spread2))&
  &,minloc(orbspread_input%spread2)+ncore+nval
  kurtvec= dsqrt(dsqrt(CFG%KURT%omega))
  write(ls%lupri,'(a,f7.3,i5)') 'Minimum fourth spread and orb.number : ',&
  &minval(kurtvec),minloc(kurtvec)+ncore+nval
  write(CFG%lupri,'(a)') 'Minimum *********************************************'
  write(CFG%lupri,*)
  call mem_dealloc(kurtvec)
  call kurt_freeMO(CFG%KURT)
  call orbspread_free(orbspread_input)
  call  mat_free(CMOblock)
end if


  call orbspread_propint_free(orbspread_input)
  call kurt_freeAO(CFG%KURT)

end subroutine LocalityMeasure

subroutine optimloc(CMO,nocc,m,ls,CFG)
use precision
use Pipek
use orbspread_module
use charge_module
use davidson_settings
use matrix_module, only: matrix
use matrix_operations 
use matrix_operations_aux, only: matrix_exponential
!use matrix_module
!use matrix_operations
!use matrix_operations_aux
use matrix_util
use loc_utils
!use typedef
use typedeftype
use LSTIMING
implicit none
type(RedSpaceItem) :: CFG
type(Matrix), target:: CMO
TYPE(lsitem) , intent(inout) :: ls
integer,       intent(in)    :: nocc
integer,       intent(in)    :: m(2)
integer                      :: nvirt, nbas, ncore, nval
type(Matrix)                 :: CMOo, CMOv, CMOc
type(Matrix), pointer        :: CMOs
integer     , pointer        :: selected(:)
real(realk), pointer      :: tmp(:)
type(orbspread_data)         :: inp
real(realk) :: tcpu1,twall1,tcpu2,twall2
integer :: m_core
!integer :: count_ncore
type(matrix) :: SC,CSC,S



nvirt=CMO%ncol - nocc
nbas =CMO%nrow
ncore = count_ncore(ls)
nval = nocc - ncore
CFG%lupri = ls%lupri
!Compute OrbLoc%SU needed for localization
if (CFG%ChargeLoc) then
   call mat_init(CFG%OrbLoc%SU,nbas,nbas)
   call get_correct_S(CFG,ls,nbas)
   CFG%OrbLoc%CMO => CMO
end if 
CFG%lupri = ls%lupri

if (CFG%KURT%TESTCASE) then
   call kurtosis_test(ls,cmo,nbas,CMO%ncol)
   return
elseif (CFG%PRINT_INFO) then
    call LocalityMeasure(CFG,ls,cmo,ncore,nval,nvirt)
    return
end if

!!!!!!!!!!!!!!!!! general, propint
if (CFG%orbspread)  call orbspread_propint(inp,ls)
if (CFG%kurtosis)   call kurt_initAO(CFG%KURT,ls,cmo%ncol)

if (.not. m(1)==0) then
CFG%KURT%m=m(1)
!HACK
!ncore = 6
!m_core = m(1)
 if (ncore.gt.0) then
!!!!!!!!!!!!!!!! core
  !init
  call mat_init(CMOc,nbas,ncore)
  !get core block
  call mem_alloc(tmp,nbas*ncore)
  call mat_retrieve_block(CMO,tmp,nbas,ncore,1,1)
  call mat_set_from_full(tmp,1d0,CMOc)
  call mem_dealloc(tmp)

  !break any symmetry in core molecular orbitals
!  call optimloc_mix_randomly(CMOc)

  !run localization
  write(ls%lupri,*) 'Localizing core: ', nbas, CMOc%ncol
!call orbspread_localize_CROP(CMOc,1,inp,ls)
  if (CFG%orbspread.or.CFG%kurtosis) then
      m_core = 1
  else
      m_core = 2
  end if

 if (ncore < 6) then
     write(ls%lupri,*) 'Too few orbitals to localize' 
 else
     write(ls%lupri,'(a)') 'Pred= ******* CORE LOCALIZATION ******* '
!     !HACK 
!     m_core = m(1)
     call localize_davidson(CMOc,m_core,inp,ls,CFG)
 end if
  write(ls%lupri,*) 'Done localizing core '
  !set occupied block in CMO
  call mem_alloc(tmp,nbas*ncore)
  call mat_to_full(CMOc,1d0,tmp)
  call mat_free(CMOc)
  call mat_create_block(CMO,tmp,nbas,ncore,1,1)
  call mem_dealloc(tmp)
 endif
!!!!!!!!!!!!!!!!!! valence
!init
call mat_init(CMOo,nbas,nval)
!
!!get core block
call mem_alloc(tmp,nbas*nval)
call mat_retrieve_block(CMO,tmp,nbas,nval,1,ncore+1)
call mat_set_from_full(tmp,1d0,CMOo)
call mem_dealloc(tmp)

!selected => orbspread_select_gt(CMOo,1d0,inp)
!CMOs => orbspread_build_selection(selected,CMOo)
!run localization
write(ls%lupri,*) 'Localizing valence: ', nbas, CMOo%ncol
if (nval < 6) then
     write(ls%lupri,*) 'Too few orbitals to localize' 
else
   write(ls%lupri,'(a)') 'Pred= ******* VALENCE LOCALIZATION ******* '
   call localize_davidson(CMOo,m(1),inp,ls,CFG)
   write(ls%lupri,*) 'Done localizing valence '
end if  
!  call orbspread_set_selection(CMOo,CMOs,selected)

!  call mat_free(CMOs)
!  deallocate(selected, CMOs)

  !set occupied block in CMO
  call mem_alloc(tmp,nbas*nval)
  call mat_to_full(CMOo,1d0,tmp)
  call mat_free(CMOo)
  call mat_create_block(CMO,tmp,nbas,nval,1,ncore+1)
  call mem_dealloc(tmp)
endif
if (.not. m(2) == 0) then
CFG%KURT%m=m(2)
!!!!!!!!!!!!!!!!! virtual
  !init
  call mat_init(CMOv,nbas,nvirt)

  !get occupied block
  call mem_alloc(tmp,nbas*nvirt)
  call mat_retrieve_block(CMO,tmp,nbas,nvirt,1,nocc+1)
  call mat_set_from_full(tmp,1d0,CMOv)
  call mem_dealloc(tmp)


  !run localization
  write(ls%lupri,*) 'Localizing virtual: ', nvirt
  if (nvirt < 6) then 
     write(ls%lupri,*) 'Too few orbitals to localize'
  else
     write(ls%lupri,'(a)') 'Pred= ******* VIRTUAL LOCALIZATION ******* '
     call localize_davidson(CMOv,m(2),inp,ls,CFG)
  end if
     
  !set occupied block in CMO
  call mem_alloc(tmp,nbas*nvirt)
  call mat_to_full(CMOv,1d0,tmp)
  call mat_free(CMOv)
  call mat_create_block(CMO,tmp,nbas,nvirt,1,nocc+1)
  call mem_dealloc(tmp)
endif

  if (CFG%orbspread) call orbspread_propint_free(inp)
  if (CFG%kurtosis)  call kurt_freeAO(CFG%KURT)
  if (CFG%Chargeloc) call mat_free(CFG%OrbLoc%SU)

  call LocalityMeasure(CFG,ls,cmo,ncore,nval,nvirt) 

    call mat_init(S,nbas,nbas)
    call mat_init(SC,nbas,nbas)
    call mat_init(CSC,nbas,nbas)
    CALL II_get_overlap(ls%lupri,ls%luerr,ls%setting,S)
    call mat_mul(S,CMO,'n','n',1E0_realk,0E0_realk,SC)
    call mat_mul(CMO,SC,'T','n',1E0_realk,0E0_realk,CSC)
    call mat_identity(SC)
    call mat_daxpy(-1E0_realk,SC,CSC)
    print*,'mat_sqnorm(C^T*S*C - I) =',mat_sqnorm2(CSC)/CSC%nrow
    IF(ABS(mat_sqnorm2(CSC)/CSC%nrow).GT.1.0E-15_realk)THEN
      write(ls%lupri,*) 'WARNING: ORBITALS NOT ORTHONORMAL!!! SOMETHING IS WRONG.' 
    ENDIF
    call mat_free(S)
    call mat_free(SC)
    call mat_free(CSC)


end subroutine optimloc


subroutine localize_davidson(CMO,m,orbspread_input,ls,CFG)
use orbspread_module
use charge_module
use davidson_settings
!use typedef
use typedeftype
use LSTIMING
use precision
use matrix_module, only: matrix
use matrix_operations 
!use matrix_operations_aux, only: matrix_exponential
!use matrix_module
!use matrix_operations
implicit none
type(RedSpaceItem) :: CFG
type(orbspread_data) :: orbspread_input
type(lsitem) :: ls
type(matrix) :: CMO
integer :: m

call davidson_reset(CFG)

if (CFG%orbspread) then
    !call orbspread_localize_CROP(CMO,m,orbspread_input,ls)
    call orbspread_localize_davidson(CFG,CMO,m,orbspread_input,ls)
    return
elseif (CFG%kurtosis) then
    call kurtosis_localize_davidson(CFG,CMO,m,ls)
    return
else
    call charge_localize_davidson(CFG,CMO,m,ls)
end if


end subroutine localize_davidson
!> \brief hessian linear transformation for power m orbital spread locality measure
!> \author B. Jansik
!> \date 2010
!> \param Hv linear transformation of H with trial vector V
!> \param V, trial vector
!> \param mu, level shift (H-muI)
!> \param norb, size of matrices (same as number of orbitals involved in localization)
!> \param orbspread_input structure holding orbspread related data
!!> \param m power
!!> \param spread2 vector of squared orbital spreads 
!!> \param R(3) matrix array holding XDIPLEN,YDIPLEN,ZDIPLEN components
!!> \param Q matrix holding sum XXSECMOM+YYSECMOM+ZZSECMOM
!!> \param tmpM(4) matrix array used as workspace
!> all parameters must be allocated prior to subroutine call
!> all type(matrix) arguments are of norb,norb size
subroutine orbspread_hesslin(Hv,V,mu,norb,orbspread_input)!m,spread2,R,Q,tmpM)
use orbspread_module
use charge_module
use davidson_settings
!use typedef
use typedeftype
use LSTIMING
use precision
use matrix_module, only: matrix
use matrix_operations 
!use matrix_operations_aux, only: matrix_exponential
!use matrix_module
!use matrix_operations
implicit none

Type(Matrix), intent(inout) :: Hv
Type(Matrix), intent(in)  :: V
real(realk), intent(in)   :: mu
integer, intent(in)       :: norb
type(orbspread_data), intent(in), target :: orbspread_input

integer       :: m
Type(Matrix)  :: R(3), RV(3)
Type(Matrix), pointer  ::  Q, G, QV ,tmpM
real(realk), pointer   :: spread2(:)
real(realk)  :: diagQV(norb), diagR(norb,3), diagRV(norb,3), tmp(norb)
integer      :: x,y,i

 !pointer assignments
 !stupid f90, no support for pointer arrays!
  do i=1,3
   call mat_clone(R(i),orbspread_input%R(i))
   call mat_clone(RV(i),orbspread_input%tmpM(i))
  enddo
  Q       => orbspread_input%Q
  QV      => orbspread_input%tmpM(4)
  tmpM    => orbspread_input%tmpM(4) !it's ok, QV will not be needed at that point
  G       => orbspread_input%G

  spread2 => orbspread_input%spread2

  m       =  orbspread_input%m


  !job
  call mat_mul(Q,V,'n','n',1E0_realk,0E0_realk,QV)

  call mat_extract_diagonal(diagQV,QV)


  do x=1, 3
  call mat_mul(R(x),V,'n','n',1E0_realk,0E0_realk,RV(x))
  call mat_extract_diagonal(diagRV(:,x),RV(x))
  call mat_extract_diagonal(diagR(:,x),R(x))
  enddo


  tmp = diagQV*(spread2**(m-2))
  call mat_zero(Hv)
  call mat_dmul(tmp,Q,'n',-4E0_realk*m*(m-1),0E0_realk,Hv)


  tmp =  (spread2**(m-1))
  call mat_dmul(tmp,QV,'t',-2E0_realk*m,1E0_realk,Hv)

  call mat_dmul(tmp,QV,'n',-2E0_realk*m,1E0_realk,Hv)

  do x=1, 3
  tmp = diagR(:,x)*diagQV*(spread2**(m-2))
  call mat_dmul(tmp,R(x),'n',8E0_realk*m*(m-1),1E0_realk,Hv)

  tmp = diagR(:,x)*diagRV(:,x)*(spread2**(m-2))
  call mat_dmul(tmp,Q,'n',8E0_realk*m*(m-1),1E0_realk,Hv)
 
     do y=1, 3
     tmp = diagR(:,x)*diagR(:,y)*diagRV(:,x)*(spread2**(m-2))
     call mat_dmul(tmp,R(y),'n',-16E0_realk*m*(m-1),1E0_realk,Hv)
     enddo

  tmp = diagRV(:,x)*(spread2**(m-1))
  call mat_dmul(tmp,R(x),'n',8E0_realk*m,1E0_realk,Hv)

  tmp = diagR(:,x)*(spread2**(m-1))
  call mat_dmul(tmp,RV(x),'t',4E0_realk*m,1E0_realk,Hv)

  call mat_dmul(tmp,RV(x),'n',4E0_realk*m,1E0_realk,Hv)

  enddo

  call mat_mul(V,G,'n','n',0.5E0_realk,1E0_realk,Hv)
  !call mat_mul(V,G,'n','n',1E0_realk,1E0_realk,Hv)

  call mat_trans(Hv,tmpM)
  call mat_daxpy(-1E0_realk,tmpM,Hv)

  !call mat_scal(0.5E0_realk,Hv)
  if (dabs(mu) > 1.0E-8_realk) call mat_daxpy(-mu,V,Hv)

end subroutine orbspread_hesslin

subroutine orbspread_precond(Xout,X,mu,inp)
use orbspread_module
use charge_module
use davidson_settings
!use typedef
use typedeftype
use LSTIMING
use precision
!use matrix_module
!use matrix_operations
use matrix_module, only: matrix
use matrix_operations
!use matrix_operations_aux, only: matrix_exponential
implicit none
type(Matrix), intent(inout) :: Xout
type(Matrix) :: X
real(realk),  intent(in) :: mu
type(orbspread_data), intent(in) :: inp
real(realk),pointer   :: tmp(:), tmpP(:)
integer                   :: i, ne
real(realk),pointer :: xvec(:),yvec(:)
type(matrix)  :: xtemp

  ne = Xout%nrow*Xout%ncol

  call mat_zero(Xout)
  
  select case(matrix_type)
  case(mtype_dense)

 
    do i=1,ne
       if (dabs(inp%P%elms(i)- mu) > 1d-8) Xout%elms(i) = X%elms(i)/(inp%P%elms(i) - mu)
    enddo
  case(mtype_scalapack)
    call mat_copy(1d0,X,Xout)
    call mat_hdiv(Xout,inp%P,mu)
  case default

    call mem_alloc(tmp,X%nrow*X%ncol)
    call mem_alloc(tmpP,inp%P%nrow*inp%P%ncol)
  
    call mat_to_full(X,1E0_realk,tmp)
    call mat_to_full(inp%P,1E0_realk,tmpP)

    do i=1,ne
    if (dabs(tmpP(i) - mu)> 1d-8) tmp(i) = tmp(i)/(tmpP(i) - mu)
    enddo


    call mat_set_from_full(tmp,1E0_realk,Xout)

    call mem_dealloc(tmp)
    call mem_dealloc(tmpP)

  end select

end subroutine orbspread_precond



!###### TESTING ROUTINES THAT ARE NOT COMPILED ########


#if 0
!> \brief unitest for orbspread_hesslin() subroutine
!> \author B. Jansik
!> \date 2010
!> \param passed 
!> passed shold be set to .true. otherwise orbspread_hesslin()
!> must be considered broken.
subroutine orbspread_hesslin_unitest(passed)
use orbspread_module
implicit none
logical, intent(out)   :: passed
integer,parameter      :: m=3,norb=4

type(orbspread_data)   :: inp

type(Matrix) :: Hv,V,T, G
real(realk),parameter :: mu=-100E0_realk
integer :: i

!allocations
 call mat_init(Hv,norb,norb)
 call mat_init(V,norb,norb)
 call mat_init(inp%Q,norb,norb)
 call mat_init(T,norb,norb)
 call mat_init(G,norb,norb)
 do i=1,3
  call mat_init(inp%R(i),norb,norb)
 enddo
 do i=1,4
  call mat_init(inp%tmpM(i),norb,norb)
 enddo

 call mem_alloc(inp%spread2,norb)

 inp%m = m

!initializations
V%elms=(/  0.00000,   0.10165,  -0.20779,   0.80376,&
&         -0.10165,   0.00000,   0.43667,   0.67566,&
&          0.20779,  -0.43667,   0.00000,  -0.01383,&
&         -0.80376,  -0.67566,   0.01383,   0.00000/)

inp%spread2=(/4.5307,  4.6998,  4.5653,  4.6842/)


inp%R(1)%elms=(/   -0.5491986,  -0.0161635,   0.0099889,  -0.0634636,&
&  -0.0161635,  -2.2018273,   0.0164245,   0.0034423,&
&   0.0099889,   0.0164245,   1.8516139,  -0.0247713,&
&  -0.0634636,   0.0034423,  -0.0247713,  -1.0247656/)

inp%R(2)%elms=(/    5.4993582,  0.0159468,  0.0328429,  0.0018908,&
&  0.0159468,  8.1435615,  0.0269154,  0.0036474,&
&  0.0328429,  0.0269154,  6.6766768,  0.0184473,&
&  0.0018908,  0.0036474,  0.0184473,  6.2713034/)

inp%R(3)%elms=(/   -5.568103,  -0.029165,  -0.085683,   0.092566,&
&  -0.029165,  -0.452908,  -0.012001,  -0.063588,&
&  -0.085683,  -0.012001,  -4.463905,   0.103218,&
&   0.092566,  -0.063588,   0.103218,  -1.464168/)

inp%Q%elms=(/   66.07905,    0.34181,    1.49184,   -0.68992,&
&    0.34181,   76.07052,    0.34397,    0.46282,&
&    1.49184,    0.34397,   72.49827,   -0.56997,&
&   -0.68992,    0.46282,   -0.56997,   47.20738/)

T%elms=(/ 0.0,                 896.5073521804492,  -371.1866122678854, 3618.1303606658821,&
&        -896.5073521804492, 0.0                ,  3826.0286713985975, 1037.6687781704547,&
&         371.1866122678854, -3826.0286713985975, 0.0 ,                74.9947733744852,&
&       -3618.1303606658821, -1037.6687781704547, -74.9947733744852, 0.0/)              


!test
 call orbspread_gradx(G,norb,inp)

 call orbspread_hesslin(Hv,V,mu,norb,inp)

 !Hv%elms=2E0_realk*Hv%elms
 write(6,*) 'Hesslin:'
 call mat_print(Hv,1,4,1,4,6)
 call mat_daxpy(-4E0_realk,Hv,T)

 passed = mat_sqnorm2(T).le. 1E-9_realk

!deallocations
 call mat_free(Hv)
 call mat_free(V)
 call mat_free(inp%Q)
 call mat_free(T)
 call mat_free(G)
 do i=1,3
  call mat_free(inp%R(i))
 enddo
 do i=1,4
  call mat_free(inp%tmpM(i))
 enddo

 call mem_dealloc(inp%spread2)

end subroutine orbspread_hesslin_unitest


!> \brief unitest for orbspread_gradx() subroutine
!> \author B. Jansik
!> \date 2010
!> \param passed 
!> passed shold be set to .true. otherwise orbspread_gradx()
!> must be considered broken.
subroutine orbspread_gradx_unitest(passed)
use orbspread_module
implicit none
logical, intent(out)   :: passed
integer,parameter      :: m=3,norb=4

type(orbspread_data)   :: inp

type(Matrix) :: G,T
integer :: i

!allocations
 call mat_init(G,norb,norb)
 call mat_init(inp%Q,norb,norb)
 call mat_init(T,norb,norb)
 do i=1,3
  call mat_init(inp%R(i),norb,norb)
 enddo
 do i=1,4
  call mat_init(inp%tmpM(i),norb,norb)
 enddo

 call mem_alloc(inp%spread2,norb)

 inp%m = m

inp%spread2=(/4.5307,  4.6998,  4.5653,  4.6842/)


inp%R(1)%elms=(/   -0.5491986,  -0.0161635,   0.0099889,  -0.0634636,&
&  -0.0161635,  -2.2018273,   0.0164245,   0.0034423,&
&   0.0099889,   0.0164245,   1.8516139,  -0.0247713,&
&  -0.0634636,   0.0034423,  -0.0247713,  -1.0247656/)

inp%R(2)%elms=(/    5.4993582,  0.0159468,  0.0328429,  0.0018908,&
&  0.0159468,  8.1435615,  0.0269154,  0.0036474,&
&  0.0328429,  0.0269154,  6.6766768,  0.0184473,&
&  0.0018908,  0.0036474,  0.0184473,  6.2713034/)

inp%R(3)%elms=(/   -5.568103,  -0.029165,  -0.085683,   0.092566,&
&  -0.029165,  -0.452908,  -0.012001,  -0.063588,&
&  -0.085683,  -0.012001,  -4.463905,   0.103218,&
&   0.092566,  -0.063588,   0.103218,  -1.464168/)

inp%Q%elms=(/   66.07905,    0.34181,    1.49184,   -0.68992,&
&    0.34181,   76.07052,    0.34397,    0.46282,&
&    1.49184,    0.34397,   72.49827,   -0.56997,&
&   -0.68992,    0.46282,   -0.56997,   47.20738/)

T%elms=(/  0.00000,   -19.63628,    -8.34807,  106.23052,&
&         19.63628,     0.00000,    18.56968,   16.51622,&
&          8.34807,   -18.56968,     0.00000,   97.01746,&
&       -106.23052,   -16.51622,   -97.01746,    0.00000/)


!test

 call orbspread_gradx(G,norb,inp)

 write(6,*) 'Gradx:'
 call mat_print(G,1,4,1,4,6)
 call mat_daxpy(-2E0_realk,G,T)

 passed = mat_sqnorm2(T).le. 1E-5_realk

!deallocations
 call mat_free(G)
 call mat_free(inp%Q)
 call mat_free(T)
 do i=1,3
  call mat_free(inp%R(i))
 enddo
 do i=1,4
  call mat_free(inp%tmpM(i))
 enddo

 call mem_dealloc(inp%spread2)

end subroutine orbspread_gradx_unitest

subroutine orbspread_precond_unitest(passed)
use orbspread_module
implicit none
logical, intent(out)   :: passed
integer,parameter      :: m=3,norb=4
real(realk),parameter :: mu=-100E0_realk
type(orbspread_data)   :: inp

type(Matrix), target :: P,T,Tp
integer :: i, kl(2,1)
real(realk) :: emin(1)

!allocations
 call mat_init(P,norb,norb)
 call mat_init(inp%Q,norb,norb)
 call mat_init(T,norb,norb)
 call mat_init(Tp,norb,norb)
 do i=1,3
  call mat_init(inp%R(i),norb,norb)
 enddo
 do i=1,4
  call mat_init(inp%tmpM(i),norb,norb)
 enddo

 call mem_alloc(inp%spread2,norb)

 inp%m = m
inp%spread2=(/4.5307,  4.6998,  4.5653,  4.6842/)


inp%R(1)%elms=(/   -0.5491986,  -0.0161635,   0.0099889,  -0.0634636,&
&  -0.0161635,  -2.2018273,   0.0164245,   0.0034423,&
&   0.0099889,   0.0164245,   1.8516139,  -0.0247713,&
&  -0.0634636,   0.0034423,  -0.0247713,  -1.0247656/)

inp%R(2)%elms=(/    5.4993582,  0.0159468,  0.0328429,  0.0018908,&
&  0.0159468,  8.1435615,  0.0269154,  0.0036474,&
&  0.0328429,  0.0269154,  6.6766768,  0.0184473,&
&  0.0018908,  0.0036474,  0.0184473,  6.2713034/)

inp%R(3)%elms=(/   -5.568103,  -0.029165,  -0.085683,   0.092566,&
&  -0.029165,  -0.452908,  -0.012001,  -0.063588,&
&  -0.085683,  -0.012001,  -4.463905,   0.103218,&
&   0.092566,  -0.063588,   0.103218,  -1.464168/)

inp%Q%elms=(/   66.07905,    0.34181,    1.49184,   -0.68992,&
&    0.34181,   76.07052,    0.34397,    0.46282,&
&    1.49184,    0.34397,   72.49827,   -0.56997,&
&   -0.68992,    0.46282,   -0.56997,   47.20738/)



!test

 call orbspread_precond_matrix(P,emin,kl,0,0E0_realk,norb,inp)

 inp%P => P

 T%elms=1E0_realk
 call orbspread_precond(Tp,T,mu,inp) 
 call mat_print(Tp,1,4,1,4,6)

!deallocations
 call mat_free(P)
 call mat_free(inp%Q)
 call mat_free(T)
 call mat_free(Tp)
 do i=1,3
  call mat_free(inp%R(i))
 enddo
 do i=1,4
  call mat_free(inp%tmpM(i))
 enddo

 call mem_dealloc(inp%spread2)

end subroutine orbspread_precond_unitest


subroutine exp_unitest(passed)
use matrix_util
implicit none
logical, intent(out)   :: passed
integer, parameter     :: norb=4
integer                :: noo, non

type(Matrix) :: X,expX,T

!allocations
 call mat_init(X,norb,norb)
 call mat_init(expX,norb,norb)
 call mat_init(T,norb,norb)
!0.344005

X%elms=(/   0.344005,  0.370805,  0.673547,  0.686226,&
&           0.031198,  0.840471,  0.605507,  0.375608,&
&           0.279060,  0.628690,  0.030451,  0.115126,&
&           0.675903,  0.671164,  0.102444,  0.206692/)

T%elms=(/  1.97286,  1.62098,  1.30758,  1.29770,&
&          0.45478,  3.05118,  1.20900,  0.87865,&
&          0.52325,  1.34923,  1.50395,  0.50309,&
&          1.12429,  1.73292,  0.83352,  1.85123/)

!test

 !call mat_no_of_matmuls(noo)

 call matrix_exponential(X,expX,1E-12_realk)

 !call mat_no_of_matmuls(non)

 !write(6,*) non-noo
 call mat_daxpy(-1E0_realk,expX,T)

 passed = mat_sqnorm2(T).le. 1E-9_realk

!deallocations
 call mat_free(X)
 call mat_free(expX)
 call mat_free(T)

end subroutine exp_unitest

subroutine orbspread_solver_unitest(passed)
use orbspread_module
!use decompMod
use ARHmodule

implicit none
logical, intent(out)   :: passed
integer,parameter      :: m=3,norb=4

type(orbspread_data), target   :: inp

type(Matrix) :: Hv, G, X
real(realk),parameter :: mu=-1.32E0_realk
integer :: i

!solver related declarations
type(decompItem)   :: decomp
type(solverItem)   :: arh
type(debugItem)    :: debug
TYPE(modFIFO)      :: queue

!allocations
 call mat_init(Hv,norb,norb)
 call mat_init(inp%Q,norb,norb)
 call mat_init(G,norb,norb)
 call mat_init(X,norb,norb)
 do i=1,3
  call mat_init(inp%R(i),norb,norb)
 enddo
 do i=1,4
  call mat_init(inp%tmpM(i),norb,norb)
 enddo

 call mem_alloc(inp%spread2,norb)

 inp%m = m

inp%spread2=(/0.16223,  0.14987,  0.39164,  0.61443/)


inp%R(1)%elms=(/  0.734535,  0.584218,  0.701755,  0.064086,&
&             0.853723,  0.796857,  0.305236,  0.681963,&
&             0.625375,  0.441937,  0.741858,  0.748711,&
&             0.766346,  0.463687,  0.927562,  0.019981/)

inp%R(2)%elms=(/  0.557369,  0.435741,  0.736332,  0.455053,&
&             0.027335,  0.545388,  0.923669,  0.803679,&
&             0.984998,  0.065604,  0.471317,  0.816302,&
&             0.662640,  0.481126,  0.147809,  0.717182/)

inp%R(3)%elms=(/  0.6461293,  0.6788147,  0.6815679,  0.1965552,&
&             0.2743679,  0.7154769,  0.3921278,  0.2958226,&
&             0.6670042,  0.3111366,  0.8163864,  0.0074360,&
&             0.7020067,  0.8659539,  0.7503724,  0.0757745/)

inp%Q%elms=(/0.047692,  0.495820,  0.258083,  0.845362,&
&        0.423167,  0.148130,  0.953802,  0.640069,&
&        0.588172,  0.639629,  0.395089,  0.084721,&
&        0.244598,  0.104311,  0.949004,  0.040549/)


!test
 call orbspread_gradx(G,norb,inp)


 call arh_set_default_config(arh)
 call decomp_set_default_config(decomp)
 arh%cfg_orbspread = .true.
 decomp%cfg_orbspread = .true.
 arh%orbspread_input => inp
 arh%cfg_arh_truncate = .false.
 arh%cfg_noprec = .false.

 call arh_crop_solver(decomp,arh,debug,G,2,X,queue)

 call orbspread_hesslin(Hv,X,arh%current_mu,norb,inp)


 call mat_daxpy(-1E0_realk,Hv,G)

 write(6,*) mat_sqnorm2(G)
 passed = mat_sqnorm2(G).le. 1E-9_realk

!deallocations
 call mat_free(Hv)
 call mat_free(X)
 call mat_free(inp%Q)
 call mat_free(G)
 do i=1,3
  call mat_free(inp%R(i))
 enddo
 do i=1,4
  call mat_free(inp%tmpM(i))
 enddo

 call mem_dealloc(inp%spread2)

end subroutine orbspread_solver_unitest

subroutine orbspread_solver_unitest2(passed)
use orbspread_module
!use decompMod
use ARHmodule

implicit none
logical, intent(out)   :: passed
integer,parameter      :: m=3,norb=4

type(orbspread_data), target   :: inp

type(Matrix) :: Hv, G, X
real(realk),parameter :: mu=0E0_realk
integer :: i

!solver related declarations
type(decompItem)   :: decomp
type(solverItem)   :: arh
type(debugItem)    :: debug
TYPE(modFIFO)      :: queue

!allocations
 call mat_init(Hv,norb,norb)
 call mat_init(inp%Q,norb,norb)
 call mat_init(G,norb,norb)
 call mat_init(X,norb,norb)
 do i=1,3
  call mat_init(inp%R(i),norb,norb)
 enddo
 do i=1,4
  call mat_init(inp%tmpM(i),norb,norb)
 enddo

 call mem_alloc(inp%spread2,norb)

 inp%m = m

inp%spread2=(/4.5307,  4.6998,  4.5653,  4.6842/)


inp%R(1)%elms=(/   -0.5491986,  -0.0161635,   0.0099889,  -0.0634636,&
&  -0.0161635,  -2.2018273,   0.0164245,   0.0034423,&
&   0.0099889,   0.0164245,   1.8516139,  -0.0247713,&
&  -0.0634636,   0.0034423,  -0.0247713,  -1.0247656/)

inp%R(2)%elms=(/    5.4993582,  0.0159468,  0.0328429,  0.0018908,&
&  0.0159468,  8.1435615,  0.0269154,  0.0036474,&
&  0.0328429,  0.0269154,  6.6766768,  0.0184473,&
&  0.0018908,  0.0036474,  0.0184473,  6.2713034/)

inp%R(3)%elms=(/   -5.568103,  -0.029165,  -0.085683,   0.092566,&
&  -0.029165,  -0.452908,  -0.012001,  -0.063588,&
&  -0.085683,  -0.012001,  -4.463905,   0.103218,&
&   0.092566,  -0.063588,   0.103218,  -1.464168/)

inp%Q%elms=(/   66.07905,    0.34181,    1.49184,   -0.68992,&
&    0.34181,   76.07052,    0.34397,    0.46282,&
&    1.49184,    0.34397,   72.49827,   -0.56997,&
&   -0.68992,    0.46282,   -0.56997,   47.20738/)



!test
 call orbspread_gradx(G,norb,inp)


 call arh_set_default_config(arh)
 call decomp_set_default_config(decomp)
 arh%cfg_orbspread = .true.
 decomp%cfg_orbspread = .true.
 arh%orbspread_input => inp
 arh%cfg_arh_truncate = .false.
 arh%cfg_noprec = .false.


 call arh_crop_solver(decomp,arh,debug,G,2,X,queue)

 call orbspread_hesslin(Hv,X,arh%current_mu,norb,inp)

 call mat_print(X,1,4,1,4,6)

 call mat_daxpy(-1E0_realk,Hv,G)

 write(6,*) mat_sqnorm2(G)
 passed = mat_sqnorm2(G).le. 1E-9_realk

!deallocations
 call mat_free(Hv)
 call mat_free(X)
 call mat_free(inp%Q)
 call mat_free(G)
 do i=1,3
  call mat_free(inp%R(i))
 enddo
 do i=1,4
  call mat_free(inp%tmpM(i))
 enddo

 call mem_dealloc(inp%spread2)

end subroutine orbspread_solver_unitest2



subroutine orbspread_precond_unitest2(passed)
use orbspread_module
!use decompMod
use ARHmodule

implicit none
logical, intent(out)   :: passed
integer,parameter      :: m=3,norb=4

type(orbspread_data), target   :: inp

type(Matrix) :: Hv, T, G, X
type(Matrix), pointer :: P
real(realk),parameter :: mu=0E0_realk
integer :: i,j, kl(2,1)
real(realk) :: val, emin(1)

!solver related declarations
type(decompItem)   :: decomp
type(solverItem)   :: arh
type(debugItem)    :: debug
TYPE(modFIFO)      :: queue

!allocations
 call mat_init(Hv,norb,norb)
 call mat_init(inp%Q,norb,norb)
 call mat_init(G,norb,norb)
 call mat_init(X,norb,norb)
 call mat_init(T,norb,norb)
 do i=1,3
  call mat_init(inp%R(i),norb,norb)
 enddo
 do i=1,4
  call mat_init(inp%tmpM(i),norb,norb)
 enddo

 call mem_alloc(inp%spread2,norb)

 inp%m = m

inp%spread2=(/0.16223,  0.14987,  0.39164,  0.61443/)

inp%R(1)%elms=(/   0.22097, 0.75410, 0.46831, 0.36425,&
&                  0.75410, 0.22471, 0.49422, 0.48281,&
&                  0.46831, 0.49422, 0.88116, 0.41692,&
&                  0.36425, 0.48281, 0.41692, 0.60770/)

inp%R(2)%elms=(/    0.27603,  0.79741,  0.46847,  0.15278,&
&                   0.79741,  0.74890,  0.59191,  0.94024,&
&                   0.46847,  0.59191,  0.35630,  0.60522,&
&                   0.15278,  0.94024,  0.60522,  0.95474/)

inp%R(3)%elms=(/   0.83232,  0.48356,  0.60922,  0.40515,&
&                  0.48356,  0.45738,  0.33015,  0.28682,&
&                  0.60922,  0.33015,  0.28448,  0.56644,&
&                  0.40515,  0.28682,  0.56644,  0.26361/)

inp%Q%elms=(/  0.14532,  0.47040,  0.67501,  0.47688,&
&              0.47040,  0.60246,  0.63225,  0.75969,&
&              0.67501,  0.63225,  0.90917,  0.55272,&
&              0.47688,  0.75969,  0.55272,  0.16080/)


!test
 call orbspread_gradx(G,norb,inp)

 do i=1,norb
  do j=1,norb
   call mat_scal(0E0_realk,X)

   call mat_create_elm(i,j,1E0_realk,X)

   call orbspread_hesslin(Hv,X,mu,norb,inp)

   call mat_get_elm(Hv,i,j,val)

   call mat_create_elm(i,j,val,T)
  enddo
 enddo

 call mat_scal(0.5E0_realk,T) 
 call mat_trans(T,inp%tmpM(1))
 call mat_daxpy(+1E0_realk,inp%tmpM(1),T)

 P => inp%tmpM(1)

 call orbspread_precond_matrix(P,emin,kl,0,mu,norb,inp)

 call mat_dotmul(T,P,1E0_realk,0E0_realk,X)

 call mat_print(T,1,4,1,4,6)
 call mat_print(P,1,4,1,4,6)
 write(6,*) mat_sqnorm2(X)
 passed = abs(mat_sqnorm2(X) -12E0_realk).le. 1E-9_realk

!deallocations
 call mat_free(Hv)
 call mat_free(X)
 call mat_free(T)
 call mat_free(inp%Q)
 call mat_free(G)
 do i=1,3
  call mat_free(inp%R(i))
 enddo
 do i=1,4
  call mat_free(inp%tmpM(i))
 enddo

 call mem_dealloc(inp%spread2)

end subroutine orbspread_precond_unitest2

#endif
