#GENERATING TENSOR PERMUTATIONS
#AUTHOR: PATRICK ETTENHUBER
#EMAIL : pett@chem.au.dk, pettenhuber@gmail.com
#DATE  : JUNE, 2013
import sys,datetime,math,os#,itertools
"""This file is inteded for the automatic generation of a data sorting module in LSDALTON
As data sorting is under constant development and features many lines of code this script was
written for easy modification of the code. Furhtermore, one might note that the structure
of optimal code might depend on the architecture which can be at some point introduced here
as well

Currently the routine does not take any command-line arguments, but is dependet on the LSDALTON
folder structure, i.e. it needs LSDALTON/lsutil and LSDALTON/lsutil/autogen/reord_headers.F90
which can be found as long as LSDALTON is in the execution path, or one layer below execution
folder."""

##################################################################################################
##################################################################################################

def main():
  #GET THE FOLDER TO STORE THE manual_reorderings.F90
  cwd = os.getcwd()
  lsutildir = cwd
  if ("LSDALTON" in lsutildir ):
    lsutildir = lsutildir[0:lsutildir.find("LSDALTON")]+"/LSDALTON/lsutil/"
  else:
    for paths,dirs,files in os.walk(cwd+"/.."):
      if("LSDALTON" in paths):
        lsutildir = paths[0:paths.find("LSDALTON")]+"/LSDALTON/lsutil/"
    if not os.path.exists(lsutildir):
      print "COULD NOT FIND LSDALTON/lsutil, exiting"
      sys.exit()

  #THIS FILE SHOULD GENERATE ALL REORDERINGS NEEDED in manual_reorderings.F90
  if(not os.path.exists(lsutildir+"manual_reorderings.F90")):
    produce_file(lsutildir,sys.argv)

##################################################################################################
##################################################################################################
def produce_file(lsutildir,args):
   abc = "abcdefghijklmnopqrstuvwxyz"
   maxr = 4
   minr = 2
   f=open(lsutildir+"manual_reorderings.F90",'w')
   #GET COMMAND LINE ARGUMENTS
   debug_loops = ("VAR_LSDEBUG" in args)
   nocollapse = ("nocollapse" in args)
    
    
   #WRITE HEADER AND MODULE
   now = datetime.datetime.now()
   f.write("!\> \\brief this autogenerated module is inteded to contain high performance reorderings for\n!mutlidimensional arrays.\n!\> \\author Patrick Ettenhuber & Janus Juul Eriksen\n!\> \\date November 2012, file produced: "+str(now.month)+", "+str(now.year)+"\n")
   f.write("module manual_reorderings_module\n")
   f.write("  use precision\n")
   f.write("  use memory_handling\n")
   f.write("  use LSTIMING\n")
   f.write("  contains\n")
   #Write the subroutines called by the user
   basic = open(lsutildir+"/autogen/reorder_header.F90",'r')
   for line in basic:
     f.write(line)
   basic.close
   
   #SPECIFY THE ORDER OF REODERINGS
   for modes in range(maxr,minr-1,-1):
   
     # GENERATE ORIGINAL ORDER AND STARTING POINT FOR NEW ORDER
     idxarr = [0]*modes
     for i in range(modes):
       idxarr[i] = i
   
     #GET ALL PERMUTATION
     #all_permutations=itertools.permutations(idxarr)
     all_permutations=permutations(idxarr)
    
     #LOOP OVER PERMUTATIONS AND WRITE SUBROUTINES
     for perm in all_permutations:
       #CHECK IF THE ORDERING IS NECESSARY, ELSE JUST SKIP IT
       doreord = True
       for i in range(len(perm)-1):
         if(perm[i]+1==perm[i+1]):
           doreord = False
       if not doreord :
         continue

       # WRITE THE SUBROUTINE
       reordstr1 = ""
       reordstr2 = ""
       reordstr3 = ""
       for i in range(modes):
         reordstr1 += str(perm[i]+1)
         reordstr2 += "dims("+str(idxarr[i]+1)+"),"
         reordstr3 += "dims("+str(perm[i]+1)+"),"
       reordstr2 = reordstr2[0:-1]
       reordstr3 = reordstr3[0:-1]
       subroutinename =  "manual_"+reordstr1+"_reordering"
     
       #GET THE SUBROUTINE HEADER
       subheaderstr= "  !\> \\brief reorder a "+str(modes)+" diensional array  to get the indices\n"
       subheaderstr+= "  !   in the order "+reordstr1+" , this is a quite expensive reordering\n"
       subheaderstr+= "  !   and thus requires additional attention \n"
       subheaderstr+= "  !\> \\autor Patrick Ettenhuber\n"
       subheaderstr+= "  !\> \date "+str(now.month)+", "+str(now.year)+"\n"
       subheaderstr+= "  subroutine "+subroutinename+"(bs,dims,pre1,array_in,pre2,array_out)\n"
       subheaderstr+= "    implicit none\n"
       subheaderstr+= "    !> input for the block size in tiled reordering\n"
       subheaderstr+= "    integer, intent(in) :: bs\n"
       subheaderstr+= "    !>  the dimensions of the different modes in the original array\n"
       subheaderstr+= "    integer, intent(in) :: dims("+str(modes)+")\n"
       subheaderstr+= "    !> as this routine can be used for adding and scaling these are the prefactors\n"
       subheaderstr+= "    real(realk),intent(in) :: pre1,pre2\n"
       subheaderstr+= "    !> array to be reordered\n"
       subheaderstr+= "    real(realk),intent(in) :: array_in("+reordstr2+")\n"
       subheaderstr+= "    !> reordered array\n"
       subheaderstr+= "    real(realk),intent(inout) :: array_out("+reordstr3+")\n"
       subheaderstr+= "    integer :: bcntr,"
       for i in range(modes):
         subheaderstr+= abc[i]+",b"+abc[i]+",d"+abc[i]+",d"+abc[i]+"2,"
       subheaderstr = subheaderstr[0:-1]
       subheaderstr += "\n"
       subheaderstr+= "    logical :: "
       for i in range(modes):
         subheaderstr+= "mod"+abc[i]+","
       subheaderstr = subheaderstr[0:-1]
       subheaderstr += "\n\n"
       for i in range(modes):
         subheaderstr+= "    d"+abc[i]+"=dims("+str(i+1)+")\n"
       subheaderstr+= "\n"
       for i in range(modes):
         subheaderstr+= "    d"+abc[i]+"2=(d"+abc[i]+"/bs)*bs\n"
       subheaderstr+= "\n"
       for i in range(modes):
         subheaderstr+= "    mod"+abc[i]+"=(mod(d"+abc[i]+",bs)>0)\n"
       subheaderstr+= "    bcntr=bs-1\n"

       f.write(subheaderstr)
       #GENERAL CASE pre1/=1 pre2/=0 or 1
       if(not debug_loops):
         cases = ["pre2 == 0.0E0_realk .and. pre1 == 1.0E0_realk"]
         cases.append("pre2 == 0.0E0_realk .and. pre1 /= 1.0E0_realk")
         cases.append("pre2 == 1.0E0_realk .and. pre1 == 1.0E0_realk")
         cases.append("pre2 == 1.0E0_realk .and. pre1 /= 1.0E0_realk")
         cases.append("pre2 /= 1.0E0_realk .and. pre1 == 1.0E0_realk")
         cases.append("pre2 /= 1.0E0_realk .and. pre1 /= 1.0E0_realk")
       else:
         cases = [".true."]

       #write sfuff for all the cases above
       for cas in range(len(cases)):
         if(cas==0):
           f.write("\n    precase: if("+cases[cas]+")then\n")
         else:
           f.write("\n    elseif("+cases[cas]+")then\n")
   
         #WRITE OMP PARALLEL STATEMENT HERE
         omppar ="      !$OMP PARALLEL DEFAULT(NONE),PRIVATE("
         for j in range(modes):
           omppar += abc[j]+",b"+abc[j]+","
         omppar = omppar[0:-1] + ")&\n      !$OMP& SHARED(bcntr,pre1,pre2,bs,array_in,array_out, &\n      !$OMP& "
         for j in range(modes):
           omppar += "d"+abc[j] +",d"+abc[j]+"2,mod"+abc[j]+","
         omppar = omppar[0:-1]+")\n"
        
         if(not debug_loops): 
           f.write("#ifndef VAR_LSESSL\n")
           f.write(omppar)
           f.write("#endif\n")
       
         #get the batched space
         casecounter = 1
         if(not debug_loops):
           fullrange = modes+1
         else:
           fullrange = 1
         for i in range(fullrange):
           #FIND THE RESTRICTED INDICES IN THE OLD ORDERING
           all_thingys = combinations(idxarr,i)
           #all_thingys = itertools.combinations(idxarr,i)
           for oldr in all_thingys:
   
             label1 = "r"+str(casecounter)
             label1 = ""
             casecounter += 1
             #get conditions for the reordering
             conditions = []
             oldu  = []
             newu  = []
             newr  = []
             for j in range(modes):
               oldu.append(idxarr[j])
               newu.append(perm[j])
               newr.append(perm[j])
               conditions.append("d"+abc[j]+"2>0")
   
             #modify the conditions accordingly
             for j in  range(len(oldr)):
               conditions[oldr[j]] = "mod"+abc[oldr[j]]
               for k in range(len(oldu)):
                 if oldu[k] == oldr[j]:
                   del oldu[k]
                   break
               for k in range(len(newu)):
                 if newu[k] == oldr[j]:
                   del newu[k]
                   break
             for j in  range(len(oldu)):
               for k in range(len(newr)):
                 if newr[k] == oldu[j]:
                   del newr[k]
                   break
             
             #Build if-statement for current restrictions
             if(not debug_loops):
               conditionalstatement = "      "+label1+"if("
               for j in range(len(conditions)):
                 conditionalstatement += conditions[j]
                 if j != len(conditions)-1:
                   conditionalstatement+=".and."
               conditionalstatement += ")then\n"
               f.write(conditionalstatement)
         
             #WRITE OMP DO STUFF HERE
             if(not debug_loops):
               if(modes-len(oldr)>0):
                 ompdo ="        !$OMP DO" 
                 if (modes-len(oldr)>1 and (not nocollapse)):
                   ompdo += " COLLAPSE("+str(modes-len(oldr))+")\n"
                 else:
                   ompdo += "\n"
                 f.write("#ifndef VAR_LSESSL\n")
                 f.write(ompdo)
                 f.write("#endif\n")
   
             #ORDER THE LOOPS, this depends on the architecture and may be modified
             #THESE CONDITIONS ARE SET UP FOR INTEL, please adapt whenever a different compiler/architecture is used
             useold = False
             for j in range(len(oldu)):
               if(idxarr[oldu[j]]<perm[newu[j]]):
                 useold = True
                 break
               elif(idxarr[oldu[j]]>perm[newu[j]]):
                 useold =False
                 break
               
             #f.write("!"+str(newu)+"    "+str(oldu)+"\n")
             #f.write("!useold "+str(useold)+"\n")
             #BUILD THE ORDER OF THE LOOPS ACCORDING TO THE PREVIOUS CONDITIONS
             outer =[]
             inner =[]
             for j in range(len(perm)):
               if useold:
                 inner.append(idxarr[j])
               else:
                 inner.append(perm[j])
             
             if useold:
               for j in range(len(oldu)):
                 outer.append(oldu[j])
             else:
               for j in range(len(newu)):
                 outer.append(newu[j])
             inneri = []
             outeri = []
             for j in reversed(inner):
               inneri.append(j)
             for j in reversed(outer):
               outeri.append(j)
           
   
             #WRITING THE OUTER FOR LOOPS HERE:
             if(not debug_loops):
               offsetstr="        "
               for j in  range(len(outeri)):
                 f.write(offsetstr+"do b"+abc[outeri[j]]+"=1,d"+abc[outeri[j]]+"2,bs\n")
                 offsetstr += "  "
               offsetstr = offsetstr[0:-2]
             else:
               offsetstr="    "
               
             f.write("\n")
            
             offsetstr2 = offsetstr + "  "
             #WRITING THE INNER FOR LOOPS HERE:
             if(not debug_loops):
               for j in range(modes):
                 if(inneri[j] in newr):
                   f.write(offsetstr2+"do "+abc[inneri[j]]+"=d"+abc[inneri[j]]+"2+1,d"+abc[inneri[j]]+"\n")
                 elif(inneri[j] in newu):
                   f.write(offsetstr2+"do "+abc[inneri[j]]+"=0,bcntr\n")
                 else:
                   print "FUCKING INVALID STUFF HAPPENING HERE"
                 offsetstr2 += "  "
             else:
               for j in range(modes):
                 f.write(offsetstr2+"do "+abc[inneri[j]]+"=1,d"+abc[inneri[j]]+"\n")
                 offsetstr2 += "  "
   
             offsetstr2 = offsetstr2[0:-2]
             
             #CENTRAL COPYING AND ADDITION STRING
             newidx = ""
             oldidx = ""
             if(not debug_loops):
               for j in range(modes):
                 if(perm[j] in newu):
                   newidx += "b"+abc[perm[j]]+"+"+abc[perm[j]]+","
                 elif(perm[j] in newr):
                   newidx += abc[perm[j]]+","
                 else:
                   print "FUCKING INVALID STUFF HAPPENING HERE"
                 if(idxarr[j] in newu):
                   oldidx += "b"+abc[idxarr[j]]+"+"+abc[idxarr[j]]+","
                 elif(idxarr[j] in newr):
                   oldidx += abc[idxarr[j]]+","
                 else:
                   print "FUCKING INVALID STUFF HAPPENING HERE"
             else:
               for j in range(modes):
                 newidx += abc[perm[j]]+","
                 oldidx += abc[idxarr[j]]+","

             newidx = newidx[0:-1]
             oldidx = oldidx[0:-1]
   
             cpstr=offsetstr2+"  array_out("
             if(not debug_loops):
               if cas == 0:
                 cpstr += newidx+")=array_in("+oldidx+")\n"
               elif cas==1:
                 cpstr += newidx+")=pre1*array_in("+oldidx+")\n"
               elif cas==2:
                 cpstr += newidx+")=array_out("+newidx+")&\n                                                  &+array_in("+oldidx+")\n"
               elif cas==3:
                 cpstr += newidx+")=array_out("+newidx+")&\n                                                  &+pre1*array_in("+oldidx+")\n"
               elif cas==4:
                 cpstr += newidx+")=pre2*array_out("+newidx+")&\n                                                  &+array_in("+oldidx+")\n"
               elif cas==5:
                 cpstr += newidx+")=pre2*array_out("+newidx+")&\n                                                  &+pre1*array_in("+oldidx+")\n"
             else:
               cpstr += newidx+")=pre2*array_out("+newidx+")&\n                                                  &+pre1*array_in("+oldidx+")\n"
    
             f.write(cpstr)
             
   
             for j in  range(modes-1,-1,-1):
               f.write(offsetstr2+"enddo\n")
               offsetstr2 = offsetstr2[0:-2]
   
             f.write("\n")
   
             #WRITING THE OUTER ENDOFOR HERE:
             if(not debug_loops):
               for j in  range(modes-len(oldr)-1,-1,-1):
                 f.write(offsetstr+"enddo\n")
                 offsetstr = offsetstr[0:-2]
              
               if(modes-len(oldr)> 0):
                 ompdo ="        !$OMP END DO NOWAIT\n" 
                 f.write("#ifndef VAR_LSESSL\n")
                 f.write(ompdo)
                 f.write("#endif\n")
              
               conditionalstatement="      endif "+label1+"\n"
               f.write(conditionalstatement)
             
           if(not debug_loops):
             if(i==modes-1):
               ompdo = "      !$OMP END PARALLEL\n"
               f.write("#ifndef VAR_LSESSL\n")
               f.write(ompdo)
               f.write("#endif\n")
      
         if(cas==len(cases)-1):
           f.write("    endif precase\n")
   
       #END THE SUBROUTINE
       f.write("  end subroutine "+subroutinename+"\n\n")
   
   f.write("end module manual_reorderings_module")
   f.close()



#ITERTOOLS COMBINATIONS AND PERMUTATIONS ARE NOT IMPLEMENTED BELOW PYTHON 2.6, THUS I COPIED THE
#SOURCE CODE OF THE HOMEPAGE DIRECTLY
##################################################################################################
##################################################################################################

#THIS IS A MODIFIED COPY OF http://docs.python.org/2/library/itertools.html#itertools.permutations
##################################################################################################
def permutations(iterable):
    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --> 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n
    if r > n:
        return
    indices = range(n)
    cycles = range(n, n-r, -1)
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return

#THIS IS A MODIFIED COPY OF http://docs.python.org/2/library/itertools.html#itertools.permutations
##################################################################################################
def combinations(iterable, r):
    # combinations('ABCD', 2) --> AB AC AD BC BD CD
    # combinations(range(4), 3) --> 012 013 023 123
    pool = tuple(iterable)
    n = len(pool)
    if r > n:
        return
    indices = range(r)
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield tuple(pool[i] for i in indices)

##################################################################################################
##################################################################################################


main()
