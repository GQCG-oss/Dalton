#GENERATING TENSOR PERMUTATIONS
#AUTHOR: PATRICK ETTENHUBER
#EMAIL : pett@chem.au.dk, pettenhuber@gmail.com
#DATE  : JUNE, 2013
import sys,datetime,math,itertools,os
abc = "abcdefghijklmnopqrstuvwxyz"


#GET THE FOLDER TO STORE THE manual_reorderings.F90
cwd = os.getcwd()
lsutildir = cwd
if ("LSDALTON" in lsutildir ):
  lsutildir = lsutildir[0:lsutildir.find("LSDALTON")]+"/LSDALTON/lsutil/"
else:
  for paths,dirs,files in os.walk(cwd+"/.."):
    if("LSDALTON" in paths):
      lsutildir = paths[0:paths.find("LSDALTON")]+"/LSDALTON/lsutil/"
  if not os.path.exists(lsutildir):
    print "COULD NOT FIND LSDALTON/lsutil, exiting"
    sys.exit()


#THIS FILE SHOULD GENERATE ALL REORDERINGS NEEDED in manual_reorderings.F90
#try:
   #IF THE FILE EXISTS SKIP THE GENERATION
#   with open(lsutildir+"manual_reorderings.F90"): pass
#except IOError:
if(not os.path.exists(lsutildir+"manual_reorderings.F90")):
   maxr = 4
   minr = 2
   f=open(lsutildir+"manual_reorderings.F90",'w')
    
   #WRITE HEADER AND MODULE
   now = datetime.datetime.now()
   f.write("!\> \\brief this autogenerated module is inteded to contain high performance reorderings for\n!mutlidimensional arrays.\n!\> \\author Patrick Ettenhuber & Janus Juul Eriksen\n!\> \\date November 2012, file produced: "+str(now.month)+", "+str(now.year)+"\n")
   f.write("module manual_reorderings_module\n")
   f.write("  use precision\n")
   f.write("  use memory_handling\n")
   f.write("  use LSTIMING\n")
   f.write("  contains\n")
   #Write the subroutines called by the user
   basic = open(lsutildir+"/autogen/reorder_header.F90",'r')
   for line in basic:
     f.write(line)
   basic.close
   
   #SPECIFY THE ORDER OF REODERINGS
   for modes in range(maxr,minr-1,-1):
   
     # GENERATE ORIGINAL ORDER AND STARTING POINT FOR NEW ORDER
     idxarr = [0]*modes
     for i in range(modes):
       idxarr[i] = i
   
     #GET ALL PERMUTATION
     all_permutations=itertools.permutations(idxarr)
    
     #LOOP OVER PERMUTATIONS AND WRITE SUBROUTINES
     for perm in all_permutations:
       #CHECK IF THE ORDERING IS NECESSARY, ELSE JUST SKIP IT
       doreord = True
       for i in range(len(perm)-1):
         if(perm[i]+1==perm[i+1]):
           doreord = False
       if not doreord :
         continue

       # WRITE THE SUBROUTINE
       reordstr1 = ""
       reordstr2 = ""
       reordstr3 = ""
       for i in range(modes):
         reordstr1 += str(perm[i]+1)
         reordstr2 += "dims("+str(idxarr[i]+1)+"),"
         reordstr3 += "dims("+str(perm[i]+1)+"),"
       reordstr2 = reordstr2[0:-1]
       reordstr3 = reordstr3[0:-1]
       subroutinename =  "manual_"+reordstr1+"_reordering"
     
       #GET THE SUBROUTINE HEADER
       subheaderstr= "  !\> \\brief reorder a "+str(modes)+" diensional array  to get the indices\n"
       subheaderstr+= "  !   in the order "+reordstr1+" , this is a quite expensive reordering\n"
       subheaderstr+= "  !   and thus requires additional attention \n"
       subheaderstr+= "  !\> \\autor Patrick Ettenhuber\n"
       subheaderstr+= "  !\> \date "+str(now.month)+", "+str(now.year)+"\n"
       subheaderstr+= "  subroutine "+subroutinename+"(bs,dims,pre1,array_in,pre2,array_out)\n"
       subheaderstr+= "    implicit none\n"
       subheaderstr+= "    !> input for the block size in tiled reordering\n"
       subheaderstr+= "    integer, intent(in) :: bs\n"
       subheaderstr+= "    !>  the dimensions of the different modes in the original array\n"
       subheaderstr+= "    integer, intent(in) :: dims("+str(modes)+")\n"
       subheaderstr+= "    !> as this routine can be used for adding and scaling these are the prefactors\n"
       subheaderstr+= "    real(realk),intent(in) :: pre1,pre2\n"
       subheaderstr+= "    !> array to be reordered\n"
       subheaderstr+= "    real(realk),intent(in) :: array_in("+reordstr2+")\n"
       subheaderstr+= "    !> reordered array\n"
       subheaderstr+= "    real(realk),intent(inout) :: array_out("+reordstr3+")\n"
       subheaderstr+= "    integer :: bcntr,"
       for i in range(modes):
         subheaderstr+= abc[i]+",b"+abc[i]+",d"+abc[i]+",d"+abc[i]+"2,"
       subheaderstr = subheaderstr[0:-1]
       subheaderstr += "\n"
       subheaderstr+= "    logical :: "
       for i in range(modes):
         subheaderstr+= "mod"+abc[i]+","
       subheaderstr = subheaderstr[0:-1]
       subheaderstr += "\n\n"
       for i in range(modes):
         subheaderstr+= "    d"+abc[i]+"=dims("+str(i+1)+")\n"
       subheaderstr+= "\n"
       for i in range(modes):
         subheaderstr+= "    d"+abc[i]+"2=(d"+abc[i]+"/bs)*bs\n"
       subheaderstr+= "\n"
       for i in range(modes):
         subheaderstr+= "    mod"+abc[i]+"=(mod(d"+abc[i]+",bs)>0)\n"
       subheaderstr+= "    bcntr=bs-1\n"

       f.write(subheaderstr)
       #GENERAL CASE pre1/=1 pre2/=0 or 1
       cases = ["pre2 == 0.0E0_realk .and. pre1 == 1.0E0_realk"]
       cases.append("pre2 == 0.0E0_realk .and. pre1 /= 1.0E0_realk")
       cases.append("pre2 == 1.0E0_realk .and. pre1 == 1.0E0_realk")
       cases.append("pre2 == 1.0E0_realk .and. pre1 /= 1.0E0_realk")
       cases.append("pre2 /= 1.0E0_realk .and. pre1 == 1.0E0_realk")
       cases.append("pre2 /= 1.0E0_realk .and. pre1 /= 1.0E0_realk")
       #write sfuff for all the cases above
       for cas in range(len(cases)):
         if(cas==0):
           f.write("\n    precase: if("+cases[cas]+")then\n")
         else:
           f.write("\n    elseif("+cases[cas]+")then\n")
   
         #WRITE OMP PARALLEL STATEMENT HERE
         omppar ="      !$OMP PARALLEL DEFAULT(NONE),PRIVATE("
         for j in range(modes):
           omppar += abc[j]+",b"+abc[j]+","
         omppar = omppar[0:-1] + ")&\n      !$OMP& SHARED(bcntr,pre1,pre2,bs,array_in,array_out, &\n      !$OMP& "
         for j in range(modes):
           omppar += "d"+abc[j] +",d"+abc[j]+"2,mod"+abc[j]+","
         omppar = omppar[0:-1]+")\n"
         
         f.write("#ifndef VAR_LSESSL\n")
         f.write(omppar)
         f.write("#endif\n")
       
         #get the batched space
         casecounter = 1
         for i in range(modes+1):
           #FIND THE RESTRICTED INDICES IN THE OLD ORDERING
           all_thingys = itertools.combinations(idxarr,i)
           for oldr in all_thingys:
   
             label1 = "r"+str(casecounter)
             label1 = ""
             casecounter += 1
             #get conditions for the reordering
             conditions = []
             oldu  = []
             newu  = []
             newr  = []
             for j in range(modes):
               oldu.append(idxarr[j])
               newu.append(perm[j])
               newr.append(perm[j])
               conditions.append("d"+abc[j]+"2>0")
   
             #modify the conditions accordingly
             for j in  range(len(oldr)):
               conditions[oldr[j]] = "mod"+abc[oldr[j]]
               for k in range(len(oldu)):
                 if oldu[k] == oldr[j]:
                   del oldu[k]
                   break
               for k in range(len(newu)):
                 if newu[k] == oldr[j]:
                   del newu[k]
                   break
             for j in  range(len(oldu)):
               for k in range(len(newr)):
                 if newr[k] == oldu[j]:
                   del newr[k]
                   break
             
             #Build if-statement for current restrictions
             conditionalstatement = "      "+label1+"if("
             for j in range(len(conditions)):
               conditionalstatement += conditions[j]
               if j != len(conditions)-1:
                 conditionalstatement+=".and."
             conditionalstatement += ")then\n"
             f.write(conditionalstatement)
         
             #WRITE OMP DO STUFF HERE
             if(modes-len(oldr)>0):
               ompdo ="        !$OMP DO" 
               if (modes-len(oldr)>1):
                 ompdo += " COLLAPSE("+str(modes-len(oldr))+")\n"
               else:
                 ompdo += "\n"
               f.write("#ifndef VAR_LSESSL\n")
               f.write(ompdo)
               f.write("#endif\n")
   
             #ORDER THE LOOPS, this depends on the architecture and may be modified
             #THESE CONDITIONS ARE SET UP FOR INTEL, please adapt whenever a different compiler/architecture is used
             useold = False
             for j in range(len(oldu)):
               if(idxarr[oldu[j]]<perm[newu[j]]):
                 useold = True
                 break
               elif(idxarr[oldu[j]]>perm[newu[j]]):
                 useold =False
                 break
               
             #f.write("!"+str(newu)+"    "+str(oldu)+"\n")
             #f.write("!useold "+str(useold)+"\n")
             #BUILD THE ORDER OF THE LOOPS ACCORDING TO THE PREVIOUS CONDITIONS
             outer =[]
             inner =[]
             for j in range(len(perm)):
               if useold:
                 inner.append(idxarr[j])
               else:
                 inner.append(perm[j])
             
             if useold:
               for j in range(len(oldu)):
                 outer.append(oldu[j])
             else:
               for j in range(len(newu)):
                 outer.append(newu[j])
             inneri = []
             outeri = []
             for j in reversed(inner):
               inneri.append(j)
             for j in reversed(outer):
               outeri.append(j)
           
   
             #WRITING THE OUTER FOR LOOPS HERE:
             offsetstr="        "
             for j in  range(len(outeri)):
               f.write(offsetstr+"do b"+abc[outeri[j]]+"=1,d"+abc[outeri[j]]+"2,bs\n")
               offsetstr += "  "
             offsetstr = offsetstr[0:-2]
             
             f.write("\n")
            
             offsetstr2 = offsetstr + "  "
             #WRITING THE INNER FOR LOOPS HERE:
             for j in range(modes):
               if(inneri[j] in newr):
                 f.write(offsetstr2+"do "+abc[inneri[j]]+"=d"+abc[inneri[j]]+"2+1,d"+abc[inneri[j]]+"\n")
               elif(inneri[j] in newu):
                 f.write(offsetstr2+"do "+abc[inneri[j]]+"=0,bcntr\n")
               else:
                 print "FUCKING INVALID STUFF HAPPENING HERE"
               offsetstr2 += "  "
   
             offsetstr2 = offsetstr2[0:-2]
             
             #CENTRAL COPYING AND ADDITION STRING
             newidx = ""
             oldidx = ""
             for j in range(modes):
               if(perm[j] in newu):
                 newidx += "b"+abc[perm[j]]+"+"+abc[perm[j]]+","
               elif(perm[j] in newr):
                 newidx += abc[perm[j]]+","
               else:
                 print "FUCKING INVALID STUFF HAPPENING HERE"
               if(idxarr[j] in newu):
                 oldidx += "b"+abc[idxarr[j]]+"+"+abc[idxarr[j]]+","
               elif(idxarr[j] in newr):
                 oldidx += abc[idxarr[j]]+","
               else:
                 print "FUCKING INVALID STUFF HAPPENING HERE"
             newidx = newidx[0:-1]
             oldidx = oldidx[0:-1]
   
             cpstr=offsetstr2+"  array_out("
             if cas == 0:
               cpstr += newidx+")=array_in("+oldidx+")\n"
             elif cas==1:
               cpstr += newidx+")=pre1*array_in("+oldidx+")\n"
             elif cas==2:
               cpstr += newidx+")=array_out("+newidx+")&\n                                                  &+array_in("+oldidx+")\n"
             elif cas==3:
               cpstr += newidx+")=array_out("+newidx+")&\n                                                  &+pre1*array_in("+oldidx+")\n"
             elif cas==4:
               cpstr += newidx+")=pre2*array_out("+newidx+")&\n                                                  &+array_in("+oldidx+")\n"
             elif cas==5:
               cpstr += newidx+")=pre2*array_out("+newidx+")&\n                                                  &+pre1*array_in("+oldidx+")\n"
    
             f.write(cpstr)
             
   
             for j in  range(modes-1,-1,-1):
               f.write(offsetstr2+"enddo\n")
               offsetstr2 = offsetstr2[0:-2]
   
             f.write("\n")
   
             #WRITING THE OUTER ENDOFOR HERE:
             for j in  range(modes-len(oldr)-1,-1,-1):
               f.write(offsetstr+"enddo\n")
               offsetstr = offsetstr[0:-2]
   
             if(modes-len(oldr)> 0):
               ompdo ="        !$OMP END DO NOWAIT\n" 
               f.write("#ifndef VAR_LSESSL\n")
               f.write(ompdo)
               f.write("#endif\n")
   
             conditionalstatement="      endif "+label1+"\n"
             f.write(conditionalstatement)
             
           if(i==modes-1):
             ompdo = "      !$OMP END PARALLEL\n"
             f.write("#ifndef VAR_LSESSL\n")
             f.write(ompdo)
             f.write("#endif\n")
      
         if(cas==5):
           f.write("    endif precase\n")
   
       #END THE SUBROUTINE
       f.write("  end subroutine "+subroutinename+"\n\n")
   
   f.write("end module manual_reorderings_module")
   f.close()
