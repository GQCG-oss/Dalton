!> @file
!> here the one sided wrappers should go, so that interfacing with
!different rma vendors is possible
!> \author Patrick Ettenhuber
!> \date April 2013
module lspdm_basic_module
  use precision
  use LSTIMING!,only:lstimer
  use memory_handling
#ifdef VAR_MPI
  use infpar_module
  use lsmpi_type
#endif
  use reorder_frontend_module
  use tensor_type_def_module

  interface get_tile_dim
    module procedure get_tileinfo_nels_frombas,&
                    &get_tileinfo_nelspmode_frombas,&
                    &get_tileinfo_nels_fromarr8,&
                    &get_tileinfo_nels_fromarr4,&
                    &get_tileinfo_nels_fromarr8mode,&
                    &get_tileinfo_nels_fromarr4mode,&
                    &get_tileinfo_nelspermode_fromarr4mode,&
                    &get_tileinfo_nelspermode_fromarr8mode,&
                    &get_tileinfo_nelspermode_fromarr4,&
                    &get_tileinfo_nelspermode_fromarr8
  end interface get_tile_dim

  !interface get_tile_idx
  !  module procedure get_tile_idx_from_global_idx
  !end interface get_tile_idx

  contains
  !subroutine get_tile_idx_from_global_idx()
  !  implicit none
  !end subroutine get_tile_idx_from_global_idx

  

  subroutine get_tileinfo_nels_frombas(sze,tileidx,dims,tdim,mode,offset)
    implicit none
    integer, intent(out) :: sze
    integer,intent(in) :: tileidx,mode,dims(mode),tdim(mode)
    integer,intent(in),optional :: offset
    integer :: j,orig_addr(mode),offs,ntpm(mode)
    offs=1
    if(present(offset))offs=offset
    do j=1,mode
      ntpm(j)=dims(j)/tdim(j)
      if(mod(dims(j),tdim(j))>0)ntpm(j)=ntpm(j)+1
    enddo
    call get_midx(tileidx,orig_addr,ntpm,mode)
    sze=1
    do j=offs, mode
      if(((dims(j)-(orig_addr(j)-1)*tdim(j))/tdim(j))>=1)then
        sze=sze*tdim(j)
      else
        sze=sze*mod(dims(j),tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nels_frombas

  !> \author Patrick Ettenhuber
  subroutine get_tileinfo_nels_fromarr8mode(nels,arr,orig_addr)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global mode index of the tile
    integer(kind=long), intent(in) :: orig_addr(arr%mode)
    !> return value, number of elements in the desired tile
    integer :: nels
    integer ::j
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels=nels*arr%tdim(j)
      else
        nels=nels*mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nels_fromarr8mode
  !> \author Patrick Ettenhuber
  subroutine get_tileinfo_nels_fromarr4mode(nels,arr,orig_addr)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global mode index of the tile
    integer(kind=4), intent(in) :: orig_addr(arr%mode)
    !> return value, number of elements in the desired tile
    integer :: nels
    integer ::j
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels=nels*arr%tdim(j)
      else
        nels=nels*mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nels_fromarr4mode

  !> \brief this function returns the number of elements of a tile where the tile index is
  ! a global tile index
  !> \author Patrick Ettenhuber
  subroutine get_tileinfo_nels_fromarr8(nels,arr,tnumber)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global tile index for which nels should be calculated
    integer(kind=long), intent(in) :: tnumber
    !> return value, number of elements in the desired tile
    integer :: nels
    integer ::orig_addr(arr%mode),j
    call get_midx(tnumber,orig_addr,arr%ntpm,arr%mode)
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels=nels*arr%tdim(j)
      else
        nels=nels*mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nels_fromarr8

  subroutine get_tileinfo_nels_fromarr4(nels,arr,tnumber)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global tile index for which nels should be calculated
    integer(kind=4), intent(in) :: tnumber
    !> return value, number of elements in the desired tile
    integer :: nels
    integer ::orig_addr(arr%mode),j
    call get_midx(tnumber,orig_addr,arr%ntpm,arr%mode)
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels=nels*arr%tdim(j)
      else
        nels=nels*mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nels_fromarr4

  subroutine get_tileinfo_nelspermode_fromarr8(nels,arr,tnumber)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global tile index for which nels should be calculated
    integer(kind=long), intent(in) :: tnumber
    !> return value, number of elements in the desired tile
    integer :: nels(arr%mode)
    integer ::orig_addr(arr%mode),j
    call get_midx(tnumber,orig_addr,arr%ntpm,arr%mode)
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels(j)=arr%tdim(j)
      else
        nels(j)=mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nelspermode_fromarr8

  subroutine get_tileinfo_nelspermode_fromarr4mode(nels,arr,orig_addr)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global tile index for which nels should be calculated
    integer(kind=4), intent(in) :: orig_addr(arr%mode)
    !> return value, number of elements in the desired tile
    integer :: nels(arr%mode)
    integer ::j
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels(j)=arr%tdim(j)
      else
        nels(j)=mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nelspermode_fromarr4mode
  subroutine get_tileinfo_nelspermode_fromarr8mode(nels,arr,orig_addr)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global tile index for which nels should be calculated
    integer(kind=long), intent(in) :: orig_addr(arr%mode)
    !> return value, number of elements in the desired tile
    integer :: nels(arr%mode)
    integer ::j
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels(j)=arr%tdim(j)
      else
        nels(j)=mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nelspermode_fromarr8mode
  subroutine get_tileinfo_nelspermode_fromarr4(nels,arr,tnumber)
    implicit none
    !> array for which nels shoulb be calculated
    type(tensor),intent(in) :: arr
    !> global tile index for which nels should be calculated
    integer(kind=4), intent(in) :: tnumber
    !> return value, number of elements in the desired tile
    integer :: nels(arr%mode)
    integer ::orig_addr(arr%mode),j
    call get_midx(tnumber,orig_addr,arr%ntpm,arr%mode)
    nels=1
    do j=1, arr%mode
      if(((arr%dims(j)-(orig_addr(j)-1)*arr%tdim(j))/arr%tdim(j))>=1)then
        nels(j)=arr%tdim(j)
      else
        nels(j)=mod(arr%dims(j),arr%tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nelspermode_fromarr4

  subroutine get_tileinfo_nelspmode_frombas(sze,tileidx,dims,tdim,mode)
    implicit none
    integer,intent(in) :: tileidx,mode,dims(mode),tdim(mode)
    integer, dimension(mode),intent(out) :: sze
    integer :: j,orig_addr(mode),ntpm(mode)
    do j=1,mode
      ntpm(j)=dims(j)/tdim(j)
      if(mod(dims(j),tdim(j))>0)ntpm(j)=ntpm(j)+1
    enddo
    call get_midx(tileidx,orig_addr,ntpm,mode)
    do j=1, mode
      if(((dims(j)-(orig_addr(j)-1)*tdim(j))/tdim(j))>=1)then
        sze(j)=tdim(j)
      else
        sze(j)=mod(dims(j),tdim(j))
      endif
    enddo
  end subroutine get_tileinfo_nelspmode_frombas

  subroutine memory_deallocate_window(arr)
    implicit none
    type(tensor),intent(inout) :: arr
    real(realk) :: vector_size
    real(realk) :: tcpu1,twall1,tcpu2,twall2
    integer :: i,ierr

    call LSTIMER('START',tcpu1,twall1,lspdm_stdout)

    !call memory_deallocate_array(arr)
    if(associated(arr%wi)) then


#ifdef VAR_MPI
       do i=1,arr%nwins
          call lsmpi_win_free(arr%wi(i))
       enddo
#else
       print *,"THIS MESSAGE SHOULD NEVER APPEAR,WHY ARE MPI_WINs ALLOCD?"
#endif

       vector_size = dble(arr%nwins)
       call mem_dealloc(arr%wi)
       !$OMP CRITICAL
       tensor_aux_deallocd_mem = tensor_aux_deallocd_mem + vector_size
       tensor_memory_in_use = tensor_memory_in_use - vector_size
       !$OMP END CRITICAL

       arr%nwins = 0

    endif

    call LSTIMER('START',tcpu2,twall2,lspdm_stdout)

 end subroutine memory_deallocate_window

  subroutine memory_allocate_window(arr,nwins)
    implicit none
    type(tensor),intent(inout) :: arr
    integer, intent(in), optional :: nwins
    real(realk) :: vector_size
    real(realk) :: tcpu1,twall1,tcpu2,twall2
    integer :: n

    call LSTIMER('START',tcpu1,twall1,lspdm_stdout)

    !call memory_deallocate_array(arr)
    if(associated(arr%wi)) then
      call lsquit("ERROR(memory_allocate_window):array already initialized, please free first",-1)
    endif

    if(present(nwins))then
       arr%nwins = nwins
    else
       arr%nwins = arr%ntiles
    endif

    vector_size = dble( arr%nwins )
   
    call mem_alloc( arr%wi, arr%nwins )

    !print *,infpar%lg_mynum,"mem update"
!$OMP CRITICAL
    tensor_aux_allocd_mem = tensor_aux_allocd_mem + vector_size
    tensor_memory_in_use = tensor_memory_in_use + vector_size
    tensor_max_memory = max(tensor_max_memory,tensor_memory_in_use)
!$OMP END CRITICAL

    call LSTIMER('START',tcpu2,twall2,lspdm_stdout)

  end subroutine memory_allocate_window

  !> \brief Allocate memory for general arrays with memory statistics and tiled
  !structure of the data
  !> \author Patrick Ettenhuber 
  subroutine memory_allocate_tiles(arr)
    implicit none
    type(tensor) :: arr
    real(realk) :: vector_size
    real(realk) :: tcpu1,twall1,tcpu2,twall2
    integer(kind=long) :: i,counter
    integer :: j,loc_idx
    integer, pointer :: idx(:)
    integer(kind=ls_mpik) :: ibuf(2)
    logical :: doit=.true.,lg_master
    integer(kind=ls_mpik) :: lg_me,lg_nnod,pc_me,pc_nnod
    integer(kind=8)       :: ne,from,tooo
    lg_master = .true.
    lg_nnod   = 1
    lg_me     = 0


#ifdef VAR_MPI
    lg_nnod   = infpar%lg_nodtot
    lg_me     = infpar%lg_mynum
    lg_master = (infpar%master==lg_me)
#else
    call lsquit("Do not use MPI-WINDOWS wihout MPI",lspdm_errout)
#endif

    !get zero dummy matrix in size of largest tile --> size(dummy)=tsize
    if( alloc_in_dummy )then
       call memory_allocate_dummy(arr, arr%tsize*arr%nlti)
#ifdef VAR_MPI
       call memory_allocate_window(arr,nwins = 1)
       call lsmpi_win_create(arr%dummy,arr%wi(1),arr%tsize*arr%nlti,infpar%lg_comm) 
#endif
    else
       call memory_allocate_dummy(arr)
       !prepare the integer window in the array --> ntiles windows should be created
       call memory_allocate_window(arr)
    endif

    call LSTIMER('START',tcpu1,twall1,lspdm_stdout)
    call mem_alloc(idx,arr%mode)

    !write(*,'(I2," in here and nlti ",I5)'),infpar%lg_mynum,arr%nlti
    allocate(arr%ti(arr%nlti))

    vector_size = dble(size(arr%ti))
    !$OMP CRITICAL
    tensor_aux_allocd_mem = tensor_aux_allocd_mem + vector_size
    tensor_memory_in_use  = tensor_memory_in_use  + vector_size
    !$OMP END CRITICAL
    counter = 1 
    !allocate tiles with zeros wherever there is mod --> this is experimental
    !and not recommended
    if(arr%zeros)then
      do i=1,arr%ntiles
        doit=.true.
#ifdef VAR_MPI
        if(.not.mod(i+arr%offset,infpar%lg_nodtot)==infpar%lg_mynum)doit=.false.
#endif
        if(doit)then
           call mem_alloc(arr%ti(counter)%t,arr%tsize)
           call mem_alloc(arr%ti(counter)%d,arr%mode)
           if( tensor_debug_mode )then
              arr%ti(counter)%t=0.0E0_realk
           endif
           arr%ti(counter)%e=arr%tsize
           vector_size = dble(arr%ti(counter)%e)*realk
           !$OMP CRITICAL
           tensor_tiled_allocd_mem = tensor_tiled_allocd_mem + vector_size
           tensor_memory_in_use    = tensor_memory_in_use    + vector_size
           vector_size             = dble(size(arr%ti(counter)%d))
           tensor_aux_allocd_mem   = tensor_aux_allocd_mem   + vector_size
           tensor_memory_in_use    = tensor_memory_in_use    + vector_size
           tensor_max_memory       = max(tensor_max_memory,tensor_memory_in_use)
           !$OMP END CRITICAL
           do j=1,arr%mode
              arr%ti(counter)%d(j)=arr%tdim(j)
           enddo
           counter = counter +1
        endif
     enddo
     !allocate tiles with the rim-tiles of mod dimensions
  else

      do i=1,arr%ntiles

        !Check if the current tile resides on the current node
        doit=.true.
#ifdef VAR_MPI
        if(arr%itype==TT_TILED_DIST.and.mod(i-1+arr%offset,lg_nnod)/=lg_me)doit=.false.
#endif
        !convert global tile index i to local tile index loc_idx
        loc_idx=((i-1)/lg_nnod) + 1
        if (arr%itype==TT_TILED) loc_idx=i 
         
        if(doit)then
          !only do these things if tile belongs to node
          !save global tile number
          arr%ti(loc_idx)%gt=i
          
          call mem_alloc(arr%ti(loc_idx)%d,arr%mode)
          vector_size = dble(size(arr%ti(loc_idx)%d))
          !$OMP CRITICAL
          tensor_aux_allocd_mem = tensor_aux_allocd_mem + vector_size
          tensor_memory_in_use  = tensor_memory_in_use  + vector_size
          !$OMP END CRITICAL

          !get the actual tile size of current tile, here the index is per
          !mode
          call get_tile_dim(arr%ti(loc_idx)%d,arr,i)
          !calculate the number of elements from the tile dimensions
          arr%ti(loc_idx)%e=1
          do j=1,arr%mode
            arr%ti(loc_idx)%e=arr%ti(loc_idx)%e*arr%ti(loc_idx)%d(j)
          enddo

#ifdef VAR_MPI
         if( alloc_in_dummy )then
            from = (loc_idx-1)*arr%tsize + 1
            tooo = (loc_idx-1)*arr%tsize + arr%ti(loc_idx)%e
            arr%ti(loc_idx)%t => arr%dummy(from:tooo)
         else
            call mem_alloc(arr%ti(loc_idx)%t,arr%ti(loc_idx)%c,arr%ti(loc_idx)%e)
            vector_size = dble(arr%ti(loc_idx)%e)*realk
            !$OMP CRITICAL
            tensor_tiled_allocd_mem = tensor_tiled_allocd_mem + vector_size
            tensor_memory_in_use    = tensor_memory_in_use + vector_size
            tensor_max_memory       = max(tensor_max_memory,tensor_memory_in_use)
            !$OMP END CRITICAL
            call lsmpi_win_create(arr%ti(loc_idx)%t,arr%wi(i),arr%ti(loc_idx)%e,infpar%lg_comm) 
         endif


         if( tensor_debug_mode )then
            arr%ti(loc_idx)%t=0.0E0_realk
         endif
#endif

          counter = counter +1
        else

         !open a window of size zero on the nodes where the tile does not
         !reside
#ifdef VAR_MPI
          if( .not. alloc_in_dummy  )call lsmpi_win_create(arr%dummy,arr%wi(i),0,infpar%lg_comm)
#endif
        endif
#ifdef VAR_MPI
        ! fence the window in preparation for comm
        if( .not. alloc_in_dummy )call lsmpi_win_fence(arr%wi(i),.true.)
#endif
      enddo
    endif
    call mem_dealloc(idx)

    if(counter-1/=arr%nlti)then
      print*," counted wrong of node",lg_me,lg_nnod,counter-1,arr%nlti,arr%ntiles,arr%offset
      call lsquit("something went wrong with the numbering of tiles on the nodes",lspdm_errout)
    endif
    call LSTIMER('START',tcpu2,twall2,lspdm_stdout)

  end subroutine memory_allocate_tiles

    subroutine memory_allocate_dummy(arr,nel)
      implicit none
      type(tensor),intent(inout) :: arr
      integer, intent(in),optional :: nel
      integer(kind=8) :: nelms
      real(realk)     :: vector_size
      real(realk)     :: tcpu1,twall1,tcpu2,twall2
      integer(kind=8) :: ne

      call LSTIMER('START',tcpu1,twall1,lspdm_stdout)

      if(associated(arr%dummy)) then
        call lsquit("ERROR(memory_allocate_dummy):array already initialized, please free first",lspdm_errout)
      endif
      if(present(nel))then
        nelms=nel
      else
        nelms=arr%tsize
      endif

      vector_size = dble(nelms)*realk

#ifdef VAR_MPI
      if( lspdm_use_comm_proc )then
        ne = 0_long
        if(infpar%pc_mynum==infpar%pc_nodtot-1) ne = arr%nelms
        call mem_alloc(arr%dummy,arr%dummyc,ne,arr%dummyw,infpar%pc_comm,nelms)
      else
        call mem_alloc(arr%dummy,arr%dummyc,nelms)
      endif

      if( tensor_debug_mode )then
         arr%dummy = 0.0E0_realk
      endif
#endif

      !$OMP CRITICAL
      tensor_aux_allocd_mem = tensor_aux_allocd_mem + vector_size
      tensor_memory_in_use = tensor_memory_in_use + vector_size
      tensor_max_memory = max(tensor_max_memory,tensor_memory_in_use)
      !$OMP END CRITICAL

      call LSTIMER('START',tcpu2,twall2,lspdm_stdout)

    end subroutine memory_allocate_dummy

    subroutine memory_deallocate_dummy(arr)
      implicit none
      type(tensor) :: arr
      real(realk) :: vector_size
      real(realk) :: dim1
      real(realk) :: tcpu1,twall1,tcpu2,twall2

      call LSTIMER('START',tcpu1,twall1,lspdm_stdout)

      if(associated(arr%dummy)) then
         dim1 = dble(size(arr%dummy(:)))
         vector_size = dim1*realk
#ifdef VAR_MPI
         call mem_dealloc(arr%dummy,arr%dummyc)
#endif
         nullify(arr%dummy)

         !$OMP CRITICAL
         tensor_aux_deallocd_mem = tensor_aux_deallocd_mem + vector_size
         tensor_memory_in_use = tensor_memory_in_use - vector_size
         !$OMP END CRITICAL
      end if

      call LSTIMER('START',tcpu2,twall2,lspdm_stdout)


    end subroutine memory_deallocate_dummy


    subroutine tensor_pdm_free_special_aux(arr)
      implicit none
      type(tensor), intent(inout) :: arr
      call memory_deallocate_window(arr)
      call memory_deallocate_dummy(arr)
    end subroutine tensor_pdm_free_special_aux

    
    subroutine get_residence_of_tile(rank_of_node,globaltilenumber,arr,pos_on_node,idx_on_node)
       implicit none
       integer, intent(out) :: rank_of_node
       type(tensor), intent(in) :: arr
       integer,intent(in) :: globaltilenumber
       integer, intent(out), optional :: pos_on_node, idx_on_node
       integer :: nnod, pos, idx

       nnod=1
#ifdef VAR_MPI
       nnod=infpar%lg_nodtot
#endif      

       rank_of_node = mod(globaltilenumber-1+arr%offset,nnod)

       pos          = (globaltilenumber-1)/nnod + 1

       idx          = 1 + ( pos - 1 ) * arr%tsize
       !Return the node local index of the tile
       if(present(pos_on_node)) pos_on_node = pos
       if(present(idx_on_node)) idx_on_node = idx
    end subroutine get_residence_of_tile


end module lspdm_basic_module
