!> @file
!> Contains the main Ichor screening integral drivers for calculation electron repulsion screening integrals
!> Ichor is the "Integral Code Hand Optimized for Rapid evaluation" 
!> Ichor is the ethereal golden fluid that is the blood of the greek gods

!> \brief Main Ichor drivers for the calculation of screening integrals 
!> based on the Obara Saika(OS)/Head-Gordon-Pople(HGP)
!> \author T. Kjaergaard
!> \date 2013 
MODULE IchorGabmodule
  use IchorprecisionModule
  use IchorBatchToolsModule
  use IchorCommonModule
  use IchorEriGabintegralOBSGeneralMod, only: IchorGabIntegral_OBS_general, &
       & IchorGabIntegral_OBS_general_size
  use IchorMemory
  use IchorGammaTabulationModule
  use IchorParametersModule
!debugging
  use IchorEriCoulombintegralOBSGeneralMod, only: IchorCoulombIntegral_OBS_general

public :: IchorGab
private
CONTAINS

subroutine IchorGab(nTypesA,MaxNatomsA,MaxnPrimA,MaxnContA,&
     & AngmomOfTypeA,nAtomsOfTypeA,nPrimOfTypeA,nContOfTypeA,&
     & startOrbitalOfTypeA,Acenters,exponentsOfTypeA,ContractCoeffOfTypeA,&
     & nTypesB,MaxNatomsB,MaxnPrimB,MaxnContB,&
     & AngmomOfTypeB,nAtomsOfTypeB,nPrimOfTypeB,nContOfTypeB,&
     & startOrbitalOfTypeB,Bcenters,exponentsOfTypeB,ContractCoeffOfTypeB,&
     & SphericalSpec,IchorJobSpec,IchorInputSpec,IchorInputDim1,&
     & IchorInputDim2,IchorInputDim3,&
     & InputStorage,IchorParSpec,IchorScreenSpec,IchorDebugSpec,&
     & IchorAlgoSpec,SameLHSaos,filestorageIdentifier,MaxMem,&
     & MaxFileStorage,MaxMemAllocated,MemAllocated,&
     & OutputDim1,OutputDim2,OutputDim3,OutputDim4,OutputDim5,&
     & OutputStorage,lupri)
implicit none
!> nTypesA is the number of different types of shells, each type is defined by 
!> an angular momentum, a number of primitives(nPrim), a number of contracted functions
!> (nCont) a set of exponents and a set of contraction coefficients. [For Center A]
integer,intent(in) :: nTypesA
!> MaxnAtomsA is the maximum number of Atoms that have the same type. [For Center A]
integer,intent(in) :: MaxnAtomsA
!> MaxnPrim is the maximum number of Primitives among all the types. [For Center A]
integer,intent(in) :: MaxnPrimA
!> MaxnPrim is the maximum number of Contracted functions among all the types. [For Center A]
integer,intent(in) :: MaxnContA
!> AngmomOfTypeA is the angular momentum for each type. [For Center A]
Integer,intent(in) :: AngmomOfTypeA(ntypesA)
!> nAtomsOfTypeA is the number of atoms that have the given type. [For Center A]
Integer,intent(in) :: nAtomsOfTypeA(ntypesA)
!> nPrimOfTypeA is the number of primitive for the given type. [For Center A]
Integer,intent(in) :: nPrimOfTypeA(ntypesA)
!> nContOfTypeA is the number of contracted function for the given type. [For Center A]
Integer,intent(in) :: nContOfTypeA(ntypesA)
!> startorbital for this atom of this type
Integer,intent(in) :: startOrbitalOfTypeA(MaxNatomsA,ntypesA)
!> Acenters is the centers of all the atoms that have the given type. [For Center A]
Real(realk),intent(in) :: Acenters(3,MaxNatomsA,ntypesA)
!> exponentsOfTypeA is the nPrim exponents for the given type. [For Center A]
Real(realk),intent(in) :: exponentsOfTypeA(MaxnprimA,ntypesA)
!> ContractCoeffOfTypeA is the contrction coefficient matrix (nPrim,nCont) for the given type. [For Center A]
Real(realk),intent(in) :: ContractCoeffOfTypeA(MaxnprimA,MaxnContA,ntypesA)
!
! Same for Center B
!
integer,intent(in) :: nTypesB,MaxnAtomsB,MaxnPrimB,MaxnContB
Integer,intent(in) :: AngmomOfTypeB(ntypesB),nAtomsOfTypeB(ntypesB)
Integer,intent(in) :: nContOfTypeB(ntypesB),nPrimOfTypeB(ntypesB),startOrbitalOfTypeB(MaxNatomsB,ntypesB)
Real(realk),intent(in) :: Bcenters(3,MaxNatomsB,ntypesB),exponentsOfTypeB(MaxnprimB,ntypesB)
Real(realk),intent(in) :: ContractCoeffOfTypeB(MaxnprimB,MaxnContB,ntypesB)
!
!> Spherical Specification (SphericalSpec = SphericalParam = 1) means to use Spherical Harmonic basis functions
Integer,intent(in) :: SphericalSpec
!> Job Specification (IcorJob = IcorJobEri = 1) means that the 4 center 2 electron repulsion integrals
!> should be calculated. 
Integer,intent(in) :: IchorJobSpec
!> Input Specification (IchorInputSpec = IcorInputNoInput = 1) means no Input have been provided
Integer,intent(in) :: IchorInputSpec
!> Input dimensions assuming InputStorage(IchorInputDim1,IchorInputDim2,IchorInputDim3)
Integer,intent(in) :: IchorInputDim1,IchorInputDim2,IchorInputDim3
!> InputStorage
real(realk),intent(in) :: InputStorage(IchorInputDim1,IchorInputDim2,IchorInputDim3)
!> Parallelization specification (communicator and other stuff should be set up with other call) 
!> IchorParSpec = IchorParNone = 1 means no parallelization - no OpenMP, no MPI, no GPU
Integer,intent(in) :: IchorParSpec
!> Screening specification 
!> IchorScreenSpec = IchorScreen = 1 means default screening including Cauchy-Schwarz screening and QQR
!> IchorScreenSpec = IchorScreenNone = 2 means no screening
Integer,intent(in) :: IchorScreenSpec
!> Debug info specification 
!> IchorDebugSpec = IchorDebugNone = 1 means no debug info
Integer,intent(in) :: IchorDebugSpec
!> Integral Algorithm specification 
!> IchorAlgoSpec = IchorAlgoOS = 1 means Obara-Saika (Head-Gordon Pople)
Integer,intent(in) :: IchorAlgoSpec
!> Permutation specification (SameLHSaos) 
logical,intent(in) :: SameLHSaos
!> Identifier to determine which file should be used to save integrals on disk, This 
!> should be logical unit number, if zero no file is open. 
Integer,intent(in) :: filestorageIdentifier
!> Maximum Memory that the integral program is allowed to use. Zero means no restrictions 
Integer(kind=long),intent(in) :: MaxMem
!> Maximum File size, if zero - no file will be written or read. 
Integer,intent(in) :: MaxFileStorage
!> Maximum Memory used in the program. The Ichor program adds to this value.  
Integer(kind=long),intent(inout) :: MaxMemAllocated
!> Memory allocated in the program. If the input value is not equal to the output value the
!> there is a memory leak inside the program. 
Integer(kind=long),intent(inout) :: MemAllocated
!> Output dimensions assuming 
!> OutputStorage(OutputDim1,OutputDim2,OutputDim3,OutputDim4,OutputDim5)
Integer,intent(in) :: OutputDim1,OutputDim2,OutputDim3,OutputDim4,OutputDim5
!> OutputStorage
real(realk),intent(inout) :: OutputStorage(OutputDim1,OutputDim2,OutputDim3,OutputDim4,OutputDim5)
!> Logical unit number of output file.
Integer,intent(in) :: lupri
! Local variables
integer :: nPrimP,nContP
integer :: nTABFJW1,nTABFJW2,TotalAngmom
integer :: i12,nPasses,offset,K,I,iPass,MaxPasses,iPrimQ,iPrimP,icont,i2,i1
integer :: ndimPass,oldmaxangmomABCD
integer :: ItypeA,ItypeB,itypeC,itypeD,AngmomA,AngmomB
integer :: ItypeAnon,ItypeBnon,nDimB
integer :: nPrimA,nPrimB,nContA,nAtomsA,nAtomsB,nOrbA,nContB,nOrbCompB
integer :: nDimA,nOrbCompA,iPrimA,iContA,iAtomA,iPrimB,iContB,iAtomB
integer :: INTPRINT,startA,startB,nBatchA,nBatchB,iBatchA,iBatchB,nOrbB
integer,pointer :: OrderdListA(:),OrderdListB(:)
integer,pointer :: BatchIndexOfTypeA(:),BatchIndexOfTypeB(:)
logical :: Psegmented,Spherical
logical :: TriangularLHSAtomLoop, PermuteLHS,PQorder
real(realk) :: CDAB(1)
real(realk),pointer :: expP(:),Pcent(:),PpreExpFac(:)!,CDAB2(:)!,CDAB(:)
REAL(realk),pointer :: TABFJW(:,:),reducedExponents(:),integralPrefactor(:)
Real(realk), parameter :: PIFAC = 34.986836655249725E0_realk !Two*PI**TwoHalf
real(realk) :: Pdistance12(3),e1,e2,X,Y,Z,d2,p,q,p_q
real(realk),pointer :: expA(:),ContractCoeffA(:,:),Acenter(:,:)
real(realk),pointer :: expB(:),ContractCoeffB(:,:),Bcenter(:,:)
integer,pointer :: StartOrbitalA(:),StartOrbitalB(:)
real(realk) :: AcenterSpec(3),BcenterSpec(3)
integer :: TMParray1maxsize,TMParray2maxsize,IAngmomTypes,MaxTotalAngmomAB
!real(realk) :: SYMFAC,SYMFAC2
real(realk),pointer :: TmpArray1(:)
real(realk),pointer :: TmpArray2(:)
INTPRINT=IchorDebugSpec
call set_ichor_memvar(MaxMemAllocated,MemAllocated)
call mem_ichor_alloc(OrderdListA,nTypesA)
call GenerateOrderdListOfTypes(lupri,nTypesA,AngmomOfTypeA,OrderdListA)
call mem_ichor_alloc(OrderdListB,nTypesB)
call GenerateOrderdListOfTypes(lupri,nTypesB,AngmomOfTypeB,OrderdListB)

! GAMMATABULATION 
!     is this needed for (SSSS) ? is it better to build it several times for 
!     different Angmom combis ? 
call mem_ichor_alloc(BatchIndexOfTypeA,nTypesA)
call ConstructBatchIndexOfType(BatchIndexOfTypeA,nTypesA,nAtomsOfTypeA,nBatchA)
IF(nBatchA.NE.OutputDim1)THEN
   CALL ICHORQUIT('Error BATCHGAB dim1 not consistent',-1)
ENDIF

call mem_ichor_alloc(BatchIndexOfTypeB,nTypesB)
call ConstructBatchIndexOfType(BatchIndexOfTypeB,nTypesB,nAtomsOfTypeB,nBatchB)
IF(nBatchB.NE.OutputDim2)THEN
   CALL ICHORQUIT('Error BATCHGAB dim2 not consistent',-1)
ENDIF

IF(SameLHSaos)THEN
   IF(.NOT.(nBatchA.EQ.nBatchB))THEN
      CALL ICHORQUIT('Error IchorGab Screening symmetry error ',-1)
   ENDIF
ENDIF
!call ichorzero2(OutputStorage,OutputDim1*OutputDim2,OutputDim3*OutputDim4*OutputDim5)
!INTRODUCE iAngmomType Loop Like IchorEri.F90 !!!
MaxTotalAngmomAB = MAXVAL(AngmomOfTypeA) + MAXVAL(AngmomOfTypeB)

Spherical = SphericalSpec.EQ.SphericalParam
oldmaxangmomABCD = -25
DO IAngmomTypes = 0,MaxTotalAngmomAB
 DO ItypeBnon=1,nTypesB
  ItypeB = OrderdListB(ItypeBnon)
  AngmomB = AngmomOfTypeB(ItypeB)
  nPrimB = nPrimOfTypeB(ItypeB)
  nContB = nContOfTypeB(ItypeB)
  IF (spherical) THEN
     nOrbCompB = 2*(AngmomB+1)-1
  ELSE
     nOrbCompB = (AngmomB+1)*(AngmomB+2)/2
  ENDIF
  nAtomsB = nAtomsOfTypeB(ItypeB) 

  nOrbB = nContB*nOrbCompB
  nDimB = nOrbB*nAtomsB

  call mem_ichor_alloc(expB,nPrimB)
  call mem_ichor_alloc(ContractCoeffB,nPrimB,nContB)
  call mem_ichor_alloc(Bcenter,3,nAtomsB)
  call mem_ichor_alloc(StartOrbitalB,nAtomsB)
  call build_exp_ContractCoeff_center(nPrimB,nContB,nAtomsB,ntypesB,iTypeB,&
       & exponentsOfTypeB,ContractCoeffOfTypeB,Bcenters,StartOrbitalOfTypeB,&
       & expB,ContractCoeffB,Bcenter,StartOrbitalB,MaxnAtomsB,MaxnprimB,MaxnContB,lupri)
  DO ItypeAnon=1,nTypesA !non ordered loop
   ItypeA = OrderdListA(ItypeAnon)  
   AngmomA = AngmomOfTypeA(ItypeA) 
   IF(AngmomA+AngmomB.EQ.IAngmomTypes)THEN
    IF(SameLHSaos .AND. ItypeB.GT.ItypeA)CYCLE
    TriangularLHSAtomLoop = SameLHSaos .AND. ItypeB.EQ.ItypeA
    nPrimA = nPrimOfTypeA(ItypeA)
    nContA = nContOfTypeA(ItypeA)
    IF (spherical) THEN
       nOrbCompA = 2*(AngmomA+1)-1
    ELSE
       nOrbCompA = (AngmomA+1)*(AngmomA+2)/2
    ENDIF
    nAtomsA = nAtomsOfTypeA(ItypeA)

    nOrbA = nContA*nOrbCompA
    nDimA = nContA*nOrbCompA*nAtomsA
    call mem_ichor_alloc(expA,nPrimA)
    call mem_ichor_alloc(ContractCoeffA,nPrimA,nContA)
    call mem_ichor_alloc(Acenter,3,nAtomsA)
    call mem_ichor_alloc(StartOrbitalA,nAtomsA)
    call build_exp_ContractCoeff_center(nPrimA,nContA,nAtomsA,ntypesA,iTypeA,&
         & exponentsOfTypeA,ContractCoeffOfTypeA,Acenters,StartOrbitalOfTypeA,&
         & expA,ContractCoeffA,Acenter,StartOrbitalA,MaxnAtomsB,MaxnprimA,MaxnContA,lupri) 

    TotalAngmom = AngmomA + AngmomB + AngmomA + AngmomB 
    nPrimP = nPrimA*nPrimB
    nContP = nContA*nContB
    IF (nContP.EQ. 1)THEN
       Psegmented = .TRUE.
    ELSE
       Psegmented = .FALSE.
    ENDIF
    call mem_ichor_alloc(expP,nPrimP)
    call build_expP(nPrimA,nPrimB,expA,expB,expP)
    IF(TotalAngmom.NE.oldmaxangmomABCD)THEN
       IF(oldmaxangmomABCD.NE.-25)THEN
          call mem_ichor_dealloc(TABFJW)
       ENDIF
       nTABFJW1 = AngmomA + AngmomB + AngmomA + AngmomB + 3 
       !only need + 3 after Branos change in BUILD_RJ000 
       nTABFJW2 = 1200
       !TABFJW(0:nTABFJW1,0:nTABFJW2)
       call mem_ichor_alloc(TABFJW,nTABFJW1,nTABFJW2,.TRUE.,.TRUE.)
       CALL GAMMATABULATION(lupri,TotalAngmom,nTABFJW1,nTABFJW2,TABFJW)  
       oldmaxangmomABCD = TotalAngmom
    ENDIF
    !it may be easy to include primitive screening on the LHS here
    call mem_ichor_alloc(reducedExponents,nPrimP*nPrimP)
    call mem_ichor_alloc(integralPrefactor,nPrimP*nPrimP)
    PQorder = .FALSE.
    call build_reducedExponents_integralPrefactorQP(nPrimP,nPrimP,expP,expP,&
         & reducedExponents,integralPrefactor)
    call mem_ichor_alloc(pcent,3*nPrimP)
    call mem_ichor_alloc(PpreExpFac,nPrimP)
    !       call IchorTimer('START',TSTART,TEND,LUPRI)
    call IchorGabIntegral_OBS_general_size(TMParray1maxsize,&
        &TMParray2maxsize,AngmomA,AngmomB,nPrimP,nContP,Psegmented)
    MaxPasses = 1
    !possibly change MaxPasses according to Sizes!
    TMParray1maxsize = TMParray1maxsize
    TMParray2maxsize = TMParray2maxsize
    call mem_ichor_alloc(TmpArray1,TMParray1maxsize)
    call mem_ichor_alloc(TmpArray2,TMParray2maxsize) 

    iBatchB = BatchIndexOfTypeB(ItypeB)
    DO IatomB = 1,nAtomsOfTypeB(ItypeB)
       startB = startOrbitalB(iAtomB)
       iBatchB = iBatchB + 1
       BcenterSpec(1) = Bcenter(1,IatomB)
       BcenterSpec(2) = Bcenter(2,IatomB)
       BcenterSpec(3) = Bcenter(3,IatomB)
       iBatchA = BatchIndexOfTypeA(ItypeA)
       DO IatomA = 1,nAtomsA
          startA = startOrbitalA(iAtomA)
          iBatchA = iBatchA + 1
          IF(TriangularLHSAtomLoop.AND.IatomB.GT.IatomA)CYCLE
          AcenterSpec(1) = Acenter(1,IatomA)
          AcenterSpec(2) = Acenter(2,IatomA)
          AcenterSpec(3) = Acenter(3,IatomA)
          !sort combined atom list with respect to distance ? which distance AB,CD,PQ 
          !only difference is the centers involved. 
          !iPass = IatomA + (IatomB-1)*nAtomsA !for now
          CALL Build_qcent_Qdistance12_QpreExpFac(nPrimA,nPrimB,&
               & nContA,nContB,expA,expB,AcenterSpec,BcenterSpec,ContractCoeffA,&
               & ContractCoeffB,PSegmented,&
               & pcent,Pdistance12,PpreExpFac,INTPRINT)
          nPasses = 1 !nAtomsA*nAtomsB
          call IchorGabIntegral_OBS_general(nPrimA,nPrimB,nPrimP,&
               & nPasses,MaxPasses,intprint,lupri,nContA,nContB,nContP,expP,&
               & ContractCoeffA,ContractCoeffB,&
               & pcent,Ppreexpfac,nTABFJW1,nTABFJW2,TABFJW,&
               & expA,expB,Psegmented,reducedExponents,integralPrefactor,&
               & AngmomA,AngmomB,Pdistance12,PQorder,CDAB,&
               & AcenterSpec,BcenterSpec,Spherical,&
               & TmpArray1,TMParray1maxsize,TmpArray2,TMParray2maxsize)
          OutputStorage(iBatchA,iBatchB,1,1,1) = CDAB(1)
       ENDDO !iAtomB
    ENDDO !iAtomA
    call mem_ichor_dealloc(TmpArray1)
    call mem_ichor_dealloc(TmpArray2)
 
    call mem_ichor_dealloc(pcent)
    call mem_ichor_dealloc(PpreExpFac)

    call mem_ichor_dealloc(reducedExponents)
    call mem_ichor_dealloc(integralPrefactor)

    call mem_ichor_dealloc(expA)
    call mem_ichor_dealloc(ContractCoeffA)
    call mem_ichor_dealloc(Acenter)
    call mem_ichor_dealloc(expP)
    call mem_ichor_dealloc(startOrbitalA)
   ENDIF
  ENDDO !typeA
  call mem_ichor_dealloc(expB)
  call mem_ichor_dealloc(ContractCoeffB)
  call mem_ichor_dealloc(Bcenter)
  call mem_ichor_dealloc(startOrbitalB)
 ENDDO !typeB
ENDDO 
!symmetrize BATCHGAB!
!output requires to zero first otherwise a floating invalid
!WRITE(lupri,*)'The BatchGab NON SYMM'
!call output(OutputStorage,1,nBatchA,1,nBatchB,nBatchA,nBatchB,1,lupri)

IF(SameLHSaos)THEN
   call AddUpperTriAngular(OutputStorage,OutputDim1,lupri)
ENDIF

call mem_ichor_dealloc(TABFJW)
call mem_ichor_dealloc(BatchIndexOfTypeA)
call mem_ichor_dealloc(BatchIndexOfTypeB)
call mem_ichor_dealloc(OrderdListA)
call mem_ichor_dealloc(OrderdListB)

!WRITE(lupri,*)'The BatchGab'
!call output(OutputStorage,1,nBatchA,1,nBatchB,nBatchA,nBatchB,1,lupri)
!call output(OutputStorage,1,nBatchA,1,nBatchB,nBatchA,nBatchB,1,6)
call retrieve_ichor_memvar(MaxMemAllocated,MemAllocated)
!call stats_ichor_mem(lupri)
end subroutine IchorGab

subroutine AddUpperTriAngular(MAT,nBatchA,lupri)
implicit none
integer,intent(in) :: nBatchA,lupri
real(realk),intent(inout) :: MAT(nBatchA,nBatchA)
!
integer :: IA,IB
DO IA = 1,nBatchA
   DO IB = 1,IA-1
      MAT(IB,IA) = MAT(IA,IB)
   ENDDO
ENDDO
end subroutine AddUpperTriAngular
END MODULE IchorGabmodule
