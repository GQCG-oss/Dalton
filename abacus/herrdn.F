C
C...   Copyright (c) 2001 by the authors of Dalton (see below).
C...   All Rights Reserved.
C...
C...   The source code in this file is part of
C...   "Dalton, a molecular electronic structure program, Release 1.2
C...   (2001), written by T. Helgaker, H. J. Aa. Jensen, P. Joergensen,
C...   J. Olsen, K. Ruud, H. Aagren, A.A. Auer, K.L. Bak, V. Bakken,
C...   O. Christiansen, S. Coriani, P. Dahle, E. K. Dalskov,
C...   T. Enevoldsen, B. Fernandez, C. Haettig, K. Hald, A. Halkier,
C...   H. Heiberg, H. Hettema, D. Jonsson, S. Kirpekar, R. Kobayashi,
C...   H. Koch, K. V. Mikkelsen, P. Norman, M. J. Packer,
C...   T. B. Pedersen, T. A. Ruden, A. Sanchez, T. Saue, S. P. A. Sauer,
C...   B. Schimmelpfennig, K. O. Sylvester-Hvid, P. R. Taylor,
C...   and O. Vahtras"
C...
C...   This source code is provided under a written licence and may be
C...   used, copied, transmitted, or stored only in accord with that
C...   written licence.
C...
C...   In particular, no part of the source code or compiled modules may
C...   be distributed outside the research group of the licence holder.
C...   This means also that persons (e.g. post-docs) leaving the research
C...   group of the licence holder may not take any part of Dalton,
C...   including modified files, with him/her, unless that person has
C...   obtained his/her own licence.
C...
C...   For questions concerning this copyright write to:
C...      dalton-admin@kjemi.uio.no
C...
C...   For information on how to get a licence see:
C...      http://www.kjemi.uio.no/software/dalton/dalton.html
C
#include <single.h>
C
#ifdef REVISION_LOG
===========================================================================
Revision 1.9  2000/05/03 10:58:51  hjj
include maxorb.h now needed for molde.h

revision 1.7-1.8 2000/04/28 10:27:31  hjj
 - implemented new normalized s,p,d,f,g,h,i GTO's in SPHINP as default
 - new input option under *READIN: .OLDNORM for using the previous
   normalization of spherical GTO's for reading MO coefficients
   generated by Dalton 1.0
 - reactivated Huckel for Q .le. 36 for spherical GTO's because
   they are now normalized so we will not get the splitting of
   e.g. degenerate d-orbitals any more.
----------------------------
revision 1.6
2000/04/27 10:18:19  hjj
- inserted BN in format statements for reading DOOWN transformation
- inserted BN and changed Fxx.y to Fxx.0 in FMT[123] for readin
  GTO exponents and cont.coeff., now integers will always be read correctly.
----------------------------
revision 1.5 2000/04/27 09:41:47  hjj
Changed input format for DOOWN scheme (CRT .eq. 'X') and inserted some tests.
Improved output of cartesian transformation matrices.
----------------------------
revision 1.4 2000/04/27 07:56:52  hjj
tell users that d, f, ... atomic GTO's are not normalized
(I have had several questions from people comparing MO coefficients from
Dalton with other programs, or comparing AO integrals with other programs).
----------------------------
revision 1.3 2000/04/14 14:09:48  hjj
\hjaaj dec 99-jan 00:
1) corrected printout for Huckel basis when ADDSTO
   (the true basis set name was printed instead of "Huckel")
2) corrected output format from I3 to I4 for .gt. 999 primitives
3) changed ZMATL format from A6 to A1 to give room for change
   of CHARGE format from F4.0 to F9.0; this was done so that
   point charges can be entered with more decimal places.
4) polishing.
----------------------------
revision 1.2 2000/04/12 10:15:14  hjj
MAXPRD was 22 on most machines except T3D and LINUX, where it was 14.
Now LINUX also has MAXPRD = 22, following suggestion by Asger Halkier
e-mail to dalton-wizards 30 Nov 99 /hjaaj
=============================================================================
960705-kr:
-- We use the small component basis for keeping a possible extra STO-3G
   basis needed when using Hueckel initial guess.
951115-hjaaj:
-- no warning for THRS .le. 0 if input field blank
-- implemented free format reads for IRIX (has removed character reads
   which does not work on IRIX and gives nulls on AIX and ?).
CNTINP: removed unused 'NAVN'; always read NAMN with '(A4)' and never
   with free format; if free format doesn't work then try formatted;
ZMAT: Read NAMN with '(A4)', allow free input for IRIX;
   for CRAY formatted input made last field for CHARGE very long;
   removed old END=204 branches which were reminiscences from when
   the input was read directly from file.
BUILDZ: changed format and output of internal coordinates;
   removed printing of zero cartesian coords. before printing of
   the correct cartesian coords.
950428-kr/hjaaj:
BASOUT,ORBOUT: removed NPRIM,NPRIMD,NORB,NORBD in parameter list to
 ORBOUT; we think they are related to an old organization of
 small component basis (before IQM(*,2) etc.)
941219-hjaaj:
BASINP: s/IQMAX/NHTYP/
950208-vebjorn
READI1: NSYMOP is first read as a text to determine if symmetry is to
        be added (indicated by blanks).
SYMINP: Has been moved after BASINP, because symmetry has to be added before
        SYMINP is executed. The full group string CLASS has been added
        as a parameter to the subroutine.
SYMADD: Completely new module that adds symmetry on request from user. The
        full group of the molecule is returned as well.
BASINP: Has been moved above SYMADD and SYMINP. As a result the updating
        of the array ISTBNU had to be moved to BASPRO. As this is processing
        rather than input, the move makes good sense.
BASPRO: Now takes care of the generation of the symmetry-dependant atoms
        through the array ISTBNU.
941119-tsaue:
READIN: added extra index to arrays IQM,NBLCK,JCO,NUC,NRC,SEG,ALPHA,
        CPRIMU ta accomodat both large and small components
ACPORB: implemented readin of exponents only
SYMGRP: New routine determining irreps, characters etc.
DBLGRP: new routine for handling double group symmetry
SYMOUT: moved test for IPREAD out of routine,
   for IPREAD=0 the routine was pretty meaningless
BASINP: major modifications - check it carefully out !!!
        may consider replacing NOORBT with MAXIQM wich has
        more information
CNTINP: info on angular momentum moved to BASINP
940207-hjaaj
READI1: 'ANG' was not initialized; errors in 'ANG' message format
931220-hjaaj
WRONEL: corrected calc. of INAMN and IGTO for LUONEL
931022-hjaaj
REAINP: INPTST = IPREAD .gt. 3 (INPTST was not defined)
expanded tabs with 'expand'
READI1: If ID3 then reset to blank (for abawalk)
BASINP: changed format for nuclear charge from F4.1 to F4.0
 (such that an entry '6' is read as 6. and not as 0.6 )
CNTINP: read in old 3F10 format if error reading coordinates
        changed format to 3F20.0 instead of 3F20.15
===========================================================================
#endif
C  /* Deck reainp */
      SUBROUTINE REAINP(WORD,IPRDEF,RELCAL,TSTINP)
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxsymm.h>
C
C     Note that the parameter MAXPRD also must be set in subroutine REAINI
C
#if defined (SYS_T3D)
      PARAMETER ( MAXPRD = 14 )
#else
      PARAMETER ( MAXPRD = 25 )
#endif
      PARAMETER ( NTABLE = 11, D1 = 1.0D0)
      LOGICAL NEWDEF, RELCAL, TSTINP
      CHARACTER PROMPT*1, WORD*7, TABLE(NTABLE)*7, WORD1*7
#include <cbirea.h>
#include <ccom.h>
C
      DATA TABLE /'.PRINT ', '.OLDNOR', '.MAXPRI', '.BIGVEC',
     *            '.MOLINP', '.SYMTHR', '.CM FUN', '.ZCMVAL',
     *            '.WRTLIN', '.UNCONT','.ANGSTR'/
C
      NEWDEF = (WORD .EQ. '*READIN')
      ICHANG = 0
      IF (NEWDEF) THEN
         WORD1 = WORD
  100    CONTINUE
            READ (LUCMD, '(A7)') WORD
            PROMPT = WORD(1:1)
            IF (PROMPT .EQ. '!' .OR. PROMPT .EQ. '#') THEN
               GO TO 100
            ELSE IF (PROMPT .EQ. '.') THEN
               ICHANG = ICHANG + 1
               DO 200 I = 1, NTABLE
                  IF (TABLE(I) .EQ. WORD) THEN
                     GO TO (1,2,3,4,5,6,7,8,9,10,11), I
                  END IF
  200          CONTINUE
               IF (WORD .EQ. '.OPTION') THEN
                 CALL PRTAB(NTABLE,TABLE,WORD1//' input keywords',LUPRI)
                 GO TO 100
               END IF
               WRITE (LUPRI,'(/,3A,/)') ' Keyword "',WORD,
     *            '" not recognized in REAINP.'
               CALL PRTAB(NTABLE,TABLE,WORD1//' input keywords',LUPRI)
               CALL QUIT('Illegal keyword in REAINP.')
    1          CONTINUE
                  READ (LUCMD, *) IPREAD
                  IF (IPREAD .EQ. IPRDEF) ICHANG = ICHANG - 1
               GO TO 100
    2          CONTINUE
                  OLDNRM = .TRUE.
               GO TO 100
    3          CONTINUE
                  READ (LUCMD,*) MAXPRI
               GO TO 100
    4          CONTINUE
                  BIGVC = .TRUE.
               GO TO 100
    5          CONTINUE
                  LUMLCL = LUCMD
               GO TO 100
 6             CONTINUE
                  READ (LUCMD,*) TOLLRN
               GO TO 100
 7             CONTINUE 
                  READ (LUCMD,*) LCMMAX, CMSTR, CMEND
                  NCMSTR = NINT(2*CMSTR + 0.01D0)
                  NCMEND = NINT(2*CMEND + 0.01D0)
               GO TO 100
 8             CONTINUE 
                  READ (LUCMD,*) ZCMVAL
               GO TO 100
 9             CONTINUE
c ach easier to debug intgrl input. 
                  WRTLIN= .TRUE.
               GO TO 100
   10          CONTINUE
                  UNCONT = .TRUE.
               GO TO 100
 11            CONTINUE
                  ANGS = .TRUE.
               GO TO 100
            ELSE IF (PROMPT .EQ. '*') THEN
               GO TO 300
            ELSE
               WRITE (LUPRI,'(/,3A,/)') ' Prompt "',WORD,
     *            '" not recognized in REAINP.'
               CALL PRTAB(NTABLE,TABLE,WORD1//' input keywords',LUPRI)
               CALL QUIT('Illegal prompt in REAINP.')
            END IF
      END IF
  300 CONTINUE
      IF (ICHANG .GT. 0) THEN
         CALL HEADER('Changes of defaults for READIN:',0)
         IF (IPREAD .NE. IPRDEF) THEN
            WRITE (LUPRI,'(A,I5)') ' Print level in READIN:',IPREAD
         END IF
         IF (OLDNRM) THEN
            WRITE (LUPRI,'(A)')
     &         ' Dalton 1.0 normalization of spherical GTOs used.'
         END IF
         IF (TOLLRN .NE. 0.0D0) THEN
            WRITE (LUPRI,'(A,G9.2)') ' Symmetry threshold: ',TOLLRN
         END IF
         IF (LUMLCL .EQ. LUCMD) THEN
            WRITE (LUPRI,'(/A)') ' MOLECULE read from input file'
         END IF
         IF (UNCONT) THEN
            WRITE (LUPRI,'(/A)')
     &         ' Uncontracted basis forced, irrespective of '//
     &         'basis input file.'
         END IF
         IF (MAXPRI .NE. MAXPRD) THEN
            WRITE (LUPRI,'(/A,I5)')
     *         ' Maximum number of primitives per integral block :',
     *         MAXPRI
         END IF
         IF (BIGVC) THEN
            WRITE (LUPRI,'(/A)')
     *         ' Primitives from different centers treated '//
     *         'simultaneously.'
            WRITE (LUPRI,'(/A)')
     &       ' Option .BIGVEC not implemented in present version.'
             CALL QUIT('Option .BIGVEC not allowed.')
         END IF
         IF (LCMMAX .GT. -1) THEN
            WRITE (LUPRI,'(/A,I5)')
     &           ' Center of mass basis functions used with l(max) =',
     &           LCMMAX
            WRITE (LUPRI,'(2(A,F4.1))')
     &           ' Sequence starts at ',CMSTR,' and ends at ', CMEND
            IF (ZCMVAL .NE. D1) 
     &           WRITE (LUPRI,'(A,F3.1)') ' Net charge of ionic core  ',
     &           ZCMVAL
            IF (LCMMAX .GT. 4) THEN
               WRITE (LUPRI,'(/A)')
     &              ' Center of mass bf. not defined for l .gt. 4'
               CALL QUIT('Error in *READIN input processing')
            END IF
         END IF
         WRITE (LUPRI,'()')
      END IF
      RETURN
      END
C  /* Deck reaini */
      SUBROUTINE REAINI(IPRDEF,RELCAL,TSTINP)
C
C     Define THRS in CCOM
C
C
C     Initialize /CBIREA/
C
#include <implicit.h>
C
C     Note that MAXPRD also must me set in subroutine REAINP
C
#if defined (SYS_T3D)
      PARAMETER (MAXPRD = 14)
#else
      PARAMETER (MAXPRD = 25)
#endif
      LOGICAL RELCAL, TSTINP
#include <maxaqn.h>
#include <ccom.h>
#include <mxsymm.h>
#include <cbirea.h>
      THRS = 1.0D-15
C
      IPREAD = IPRDEF
      LUMLCL = 0
      MAXPRI = MAXPRD
      UNCONT = .FALSE.
      BIGVC  = .FALSE.
      DIRAC  = RELCAL
      GENCON = .TRUE.
      INPTST = TSTINP
      BASIS  = .FALSE.
      ATOMBA = .FALSE.
      OLDNRM = .FALSE.
      WRTLIN  = .FALSE.
      TOLLRN = 0.0D0
      ZCMVAL = 1.0D0
      LCMMAX = -1
      RETURN
      END
C  /* Deck readin */
      SUBROUTINE READIN(WORK,LWORK,HERMIT)
C     Based on
C       READIN:Input processing routine for  M O L E C U L E.
C         Jan Almlof, Stockholm, Dec. 1971.
C         - adaption for ABACUS (T.Helgaker, University of Oslo)
C         - Occams razor by T.Saue, University of Oslo, March 10 - 1993
C           Major surgery includes:
C               - common block CCOM :
C                       - added KHK(MXQN),KCK(MXQN),NHKOFF(MXQN)
C                       - added GTOTYP(MXQN*(MXQN+1)*(MXQN+2)/6)
C               - common block NUCLEI:
C                       - added GAUNUC, GNUEXP(MXCENT)
C                       - added NAMN(MXCENT)
C               - NEW common block FRAME
C                       - added POTNUC, DPNUC(3)
C               - common block CBIREA:
C                       - IPRINT changed to IPREAD
C                       - added INPTST,FAMILY
C               - common block SHELLS:
C                       - added NLRGSH,NSMLSH,NLARGE,NSMALL,NORBS
C                       - added LCLASS(MXSHEL)
C               - common block MOLINP: deleted !!!
C               - common block MOLINC: deleted !!!
C               - common block HRUNIT: deleted !!!
C******************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <dummy.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
C
#include <abainf.h>
#include <gnrinf.h>
#include <cbirea.h>
C
      DIMENSION WORK(LWORK)
      LOGICAL HERMIT,NEWFILE,SET
      CHARACTER KEYWRD*6
#include <molinp.h>
#include <ccom.h>
#include <nuclei.h>
#include <frame.h>
#include <primit.h>
#include <shells.h>
#include <symmet.h>
#include <aosotr.h>
#include <infpar.h>
#include <chrsgn.h>
C
C     A SET variable has been replaced by RDINPC. This allows external control
C     of READIN processing. The processing should be performed once every
C     iteration.
C
      IF (RDINPC) RETURN
      RDINPC = .TRUE.
C
      IF (IPREAD .GE. 11) CALL TIMER('START ',TIMSTR,TIMEND)
      IF (IPREAD .GT.  0) THEN
         CALL TITLER('Output from READIN input processing','*',118)
      END IF
      LUINFO = LUMLCL
C
C Only the master in a parallel calc. reads the input file. The
C slaves do not read the input file in RDLINE but use the input lines
C read by the master and transferred in common block MOLINP. /hjaaj
C
      NEWFILE = LUINFO .NE. LUCMD .AND. .NOT. SLAVE
      IF (NEWFILE) THEN
         CALL GPOPEN (LUINFO,'MOLECULE.INP','OLD',' ','FORMATTED',
     &                IDUMMY,.FALSE.)
      END IF
C
      IF (.NOT.SLAVE) REWIND(LUINFO)
      NMLINE = 0
      CALL RDLINE(LUINFO)
      READ (MLINE(NMLINE),'(A6)') KEYWRD
      IF (KEYWRD(1:5) .EQ. 'BASIS') THEN
         BASIS = .TRUE.
      ELSE IF (KEYWRD .EQ. 'ATOMBA') THEN
         ATOMBA = .TRUE.
      ELSE IF (KEYWRD .NE. 'INTGRL') THEN
         GOTO 5010
      END IF
C
C     ********************************************
C     ***** Allocate memory **********************
C     ********************************************
C
      KATOM  = MXCENT
      KANG   = MXAQN
      KAOVEC = MXAOVC
      KBLOCK = KATOM*KAOVEC
      KPRIM  = MAXPRI
      KCMAT  = KPRIM*KPRIM
      KNONT  = 1
      KIQM   = KNONT  +  KATOM
      KBLCK  = KIQM   +  KATOM*2
      KJCO   = KBLCK  +  KATOM*2
      KNUC   = KJCO   +  KATOM*KANG*2
      KNRC   = KNUC   +  KBLOCK*2
      KSEG   = KNRC   +  KBLOCK*2
      KA     = KSEG   +  KBLOCK*2
      KC     = KA     +  KBLOCK*KPRIM*2
      KCC    = KC     +  KBLOCK*KCMAT*2
      KLAST  = KCC    +  KBLOCK*KCMAT*2
C     WRITE(LUPRI,'(A,2I16)') 'KLAST, LWORK',KLAST,LWORK
      IF(KLAST.GT.LWORK) GOTO 5020
      LWRK   = LWORK  -  KLAST + 1
C
C     ********************************************
C     ***** Read input file and process data *****
C     ********************************************
C
      CALL READI1(LUINFO,WORK(KLAST),LWRK,WORK(KNONT),WORK(KIQM),
     &            WORK(KBLCK),WORK(KJCO),WORK(KNUC),
     &            WORK(KNRC),WORK(KSEG),WORK(KA),
     &            WORK(KC),WORK(KCC),KATOM,KANG,KBLOCK,KPRIM,KAOVEC,
     &            HERMIT)
C     CALL RDLINE(LUINFO)
C     READ (MLINE(NMLINE),'(A6)') KEYWRD
C     IF (KEYWRD .NE. 'FINISH') GOTO 5030
      IF (IPREAD .GT. 20) CALL REAPRI
      IF (NEWFILE) CALL GPCLOSE(LUINFO,'KEEP')
      RETURN
C
C Error messages:
C
 5000 CONTINUE
      WRITE (LUPRI,'(//A)') ' *** ERROR *** unable to open MOLECULE.INP'
      CALL QUIT(' *** ERROR (READIN) unable to open input file LUINFO ')
 5010 CONTINUE
      CALL QUIT('Wrong keyword. Expecting INTGRL or BASIS')
 5020 CONTINUE
      CALL STOPIT('READIN','READI1',KLAST,LWORK)
C5030 CONTINUE
      CALL QUIT('Wrong keyword. Expecting FINISH')
      END
C  /* Deck readi1 */
      SUBROUTINE READI1(LUINFO,WORK,LWORK,NONT,IQM,NBLCK,JCO,NUC,
     &           NRC,SEG,ALPHA,CPRIM,CPRIMU,KATOM,KANG,KBLOCK,
     &           KPRIM,KAOVEC,HERMIT)
C******************************************************************************
C
C     Reads and processes input file of molecular data
C
C       **** Temporary variables used in READIN ****
C
C       KATOM   - atomic types
C       KANG    - angular momentum
C       KBLOCK  - AO-block
C       KPRIM   - primitives
C
C      (Large/small)
C       NONT            (KATOM)         - number of symmetry independent
C                                         centres for this atomic type
C       IQM             (KATOM)         - highest L-value
C       NBLCK           (KATOM)         - number of AO-blocks for a given
C                                         atomic type
C       JCO             (KANG,KATOM)    - number of AO-blocks for a given
C                                         atomic type and L-value
C       NUC             (KBLOCK)        - number of uncontracted functions
C                                         in a given AO-block
C       NRC             (KBLOCK)        - number of contracted functions
C                                         in a given AO-block
C       SEG             (KBLOCK)        - TRUE: segmented contraction
C       ALPHA           (KPRIM,KBLOCK)  - exponents
C       CPRIM           (KPRIM,KPRIM,KBLOCK)  - normalized contraction
C                                               coefficients
C       CPRIMU          (KPRIM,KPRIM,KBLOCK)  - contraction coefficients
C
C     LOCAL VARIABLES:
C       IPRIMA - runs over primitives for a given atomic type
C       ISHELL - runs over all shells
C       IPRIM - runs over all primitives
C       NUCIND2 - runs over all symmetry independent centers
C******************************************************************************
#include <implicit.h>
#include <iratdef.h>
#include <priunit.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
#include <codata.h>
      PARAMETER (D0 = 0.0D0, THRMIN = 1.D-15)
#include <clsfmm.h>
#include <cbirea.h>
      LOGICAL SEG,HERMIT,DOOWN,ZMAT
      DIMENSION NONT(KATOM),IQM(KATOM,2),NBLCK(KATOM,2),
     &          JCO(KANG,KATOM,2),
     &          NUC(KBLOCK,2),NRC(KBLOCK,2),SEG(KBLOCK,2),
     &          ALPHA(KPRIM,KBLOCK,2),
     &          CPRIM(KPRIM,KPRIM,KBLOCK,2),
     &          CPRIMU(KPRIM,KPRIM,KBLOCK,2), WORK(LWORK)
C
C       Local variables
C
      CHARACTER*1 KASYM(3,3),ID3,SPDCAR,CRT
      CHARACTER*72 TITLE(2)
      CHARACTER*2 SYMTXT
      CHARACTER*15 CLASS
      DIMENSION IFXYZ(3)
      LOGICAL ANG, ADDSYM
#include <cbihr1.h>
#include <molinp.h>
#include <ccom.h>
#include <inftap.h>
#include <nuclei.h>
#include <primit.h>
#include <shells.h>
#include <symmet.h>
#include <aosotr.h>
#include <gnrinf.h>
#include <orgcom.h>
#include <infpar.h>
#include <numder.h>
#include <r12int.h>
#include <ibtfun.h>
      ZMAT = .FALSE.
C     Initialize auxiliary basis set variables (WK/UniKA/04-11-2002).
      LAUXBS = .FALSE.
      MBSMAX = 4
      NMULBS = 0
C
C*****************************************************************************
C     Card 1: Keyword (INTGRL) - read in READIN
C*****************************************************************************
C*****************************************************************************
C     Card 2: If basis set library, read additional card containing basis set
C*****************************************************************************
      IF (BASIS) THEN
         CALL RDLINE(LUINFO)
C        Read basis set BASNAM (WK/UniKA/04-11-2002).
         CALL BASMUL(MLINE(NMLINE),BASNAM,IPREAD)
      END IF
C     Enforce computation of Cartesian second moments (WK/UniKA/04-11-2002).
      IF (LMULBS) CALL STCMOM
C*****************************************************************************
C     Card 2-3: Title cards
C*****************************************************************************
      CALL RDLINE(LUINFO)
      READ (MLINE(NMLINE),'(A72)') TITLE(1)
      CALL RDLINE(LUINFO)
      READ (MLINE(NMLINE),'(A72)') TITLE(2)
      IF (IPREAD .GT. 0) THEN
         CALL HEADER('Title Cards',1)
         WRITE (LUPRI,'(2X,A,/,2X,A)') TITLE(1),TITLE(2)
         IF (LUCME.GT.0) WRITE (LUCME,'(2X,A,/,2X,A)') TITLE(1),TITLE(2)
      END IF
C*****************************************************************************
C     Card 4:
C       CRT     - flag for spherical harmonics or "your own scheme"
C       NONTYP  - number of atomic types
C       SYMTXT  - Symmetry operations read as a text to test if
C                 symmetry is to be added automatically
C       KCHARG  - Molecular charge
C       NSYMOP  - number of independent twofold symmetry operations of
C                 point group to be used
C       KASYM   - 3x3 character array specifying the basic symmetry operations;
C                 specify axis that are reversed under the operation
C       THRS    - integral threshold
C******************************************************************************
      CALL RDLINE(LUINFO)
      READ (MLINE(NMLINE),'(BN,A1,I4,I3,A2,10A1,D10.2,6I5)')
     &     CRT,NONTYP,KCHARG,SYMTXT,((KASYM(I,J),I=1,3),J=1,3),ID3,THRS
      IF (NONTYP.EQ.0) THEN
        WRITE (LUPRI,'(/A/A//A)')
     &    ' You have specified a molecule with zero atoms,',
     &    ' thus all answers to all your input are zero!',
     &    ' (or you made an input error in the .mol file)'
        CALL QUIT('No atoms according to .mol input!')
      ELSE IF (NONTYP.LT.0) THEN
        WRITE (LUPRI,'(/A,I6)')
     &    ' >>> READI1 error, no. of atomic types negative:',NONTYP
        CALL QUIT('Negative number of atoms according to .mol input')
      ELSE IF (NONTYP.GT.KATOM) THEN
        WRITE (LUPRI,'(/A,I6/A,I6)')
     &   ' >>> READI1 error, no. of atomic types    ',NONTYP,
     &   '                   current maximum number ',KATOM
        CALL QUIT('Too many atomic types in .mol input')
      END IF
C*****************************************************************************
C Check integral threshold: THRS must be .gt. 0
C       ( log(thrs*thrs) taken in oneint) (851005-hjaaj)
C*****************************************************************************
C
      IF (MLINE(NMLINE)(21:30) .EQ. '          ') THEN
C        nothing specified, default minimum value used
         THRS = THRMIN
Chj   ELSE IF (THRS .LE. D0) THEN
      ELSE IF (THRS .LT. THRMIN) THEN
         WRITE (LUPRI,'(/2X,A)') '*** WARNING from READIN ***'
         WRITE (LUPRI,'(2(/2X,A,1P,D12.2))')
     &      'Threshold for discarding integrals was',THRS,
     &      'Threshold is reset to minimum value   ',THRMIN
         THRS = THRMIN
C        note that her2drv.F has explicit THRESH = MAX(THRS,1.0D-15)
C        - hjaaj, aug99
      ENDIF
C*****************************************************************************
C Check if symmetry is to be added automatically
C       ADDSYM  - flag for automatic determination of symmetry
C*****************************************************************************
      ADDSYM = (SYMTXT .EQ. '  ')
      IF (.NOT. ADDSYM) THEN
         READ(SYMTXT,'(I2)') NSYMOP
         NOADSY = .TRUE.
      ELSE
         NSYMOP = 0
         NOADSY = .FALSE.
      END IF
      NMLAU = NMLINE
C     .. NMLAU indentifies input line with Angstroms or bohrs indicator.
      IF (ID3 .NE. ' ' .or. ANGS ) THEN
        ANG = .TRUE.
        IF (.NOT. SLAVE .AND. IPREAD .GT. 0)
     &      WRITE (LUPRI,'(/2X,A/10X,A,F11.8,A2)')
     &          'Coordinates are entered in Angstroms'//
     &          ' and converted to atomic units.',
     &          '- Conversion factor : 1 bohr =',XTANG,' A'
      ELSE
         ANG = .FALSE.
      ENDIF
C*****************************************************************************
C Process Cartesian to spherical or your own transformation
C     note: SPHINP will read additional input lines if DOOWN true
C*****************************************************************************
      DOCART = CRT .EQ. 'C' .OR. CRT .EQ. 'c'
      DOOWN  = CRT. EQ. 'X'
      CALL CRTEST(DOCART)
      CALL SPHINP(LUINFO,WORK,LWORK,DOOWN,MXSPD)
C
C     ************************************************
C     ***** Read orbital and geometry input data *****
C     ************************************************
C
      OLDNRM = DOCART .OR. DOOWN .OR. OLDNRM
C     ... now oldnrm only false if sperical, i.e. the only case
C         where we know the 5 d's have same norm. Used for Huckel.
      CALL BASINP(LUINFO,WORK,LWORK,NONTYP,NSYMOP,NONT,IQM,NBLCK,JCO,
     &            NUC,NRC,SEG,ALPHA,CPRIM,CPRIMU,KATOM,KANG,
     &            KBLOCK,KPRIM,KAOVEC,ANG,ZMAT,MXSPD)
C
C     *************************************************
C     ***** Process ZMAT coordinates if requested *****
C     *************************************************
C
      IF (ZMAT) CALL BUILDZ(IPREAD,NONTYP,NSYMOP,NONT,IQM,NBLCK,JCO,NUC,
     &                  NRC,SEG,ALPHA,CPRIM,CPRIMU,KATOM,KANG,
     &                  KBLOCK,KPRIM,KAOVEC,DOOWN,MXSPD)
C
C     *************************************************
C     ***** Add symmetry to molecule if requested *****
C     *****   Returns CLASS, the full symmetry    *****
C     *************************************************
C
      CLASS = 'N/A'
      IF (ADDSYM .AND. (.NOT. DIRAC)) THEN
         CALL SYMADD(WORK,LWORK,NONTYP,NSYMOP,NONT,KATOM,KASYM,CLASS)
      END IF
C
C     ***************************************
C     ***** Process symmetry input data *****
C     ***************************************
C
      CALL SYMINP(NSYMOP,KASYM,IFXYZ, CLASS)
C
C     ***************************************************
C     ***** Process orbital and geometry input data *****
C     ****************************************************
C
      CALL BASPRO(WORK,LWORK,NONTYP,NSYMOP,NONT,IQM,NBLCK,JCO,NUC,NRC,
     &            SEG,ALPHA,CPRIM,CPRIMU,KATOM,KANG,KBLOCK,KPRIM,
     &            KAOVEC,DOOWN)
C
C     Determine center of mass
C
      KGEOM = 1
      KMASS = KGEOM + 3*NUCDEP
      KNAT  = KMASS + NUCDEP
      KNUMIS= KNAT  + (NUCDEP + 1)/IRAT
      KLAST = KNUMIS+ (NUCDEP + 1)/IRAT
      IF (KLAST .GT. LWORK) CALL STOPIT('READI1','CMMASS',KLAST,
     &                                   LWORK)
      CALL CMMASS(WORK(KGEOM),WORK(KMASS),WORK(KNAT),WORK(KNUMIS),
     &            IPREAD-1)
      IF (ADDSYM) CALL DCOPY(3,CMXYZ,1,DIPORG,1)
      IF (ADDSYM) CALL DCOPY(3,CMXYZ,1,GAGORG,1)
      IF (.NOT. CAVUSR) CALL DCOPY(3,CMXYZ,1,CAVORG,1)
C
C     *************************************************
C     ***** Print orbital and geometry input data *****
C     *************************************************
C
      CALL BASOUT(WORK,LWORK,NONTYP,NONT,IQM,NBLCK,JCO,NUC,NRC,SEG,
     &            ALPHA,CPRIM,CPRIMU,KATOM,KANG,
     &            KBLOCK,KPRIM,KAOVEC,KASYM,NSYMOP,HERMIT)
C
      IF (IPREAD .GE. 2) THEN
         CALL HEADER('Copy of input to READIN',0)
         WRITE (LUPRI,'(A)') (MLINE(I), I = 1, NMLINE)
         WRITE (LUPRI,'(/)')
      END IF
C
      THRCLS = THRS
C
C     ****************************************
C     ***** Output on LUONEL *****************
C     ****************************************
C
      IF (HERMIT) CALL WRONEL(TITLE,NONTYP,NONT,IQM,IFXYZ,KATOM,JCO,
     &                        KANG)
C
      RETURN
      END
C  /* Deck baspar */
      SUBROUTINE BASPAR(NSYMOP)
C*****************************************************************************
C
C       Set various basis parameters:
C               KHK(J) - number of spherical (cartesian) components for given J
C               KCK(J) - number of Cartesian components for given J
C                      - tabulate incomplete Gamma function
C                      - determine Cartesian powers
C               NHKOFF(J) - offset for components in list of l-functions
C               MAXOPR - maximum number of operations to loop over
C*****************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
#include <cbirea.h>
C
#include <ccom.h>
#include <nuclei.h>
#include <symmet.h>
#include <aosotr.h>
#include <ibtfun.h>
C
C     ***** Tabulate Incomplete Gamma Function *****
C
      JMAX = MAX(4,4*(NHTYP - 1) + 2)
      CALL GAMTAB(JMAX)
C
C     ***** Cartesian powers *****
C
      CALL CARPOW
C
C     ***** NHKOFF() *****
C     - offset for components in list of l-functions
C
      IOFF = 0
      DO 100 I = 1, NHTYP
         NHKOFF(I) = IOFF
         IOFF = IOFF + KHK(I)
  100 CONTINUE
C
C     ***** MAXOPR *****
C     - maximum number of operations necessary to loop over
C
      MAXOPR = 1
      IF (NSYMOP .GT. 0) THEN
         MAXLO = 7
         DO 200 I = 1, NUCIND
            MAXLO = IBTAND(ISTBNU(I),MAXLO)
  200    CONTINUE
         II = 1
         DO 300 I = 1, NSYMOP
            IF(IBTAND(II,MAXLO).EQ.0) MAXOPR = 2*II
            II = 2*II
  300    CONTINUE
      END IF
      MAXOPR = MAXOPR - 1
C
      END
C  /* Deck basinp */
      SUBROUTINE BASINP(LUINFO,WORK,LWORK,NONTYP,NSYMOP,NONT,IQM,NBLCK,
     &                  JCO,NUC,NRC,SEG,ALPHA,CPRIM,CPRIMU,KATOM,
     &                  KANG,KBLOCK,KPRIM,KAOVEC,ANG,ZMTTST,MXSPD)
C*****************************************************************************
C
C       Read orbital and geometry input data
C
C*****************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
      PARAMETER (D0 = 0.0D0)
      PARAMETER (DSM = 1.0D-30)
#include <cbirea.h>
      DIMENSION WORK(LWORK)
      LOGICAL SEG,ANG,NOORBI,ZMTTST
      DIMENSION NONT(KATOM),IQM(KATOM,2),JCO(KANG,KATOM,2),
     &          NBLCK(KATOM,2),NUC(KBLOCK,2),NRC(KBLOCK,2),
     &          SEG(KBLOCK,2),
     &          ALPHA(KPRIM,KBLOCK,2),CPRIM(KPRIM,KPRIM,KBLOCK,2),
     &          CPRIMU(KPRIM,KPRIM,KBLOCK,2)
      CHARACTER SPDCAR*1,BSET*5,ZMATL*1
      DIMENSION IBLOCK(2)
#include <molinp.h>
#include <ccom.h>
#include <nuclei.h>
#include <symmet.h>
#include <cbisol.h>
#include <huckel.h>
#include <aosotr.h>
#include <ecpinf.h>
#include <r12int.h>
#include <ibtfun.h>
C
C     MBSIP = basis-set identifier (WK/UniKA/04-11-2002).
      MBSIP = 0
      NUCIND = 0
      NHTYP  = 0
      IBLOCK(1) = 1
      IBLOCK(2) = 1
      CALL IZERO(IQM,KATOM*2)
C
C     Initialize NSETS and BSET for Dalton,
C     if (DIRAC) these will be modified below:
C     NSETS = 1 for Large, = 2 for "Large" and "Small"
C     and BSET will change to "Large" or "Small".
C
      NSETS = 1
      IF (ADDSTO) NSETS = 2
C     If (ADDSTO) use second set for STO-3G for Huckel guess
      BSET = 'Basis'
C
C     Run over atomic centers
C     =======================
C
      DO 100 I = 1, NONTYP
         NOORBI = .TRUE.
         INUC = NUCIND
C
C*****************************************************************************
C        Card 6: ATOMIC DATA
C         Q     - nuclear charge
C         NONT  - number of symmetry independent atoms
C         IQM   - maximum angular quantum number (s=1,p=2,d=3 etc.)
C         NHTYP - maximum angular quantum number for ALL orbitals
C         JCO   - number of AO-blocks for each l-value
C*****************************************************************************
C
         CALL RDLINE(LUINFO)
C
C        Test if Z-matrix for first line (I.eq.1):
C
         IF (I .EQ. 1 .AND. .NOT. DIRAC) THEN
           READ (MLINE(NMLINE),'(A1)') ZMATL
           IF (ZMATL .NE. ' ') THEN
              ZMTTST = .TRUE.
              WRITE (LUPRI,'(/A)')
     &        'Atoms and their geometry are read in Z-matrix format.'
              IF (.NOT. BASIS) THEN
                 WRITE (LUPRI,'(/A)') '*** READI1 ERROR:'
                 CALL QUIT('Z-matrix only implemented with BASIS')
              END IF
           END IF
         END IF
C
C        Read/process data on centers/blocks
C        ===================================
C
         IF (DIRAC) THEN
            READ (MLINE(NMLINE),'(BN,1X,F9.0,2I5)') Q,NONT(I),NSETS
         ELSE IF (ZMTTST) THEN
C           Z-matrix not implemented with LMULBS (WK/UniKA/04-11-2002).
            IF (LMULBS) THEN
               WRITE (LUPRI,'(/A)') '*** READI1 ERROR:'
               CALL QUIT('Z-matrix not implemented with LMULBS')
            END IF
            CALL ZMAT(NONT,KATOM)
            Q = CHARGE(NUCIND)
         ELSE IF (ATOMBA .OR. BASIS) THEN
C           Read basis-set identifier from MLINE(NMLINE)
C           Put MBSI = 1 otherwise (WK/UniKA/04-11-2002).
            IF (LMULBS) THEN
               READ (MLINE(NMLINE),'(BN,1X,I2,F7.0,I5)') MBSI,Q,NONT(I)
            ELSE
               READ (MLINE(NMLINE),'(BN,1X,F9.0,I5)') Q,NONT(I)
               MBSI = 1
            END IF
         ELSE
C ach 
            if (wrtlin) then 
               write(lupri,*) mline(nmline)
               call flush(lupri)
            endif
C           Read basis-set identifier from MLINE(NMLINE)
C           Put MBSI = 1 otherwise (WK/UniKA/04-11-2002).
            IF (LMULBS) THEN
               READ (MLINE(NMLINE),'(BN,1X,I2,F7.0,I5,24I5)') 
     &               MBSI,Q,NONT(I),IQM(I,1),(JCO(J,I,1), J=1, IQM(I,1))
            ELSE
               READ (MLINE(NMLINE),'(BN,1X,F9.0,I5,24I5)') 
     &                    Q,NONT(I),IQM(I,1),(JCO(J,I,1), J=1, IQM(I,1))
               MBSI = 1
            END IF
         END IF
C        Check MBSI (WK/UniKA/04-11-2002).
         IF (LMULBS .AND. MBSI .LE. 0) THEN 
            WRITE (LUPRI,'(/A)') '*** READI1 ERROR:'
            CALL QUIT('Please provide proper basis-set identifier')
         END IF
C        Check MBSI (WK/UniKA/04-11-2002).
         IF (LMULBS .AND. MBSI .LT. MBSIP) THEN 
            WRITE (LUPRI,'(/A)') '*** READI1 ERROR:'
            CALL QUIT('Please provide multiple basis sets in increasing'
     &                //' order')
         END IF
C        Check MBSI (WK/UniKA/04-11-2002).
         MBSIP = MBSI
         NMULBS = MAX(MBSI,NMULBS)
         IF (NMULBS .GT. MXMULB) THEN
            WRITE (LUPRI,'(/A)') '*** READI1 ERROR:'
            CALL QUIT('Too many multiple basis sets')
         END IF
Chj - aug99: changed test from 36 to 20, because current Huckel implementation
C            (1) gives poor orbital energies for some d-orbitals
C                because of normalization of x2, y2, z2 to three
C                (instead of one)
C            (2) and breaks symmetry between e.g. x2-y2 and xy because of (1)
C
         IF (OLDNRM) THEN
C        ... Here oldnrm is only false if sperical, i.e. the only case
C            where we know the 5 d's have same norm.
            MXQHUCK = 20
         ELSE
Chj - apr00: this has been fixed with normalized spherical GTO's from SPHCOM
            MXQHUCK = 36
         ENDIF
         IF (ADDSTO .AND. NINT(Q) .GT. MXQHUCK) THEN
            NSETS = 1
            ADDSTO = .FALSE.
            NINFO = NINFO + 1
            WRITE (LUPRI,'(/A,I3)')
     &           '  INFO: No Huckel start guess due'//
     &           ' to nuclear charge larger than',MXQHUCK
C
C     Just in case we have already processed some Huckel-orbitals for 
C     some centers, we zero out IQM in order to prevent errors when sorting
C     integral shells
C
           CALL DZERO(IQM(1,2),KATOM)
        ENDIF
C
C       Read/process data on symmetry independent centers
C       =================================================
C       (if ZMAT then it is done later)
C
         IF (ZMTTST) GO TO 100
C
         IF (INPTST .OR. IPREAD .GT. 3) THEN
            WRITE(LUPRI,'(/A,I5)') 'Atomic type: ',I
            WRITE(LUPRI,'(3X,A,F4.1)') 'Nuclear charge:  ',Q
            WRITE(LUPRI,'(3X,A,I5)') 'Number of symmetry '//
     &           'independent centres: ',NONT(I)
         ENDIF
C        MBSI has been added (WK/UniKA/04-11-2002).
         CALL CNTINP(LUINFO,NONT(I),Q,NSYMOP,ANG,MBSI)
C
         DO 300 J = 1,NSETS
C
C         Construct basis set for center of mass centers if requested
C         ===========================================================
C         Center of mass centers are designated with 'x' or 'X'
C
Chj: changed to correspond to input manual 970926
Chj  (Otherwise floating orbitals will not work with .CM FUN)
Chj         NQ = NINT(Q + 0.01)
Chj         IF ((LCMMAX .GT. -1) .AND. (NQ .EQ. 0)) THEN
            IF ((LCMMAX .GT. -1) .AND. (NONT(I) .EQ. 1) .AND.
     &          (INDEX('   X   ',NAMN(NUCIND)) .GT. 0 .OR.
     &           INDEX('   x   ',NAMN(NUCIND)) .GT. 0)) THEN
               IF (J .EQ. 1) THEN
                  IQM(I,J) = LCMMAX + 1
                  CALL CMBAS(IQM(I,J),JCO(1,I,J),NUC(IBLOCK(J),J),
     &                 NRC(IBLOCK(J),J),SEG(IBLOCK(J),J),
     &                 ALPHA(1,IBLOCK(J),J),
     &                 CPRIM(1,1,IBLOCK(J),J),CPRIMU(1,1,IBLOCK(J),J),
     &                 NBLOCK,KAOVEC,KPRIM)
               ELSE
                  IQM(I,J) = 0
               END IF
C
C         Get basis set from basis set library
C         ===================================
C
            ELSE IF ((BASIS .OR. ATOMBA .OR. (ADDSTO .AND. J .EQ. 2
     &              .AND. Q .NE. 0.0D0)) .AND. .NOT. DIRAC) THEN
              IF (BASIS) THEN
C                Basis-set name for identifier MBSI (WK/UniKA/04-11-2002).
                 BASNAM = MULNAM(MBSI)
              ELSE IF (ATOMBA) THEN
                 BASNAM = MLINE(NMLINE-NONT(I))(16:)
                 DO ILEN = 1, LEN(BASNAM)
                    IF (BASNAM(ILEN:ILEN) .NE. ' ') GO TO 33
                 END DO
 33              CONTINUE
                 BASNAM = BASNAM(ILEN:)
                 IF (INPTST .OR. IPREAD .GT. 1) THEN
                    IF (ADDSTO .AND. J.EQ.2) THEN
                       WRITE (LUPRI,'(/A,I3)')
     &                 ' Huckel basis read for atomic type no.',I
                    ELSE IF (BASNAM(1:6) .EQ. 'INTGRL') THEN
                       WRITE (LUPRI,'(/A,I3,A)')
     &                    ' For atomic type no.',I,
     &                    ' the basis set will be read from input.'
                    ELSE IF (BASNAM(1:11) .EQ. 'pointcharge') THEN
                       WRITE (LUPRI,'(/A,I3,A)')
     &                    ' Atomic type no.',I,
     &                    ' is a point charge without basis functions.'
                    ELSE IF (BASNAM(1:3) .EQ. 'ECP') THEN
                       WRITE (LUPRI,'(/A,I3,A/5X,A/A)')
     &                 ' For atomic type no.',I,
     &                 ' the effective core potential basis set ',
     &                 BASNAM,
     &                 ' from the basis set library will be used.'
                    ELSE
                       WRITE (LUPRI,'(/A,I3,A/5X,A/A)')
     &                 ' For atomic type no.',I,' the basis set',BASNAM,
     &                 ' from the basis set library will be used.'
                    END IF
                 END IF
              END IF
              IF (BASNAM(1:6) .EQ. 'INTGRL') THEN
C                this makes it possible to specify basis sets
C                not in basis library for some atoms.
                 CALL GTOINP(LUINFO,IQM(I,J),JCO(1,I,J),
     &                NUC(IBLOCK(J),J),NRC(IBLOCK(J),J),
     &                SEG(IBLOCK(J),J),
     &                ALPHA(1,IBLOCK(J),J),CPRIM(1,1,IBLOCK(J),J),
     &                CPRIMU(1,1,IBLOCK(J),J),NBLOCK,KAOVEC,KPRIM)
              ELSE IF (BASNAM(1:11) .NE. 'pointcharge') THEN
                 CALL BASLIB(IQM(I,J),JCO(1,I,J),NUC(IBLOCK(J),J),
     &                  NRC(IBLOCK(J),J),SEG(IBLOCK(J),J),
     &                  ALPHA(1,IBLOCK(J),J),
     &                  CPRIM(1,1,IBLOCK(J),J),
     &                  CPRIMU(1,1,IBLOCK(J),J),
     &                  NBLOCK,KAOVEC,KPRIM,Q,J,DSM)
                 IF (BASNAM(1:3) .EQ. 'ECP') THEN
C     Read effective core potantial information from file for atom. 
C     The charge of atom type is set to be the effective charge.
                    CALL ECPINP(Q,QEFF,I,IPREAD)
                    DO INONT=1,NONT(I)
                       CHARGE(NUCIND+1 - INONT) = QEFF
                    END DO
                    INDECP(I) = NUCIND+1 - NONT(I)
                    NECP(I) = NONT(I)
                    IF (NECP(I).GT.MXNONT) THEN
                       WRITE(LUPRI,*) ' NUMBER OF ECP ATOMS OF TYPE ', 
     &                      NTYECP, ' EXCEEDS MXNONT=',MXNONT
                       CALL QUIT('Too many ECP atoms of this type')
                    END IF
                 END IF
              END IF
C
            ELSE
C
C         Read basis set from file
C         ========================
C
               IF (DIRAC) THEN
                  CALL RDLINE(LUINFO)
                  READ (MLINE(NMLINE),'(BN,A5,12I5)')
     &                 BSET,IQM(I,J),(JCO(K,I,J),K=1,IQM(I,J))
               ENDIF
               CALL GTOINP(LUINFO,IQM(I,J),JCO(1,I,J),
     &              NUC(IBLOCK(J),J),NRC(IBLOCK(J),J),
     &              SEG(IBLOCK(J),J),
     &              ALPHA(1,IBLOCK(J),J),CPRIM(1,1,IBLOCK(J),J),
     &              CPRIMU(1,1,IBLOCK(J),J),NBLOCK,KAOVEC,KPRIM)
            ENDIF
            NBLCK(I,J) = NBLOCK
            IBLOCK(J)  = IBLOCK(J) + NBLCK(I,J)
            NOORBI     = NOORBI .AND.IQM(I,J).EQ.0
            IF (IQM(I,J).GT.0) THEN
               IF(INPTST .OR. IPREAD .GT. 3) THEN
                  WRITE(LUPRI,'(3X,A5,A)') BSET,' set:'
                  WRITE(LUPRI,'(6X,A,I5,A,12I5)')
     &                 'Max.ang.quantum no.:',(IQM(I,J)-1),
     &                 '  Blocks:',(JCO(K,I,J), K=1,IQM(I,J))
               ENDIF
C
C     Check angular momentum quantum number
C
               NHTYP     = MAX(NHTYP,IQM(I,J))
               IF(NHTYP.GT.MXSPD) GOTO 5000
            ENDIF
 300     CONTINUE
C
         DO 400 K = 1,NONT(I)
            NOORBT(K+INUC) = NOORBI
 400     CONTINUE
  100 CONTINUE
      RETURN
C
C     Error messages:
C
 5000 CONTINUE
         WRITE (LUPRI,'(6X,A,I3,3A/9X,2A)')
     &      '*  Input specifies highest orbital of atomic type ',
     &      I,' AS "',SPDCAR(NHTYP - 1),'".',
     &      ' Highest allowed orbital in this version: ',
     &      SPDCAR(MXSPD - 1)
         IF (NHTYP.GT.MXQN) WRITE (LUPRI,'(9X,2(A,I3),A)')
     &      ' Increase MXQN from',MXQN,' to',NHTYP,' and recompile.'
         CALL QUIT('Too high angular quantum no. specified in input.')
      END
C  /* Deck cntinp */
      SUBROUTINE CNTINP(LUINFO,NONT,Q,NSYMOP,ANG,MBSI)
C     MBSI has been added (WK/UniKA/04-11-2002).
C*****************************************************************************
C
C        Read and process data about symmetry independent centers
C
C*****************************************************************************
#include <implicit.h>
#include <dummy.h>
#include <priunit.h>
#include <mxcent.h>
#include <maxaqn.h>
#include <maxorb.h>
#include <codata.h>
      PARAMETER(D0 = 0.0D00, CORMAX = 1.D5)
#include <cbirea.h>
C
      LOGICAL ANG
#include <gnrinf.h>
#include <molinp.h>
#include <ccom.h>
#include <nuclei.h>
#include <symmet.h>
#include <r12int.h>
#include <ibtfun.h>
C
      IF (GAUNUC.AND.(NINT(Q).NE.0)) THEN
         CALL NUCSIZ(IPREAD,Q,GEXP)
      ELSE
         GEXP = D0
      END IF
      NUCSTR = NUCIND + 1
      IF (INPTST .OR. IPREAD .GT. 3) 
     &     WRITE(LUPRI,'(3X,A)') 'Symmetry independent centers:'
      DO 100 N = 1,NONT
         NUCIND = NUCIND + 1
         IF (NUCIND.GT.MXCENT) GOTO 5000
C
C*****************************************************************************
C        Card 7:
C           NAMN - name of symmetry independent center
C           CORR - coordinates of symmetry independent center
C*****************************************************************************
C
         CALL RDLINE(LUINFO)
         READ (MLINE(NMLINE),'(A4)') NAMN(NUCIND)
C        951115-hjaaj: NAMN() must never be read with free format
C          (otherwise it will on e.g. AIX be filled with nulls:
C           e.g. ' C  ' would become 'C\NULL\NULL\NULL'; and on
C           e.g. IRIX free format read of char. var. is not defined).
#if !defined (SYS_CRAY) && !defined (VAR_NOFREE) && !defined (SYS_T3D) && !defined (SYS_T90)
         READ (MLINE(NMLINE)(5:80),*,ERR=101) (CORD(J,NUCIND),J = 1, 3)
         GOTO 104
  101    READ (MLINE(NMLINE)(1:80),'(BN,4X,3F20.0)',ERR=102)
     &        (CORD(J,NUCIND), J = 1,3)
         GO TO 104
  102    READ (MLINE(NMLINE)(1:80),'(BN,4X,3F10.0)',ERR=103)
     &           (CORD(J,NUCIND), J = 1,3)
         GO TO 104
  103    CONTINUE
            WRITE(LUPRI,'(/A,I5/A,I5,A)')
     &      ' ERROR: Unable to read Cartesian coordinates of atom no.',
     &      NUCIND,' from line',NMLINE,' in the MOLECULE input file:'
            WRITE(LUPRI,'(A)') MLINE(NMLINE)
         CALL QUIT('ERROR reading atomic coordinates in MOLECULE input')
  104    CONTINUE
#else
         ISTART = 5
         DO J = 1, 3
           CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,CORD(J,NUCIND),'REA')
         END DO
#endif
         IPOS = INDEX(MLINE(NMLINE),'Isotope=')
         IF (IPOS .NE. 0) THEN
            IPOS = IPOS + 8
            READ (MLINE(NMLINE)(IPOS:),'(I3)') MASSNM
            ISOTOP(NUCIND) = ISOMAS(NINT(Q),MASSNM)
         ELSE
            ISOTOP(NUCIND) = 1
         END IF
         IF(INPTST .OR. IPREAD .GT. 3) THEN
            WRITE(LUPRI,'(6X,A4,3F20.15)') NAMN(NUCIND),
     &          (CORD(J,NUCIND), J = 1,3)
         ENDIF
         NCLINE(NUCIND) = NMLINE
         NAMEX(3*NUCIND)     = NAMN(NUCIND)//' z'
         NAMEX(3*NUCIND - 1) = NAMN(NUCIND)//' y'
         NAMEX(3*NUCIND - 2) = NAMN(NUCIND)//' x'
         DO 200 J = 1,3
            IF(ANG) CORD(J,NUCIND) = CORD(J,NUCIND)/XTANG
            IF(ABS(CORD(J,NUCIND)).GT.CORMAX) GOTO 5010
  200   CONTINUE
C
C*****************************************************************************
C       MULBSI  - basis-set identifier (WK/UniKA/04-11-2002).
C       CHARGE  - charge of center
C       NOORBT  - TRUE: no orbitals on this center
C       GNUEXP  - exponent of Gaussian nuclear charge distribution
C*****************************************************************************
C
         MULBSI(NUCIND) = MAX(MBSI,1)
         IF (MBSI .GT. 1) THEN
            CHARGE(NUCIND) = D0
            GNUEXP(NUCIND) = D0
         ELSE
            CHARGE(NUCIND) = Q
            GNUEXP(NUCIND) = GEXP
         END IF
  100 CONTINUE
      RETURN
C
C       Error messages:
C
 5000 CONTINUE
        WRITE (LUPRI,'(/A/A,I5)')
     &    ' Too many atomic centers: MXCENT exceed in CNTINP,',
     &    ' Current limit:',MXCENT
        CALL QUIT('*** ERROR *** MXCENT exceeded in CNTINP')
 5010 CONTINUE
        WRITE (LUPRI,'(A,E12.6,A/A/A,E12.6)')
     &    ' Atomic coordinate ',CORD(J,NUCIND),
     &    ' too large in CNTINP.',
     &    ' Note: Program is unstable for large coordinates.',
     &    ' Maximum coordinate value:',CORMAX
        CALL QUIT('*** ERROR: Atomic coordinate too large in CNTINP')
      END
C  /* Deck baspro */
      SUBROUTINE BASPRO(WORK,LWORK,NONTYP,NSYMOP,NONT,IQM,NBLCK,JCO,NUC,
     &                  NRC,SEG,ALPHA,CPRIM,CPRIMU,KATOM,KANG,
     &                  KBLOCK,KPRIM,KAOVEC,DOOWN)
C
C*****************************************************************************
C
C       Process orbital and geometry input data
C
C*****************************************************************************
C
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
#include <cbirea.h>
      DIMENSION WORK(LWORK)
      LOGICAL SEG,DOOWN
      DIMENSION NONT(KATOM),IQM(KATOM,2),JCO(KANG,KATOM,2),
     &          NBLCK(KATOM,2),NUC(KBLOCK,2),NRC(KBLOCK,2),
     &          SEG(KBLOCK,2),
     &          ALPHA(KPRIM,KBLOCK,2),CPRIM(KPRIM,KPRIM,KBLOCK,2),
     &          CPRIMU(KPRIM,KPRIM,KBLOCK,2)
      CHARACTER*1 SPDCAR
#include <ccom.h>
#include <nuclei.h>
#include <shells.h>
#include <symmet.h>
#include <primit.h>
#include <gnrinf.h>
#include <huckel.h>
#include <aosotr.h>
#include <veclen.h>
#include <ibtfun.h>
C*****************************************************************************
C       MULK    - bitstring of basic operations that stabilise a center
C*****************************************************************************
C
      II = 1
      DO 100 I = 1, NONTYP
         DO 110 J = 1, NONT(I)
            MULK = 0
            LL = 1
            DO 140 L = 1, NSYMOP
               DO 150 M = 1,3
                  IF(IBTAND(LL,ISYMAX(M,1)) .NE. 0) THEN
                     IF(ABS(CORD(M,II)).GE.1.0D-06) GOTO 140
                  END IF
 150           CONTINUE
               MULK = MULK + LL
 140        LL = 2*LL
            ISTBNU(II) = MULK
            II = II + 1
 110     CONTINUE
 100  CONTINUE
C*****************************************************************************
C       Set various basis parameters
C*****************************************************************************
      CALL BASPAR(NSYMOP)
C*****************************************************************************
C       Process nuclear data
C*****************************************************************************
      CALL NUCPRO(WORK,LWORK)
C*****************************************************************************
C       Process orbital data for large components
C*****************************************************************************
      LCOMP  = 1
      ISHELL = 0
      IPRIM  = 0
      IPRIMD = 0
      IORB   = 0
      IORBD  = 0
      CALL ORBPRO(NONTYP,NONT,IQM(1,1),NBLCK(1,1),JCO(1,1,1),NUC(1,1),
     &            NRC(1,1),SEG(1,1),
     &            ALPHA(1,1,1),CPRIM(1,1,1,1),CPRIMU(1,1,1,1),
     &            KATOM,KANG,KBLOCK,KPRIM,ISHELL,
     &            IPRIM,IPRIMD,IORB,IORBD,LCOMP)
      NLRGSH = ISHELL
      NLARGE = IORBD
      NORBL  = IORB
      NPLRG  = IPRIMD
      NPLSH  = IPRIM
C
C     Set up a contraction matrix in case of Douglas-Kroll integrals
C
      IF (DKTRAN) THEN
         IF (LWORK .LT. NPLRG*NLARGE) CALL STOPIT('READI1 ','BASPRO',
     &                                             NPLRG*NLARGE,LWORK)
         CALL DKPRO(NONTYP,NONT,IQM(1,1),NBLCK(1,1),JCO(1,1,1),
     &              NUC(1,1),NRC(1,1),SEG(1,1),ALPHA(1,1,1),
     &              CPRIM(1,1,1,1),WORK,KATOM,KANG,KBLOCK,KPRIM,
     &              NPLRG,NLARGE)
      END IF
C*****************************************************************************
C       Process orbital data for small components
C*****************************************************************************
      LCOMP = 2
      CALL ORBPRO(NONTYP,NONT,IQM(1,2),NBLCK(1,2),JCO(1,1,2),NUC(1,2),
     &            NRC(1,2),SEG(1,2),
     &            ALPHA(1,1,2),CPRIM(1,1,1,2),CPRIMU(1,1,1,2),
     &            KATOM,KANG,KBLOCK,KPRIM,
     &            ISHELL,IPRIM,IPRIMD,IORB,IORBD,LCOMP)
      IF (ADDSTO) THEN
         IF (ISHELL .GT. MXSHEL) GOTO 5040
         IF (IORBD  .GT. MXCORB) GOTO 5050
         IF (IPRIMD .GT. MXPRIM) GOTO 5060
         NSMLSH = ISHELL - NLRGSH
         NORBS  = IORB
         NSMALL = IORBD - NLARGE
         NPSML  = IPRIMD - NPLRG
         NPSHEL = IPRIM - NPLRG
C
         KMAX   = NLRGSH
         NBASIS = NLARGE
         NPBAS  = NPLRG
C
         NHUCSH = NSMLSH
         NHUCBA = NSMALL
         NHUCNP = NPSML
      ELSE
         KMAX   = ISHELL
         IF(KMAX.GT.MXSHEL) GOTO 5000
         NSMLSH = KMAX - NLRGSH
         NORBS  = IORB
         NBASIS = IORBD
         IF (IPREAD .GT. 20) THEN
            WRITE(LUPRI,'(A)') 'PRIEXP:'
            WRITE(LUPRI,'(I5,F15.5)') (KK,PRIEXP(KK),KK=1,IPRIM)
         END IF
         IF (NBASIS .GT. MXCORB) GOTO 5010
         NSMALL = NBASIS - NLARGE
         NPBAS  = IPRIMD
         IF (NPBAS .GT. MXPRIM)  GOTO 5020
         NPSHEL  = IPRIM
         NPSML   = IPRIMD - NPLRG
      END IF
CNECgh980808
      NODD = 1 - MOD(NBASIS,2)
C
      KKVAL = 1
      KMVAL = KKVAL + MXAQN
      KNVAL = KMVAL + MXAQN
      KIREP = KNVAL + MXAQN
      KLAST = KIREP + MXCORB
      IF (KLAST .GT. LWORK) GOTO 5030
      CALL SYMPRO(WORK(KKVAL),WORK(KMVAL),WORK(KNVAL),WORK(KIREP),
     &            DOOWN)
C
C     ***************************************
C     ***** Orbital Symmetry Processing *****
C     ***************************************
C
C
      RETURN
C
C       Error messages:
C
 5000 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> BASPRO error, number of shells                    ',KMAX,
     *  '                   current maximum number              ',MXSHEL
        CALL QUIT('BASPRO: Too many shells')
 5010 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> BASPRO error, number of contracted basis functions',
     *  NBASIS,
     *  '                   current maximum number              ',MXCORB
        CALL QUIT('BASPRO: Too many contracted basis functions')
 5020 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> BASPRO error, number of primitive basis functions',NPBAS,
     *  '                   current maximum number             ',MXPRIM
        CALL QUIT('BASPRO: Too many primitives')
 5030 CONTINUE
        CALL STOPIT('BASPRO','SYMPRO',KLAST,LWORK)
 5040 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> BASPRO error, # of shells when adding Huckel orbitals',
     &     KMAX,
     *  '                   current maximum number                 ',
     &     MXSHEL
        CALL QUIT('BASPRO: Too many shells')
 5050 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> BASPRO error, # of contracted bf. after adding Huckel '//
     &     'orbitals',NBASIS,
     *  '                   current maximum number                  '//
     &     '        ',MXCORB
        CALL QUIT('BASPRO: Too many contracted basis functions')
 5060 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> BASPRO error, n# of primitive bf after adding Huckel '//
     &     'orbitals',NPBAS,
     *  '                   current maximum number                 '//
     &     '        ',MXPRIM
        CALL QUIT('BASPRO: Too many primitives')
      END
C  /* Deck basout */
      SUBROUTINE BASOUT(WORK,LWORK,NONTYP,NONT,IQM,NBLCK,JCO,NUC,NRC,
     &                  SEG,ALPHA,CPRIM,CPRIMU,KATOM,KANG,
     &                  KBLOCK,KPRIM,KAOVEC,KASYM,NSYMOP,HERMIT)
C*****************************************************************************
C
C     Print orbital and geometry input data
C
C*****************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
#include <cbirea.h>
      DIMENSION WORK(LWORK)
      LOGICAL SEG,HERMIT,NRMPRI
      DIMENSION NONT(KATOM),IQM(KATOM,2),JCO(KANG,KATOM,2),
     &          NBLCK(KATOM,2),NUC(KBLOCK,2),NRC(KBLOCK,2),
     &          SEG(KBLOCK,2),
     &          ALPHA(KPRIM,KBLOCK,2),CPRIM(KPRIM,KPRIM,KBLOCK,2)
      CHARACTER SPDCAR*1,TSTRING*(6*MXQN+3),TSTRI2*(6*MXQN+3),
     &          KASYM(3,3)*1
#include <molde.h>
#include <ccom.h>
#include <nuclei.h>
#include <frame.h>
#include <inftap.h>
#include <infpar.h>
#include <shells.h>
#include <primit.h>
#include <symmet.h>
#include <aosotr.h>
#include <r12int.h>
#include <ibtfun.h>
C
C     ******************************************
C     ***** Printing of basis information  *****
C     ******************************************
C
      IF (IPREAD .GT. 0) THEN
         CALL HEADER('Atoms and basis sets',1)
         WRITE (LUPRI,'(A,I5 )') '  Number of atom types: ',NONTYP
         WRITE (LUPRI,'(A,I5/)') '  Total number of atoms:',NUCDEP
         IF (BASIS) THEN
          IF (LMULBS) THEN
C           Output for multiple basis sets (WK/UniKA/04-11-2002).
            DO IMULBS = 1, NMULBS
             DO ILEN = LEN(MULNAM(IMULBS)),1,-1
              IF (MULNAM(IMULBS)(ILEN:ILEN) .NE. ' ') GO TO 331
             END DO
 331         CONTINUE
             WRITE (LUPRI,'(A,I2,A/)') '  Basis-set',IMULBS,
     &      ' refers to the basis "'//MULNAM(IMULBS)(1:ILEN)//
     &      '" from the basis-set library.'
            ENDDO 
          ELSE
            DO ILEN = LEN(BASNAM),1,-1
              IF (BASNAM(ILEN:ILEN) .NE. ' ') GO TO 332
            END DO
 332        CONTINUE
            WRITE (LUPRI,'(3A/)') '  Basis set used is "',
     &      BASNAM(1:ILEN),'" from the basis set library.'
          END IF
         END IF
         IF (LUCME.GT.0) THEN
            WRITE (LUCME,'(A,I5 )') '  Number of atom types: ',NONTYP
            WRITE (LUCME,'(A,I5/)') '  Total number of atoms:',NUCDEP
         END IF
      END IF
      IBLOCK = 1
      IBLCKS = 1
      ICENT  = 0
      IF (IPREAD .GT. 0) THEN
       IF (LMULBS) THEN
C        Output for multiple basis sets (WK/UniKA/04-11-2002).
         WRITE (LUPRI,'(2X,A)')
     &        'label  basis   atoms  charge'//
     &        '   prim    cont     basis   '
         WRITE (LUPRI,'(2X,78A1)') ('-',I=1,78)
         IF (LUCME.GT.0) THEN
             WRITE (LUCME,'(2X,A)')
     &           'label  basis   atoms  charge'//
     &           '   prim    cont     basis   '
             WRITE (LUCME,'(2X,78A1)') ('-',I=1,78)
         END IF
       ELSE
         WRITE (LUPRI,'(2X,A)')
     &        'label    atoms   charge   prim    cont     basis   '
         WRITE (LUPRI,'(2X,70A1)') ('-',I=1,70)
         IF (LUCME.GT.0) THEN
            WRITE (LUCME,'(2X,A)')
     &        'label    atoms   charge   prim    cont     basis   '
            WRITE (LUCME,'(2X,70A1)') ('-',I=1,70)
         END IF
       END IF
      END IF
      NCHTOT = 0
      DO 100 I = 1,NONTYP
         IF (IQM(I,1).GT.0) THEN
            TSTRING = ' '
            NPRIM = 0
            NBAS  = 0
            CALL BASTYP(IQM(I,1),JCO(1,I,1),NRC(IBLOCK,1),
     &                  NUC(IBLOCK,1),
     &                  KAOVEC,NPRIM,NBAS,TSTRING)
         ELSE
            TSTRING = 'Point Charge'
         END IF
         IF (IQM(I,2).GT.0) THEN
            TSTRI2 = ' '
            NPRIMS = 0
            NBASS = 0
            CALL BASTYP(IQM(I,2),JCO(1,I,2),NRC(IBLCKS,2),
     +                  NUC(IBLCKS,2),KAOVEC,NPRIMS,NBASS,TSTRI2)
         ELSE
            TSTRI2 = 'Point Charge'
         END IF
         DO 20 N = 1,NONT(I)
            ICENT  = ICENT + 1
            NCHARG = NINT(CHARGE(ICENT))
            NCHTOT = NCHTOT + NUCDEG(ICENT)*NCHARG
            IF (IPREAD .GT. 0) THEN
               IF(DIRAC) THEN
                  WRITE (LUPRI,'(2X,A4,1X,4I8,6X,2A)') NAMN(ICENT),
     &                   NUCDEG(ICENT),NCHARG,NPRIM,NBAS,'L - ',TSTRING
                  WRITE (LUPRI,'(23X,2I8,6X,2A)')
     &                   NPRIMS,NBASS,'S - ',TSTRI2
               ELSE
                IF (LMULBS) THEN
C                 Output for multiple basis sets (WK/UniKA/04-11-2002).
                  WRITE (LUPRI,'(2X,A4,1X,I5,4I8,6X,A)') NAMN(ICENT),
     &                   MULBSI(ICENT),
     &                   NUCDEG(ICENT),NCHARG,NPRIM,NBAS,TSTRING
                  IF (LUCME.GT.0)
     &               WRITE (LUCME,'(2X,A4,1X,I5,4I8,6X,A)') NAMN(ICENT),
     &                   MULBSI(ICENT),
     &                   NUCDEG(ICENT),NCHARG,NPRIM,NBAS,TSTRING
                ELSE
                  WRITE (LUPRI,'(2X,A4,1X,4I8,6X,A)') NAMN(ICENT),
     &                   NUCDEG(ICENT),NCHARG,NPRIM,NBAS,TSTRING
                  IF (LUCME.GT.0)
     &               WRITE (LUCME,'(2X,A4,1X,4I8,6X,A)') NAMN(ICENT),
     &                   NUCDEG(ICENT),NCHARG,NPRIM,NBAS,TSTRING
                END IF
               ENDIF
            END IF
   20    CONTINUE
         IBLOCK = IBLOCK + NBLCK(I,1)
         IBLCKS = IBLCKS + NBLCK(I,2)
  100 CONTINUE
      IF (IPREAD .GT. 0) THEN
         IF(DIRAC) THEN
            WRITE (LUPRI,'(2X,70A1)') ('-',I=1,70)
            WRITE(LUPRI,'(23X,2I8,3X,A)')
     &            NPLRG,NLARGE,'L - large components'
            WRITE(LUPRI,'(23X,2I8,3X,A)')
     &            NPSML,NSMALL,'S - small components'
         ENDIF
         IF (LMULBS) THEN
C           Output for multiple basis sets (WK/UniKA/04-11-2002).
            WRITE (LUPRI,'(2X,78A1)') ('-',I=1,78)
            WRITE (LUPRI,'(2X,A,I12,3I8)')
     &         'total:',NUCDEP,NCHTOT,NPBAS,NBASIS
            IF (LUCME.GT.0) WRITE (LUCME,'(2X,A,I12,3I8,6X,/)')
     &         'total:',NUCDEP,NCHTOT,NPBAS,NBASIS
            WRITE (LUPRI,'(2X,78A1)') ('-',I=1,78)
         ELSE
            WRITE (LUPRI,'(2X,70A1)') ('-',I=1,70)
            WRITE (LUPRI,'(2X,A,I7,3I8)')
     &         'total:',NUCDEP,NCHTOT,NPBAS,NBASIS
            IF (LUCME.GT.0) WRITE (LUCME,'(2X,A,I7,3I8,6X,/)')
     &         'total:',NUCDEP,NCHTOT,NPBAS,NBASIS
            WRITE (LUPRI,'(2X,70A1)') ('-',I=1,70)
         END IF
         IF (NHTYP .GT. 2) THEN
            IF(DOCART) THEN
               WRITE (LUPRI,'(A)') '  Cartesian basis used. ',
     &     '  (Note that d, f, ... atomic GTOs are not all normalized.)'
               IF (LUCME.GT.0)
     &         WRITE (LUCME,'(A)') '  Cartesian basis used.'
            ELSE
               WRITE (LUPRI,'(A)') '  Spherical harmonic basis used.'
               IF (LUCME.GT.0)
     &         WRITE (LUCME,'(A)') '  Spherical harmonic basis used.'
            ENDIF
         END IF
         WRITE (LUPRI,'(/A,1P,D10.2)')
     &      '  Threshold for integrals:',THRS
      END IF
C
C     ******************************************
C     ***** Printing of atomic coordinates *****
C     ******************************************
C
      CALL PRICAR(WORK,LWORK)
C
 1010 FORMAT(I14,' large AO-blocks of ',A1,' type')
 1020 FORMAT(I14,' small AO-blocks of ',A1,' type')
      KIPCON = 1
      KLAST  = KIPCON + KPRIM
      IF (KLAST.GT.LWORK) CALL STOPIT('BASOUT','ORBOUT',KLAST,LWORK)
      IF (.NOT.SLAVE)
     &     CALL MOLOUT(NONTYP,NONT,IQM(1,1),NBLCK(1,1),
     &                 JCO(1,1,1),NUC(1,1),NRC(1,1),SEG(1,1),
     &                 WORK(KIPCON),KATOM,KANG,KBLOCK,
     &                 KPRIM,CPRIMU,NRMPRI,KASYM,NSYMOP)
      IF (IPREAD .GE. 2) THEN
C*****************************************************************************
C        Print information about large component basis
C*****************************************************************************
         IF(NLARGE.GT.0) THEN
            IF (DIRAC) CALL HEADER('Large Components Basis',-1)
            NRMPRI = .FALSE.
            CALL ORBOUT(NONTYP,NONT,IQM(1,1),NBLCK(1,1),JCO(1,1,1),
     &                  NUC(1,1),NRC(1,1),SEG(1,1),
     &                  WORK(KIPCON),KATOM,KANG,KBLOCK,KPRIM,
     &                  CPRIMU,NRMPRI)
            IF (IPREAD .GT. 2) THEN
               NRMPRI = .TRUE.
               CALL ORBOUT(NONTYP,NONT,IQM(1,1),NBLCK(1,1),JCO(1,1,1),
     &                     NUC(1,1),NRC(1,1),SEG(1,1),
     &                     WORK(KIPCON),KATOM,KANG,KBLOCK,KPRIM,
     &                     CPRIM,NRMPRI)
            END IF
         END IF
C*****************************************************************************
C        Print information about small component basis
C*****************************************************************************
         IF (NBASIS.GT.NLARGE) THEN
            CALL HEADER('Small Components Basis',-1)
            NRMPRI = .FALSE.
            CALL ORBOUT(NONTYP,NONT,IQM(1,2),NBLCK(1,2),JCO(1,1,2),
     &                  NUC(1,2),NRC(1,2),SEG(1,2),
     &                  WORK(KIPCON),KATOM,KANG,KBLOCK,KPRIM,
     &                  CPRIMU,NRMPRI)
            IF (IPREAD .GT. 2) THEN
               NRMPRI = .TRUE.
               CALL ORBOUT(NONTYP,NONT,IQM(1,2),NBLCK(1,2),JCO(1,1,2),
     &                     NUC(1,2),NRC(1,2),SEG(1,2),
     &                     WORK(KIPCON),KATOM,KANG,KBLOCK,KPRIM,
     &                     CPRIM,NRMPRI)
            END IF
         END IF
      END IF
C
C     Symmetry basis:
C
      IF (.NOT.SLAVE) CALL SYMOUT
C
C     Symmetrized magnetic moments
C
      IF (HERMIT) CALL MAGCOR(IPREAD)
C
C     ***************************
C     ***** Determine IAOAO *****
C     ***************************
C
      CALL AOTOAO(IAOAO,IPREAD)
C
C     **************************
C     **** Determine ICNTAO ****
C     **************************
C
      CALL CNTAO(IPREAD)
C
      END
C  /* Deck bastyp */
      SUBROUTINE BASTYP(IQM,JCO,NRC,NUC,NBLOCK,NPRIM,NBAS,TSTRING)
C*****************************************************************************
C
C     Generate string : Uncontracted/contracted basis functions
C
C*****************************************************************************
#include <implicit.h>
#include <maxaqn.h>
      CHARACTER TSTRING*(6*MXAQN+3),SPDCAR*1
      DIMENSION JCO(IQM),NRC(NBLOCK),NUC(NBLOCK)
#include <ccom.h>
C*****************************************************************************
      IND = 1
      TSTRING(IND:IND) = '['
C*****************************************************************************
C * P R I M I T I V E S:
C*****************************************************************************
      IBLOCK = 0
      NPRIM = 0
      DO 100 I = 1,IQM
         IPRIM  = 0
         ISHELL = 0
         NCOMP = KHK(I)
         DO 200 J = 1,JCO(I)
            IBLOCK = IBLOCK + 1
            IPRIM  = IPRIM  + NUC(IBLOCK)
            NPRIM = NPRIM + NCOMP*NUC(IBLOCK)
  200    CONTINUE
         IF (IPRIM.GT.0) THEN
            IF (IPRIM.GE.10) THEN
#if defined (SYS_NEC)
C NECyuji
               NDIG = INT(DLOG10(DBLE(IPRIM))+1)
#else
               NDIG = INT(LOG10(FLOAT(IPRIM))+1)
#endif
               ITEN = 10**NDIG
               DO 300 K = NDIG,1,-1
                  ITEN = ITEN/10
                  IND = IND + 1
                  IDIG = ICHAR('0') + INT(IPRIM/ITEN)
                  TSTRING(IND:IND) = CHAR(IDIG)
                  IPRIM=MOD(IPRIM,ITEN)
  300          CONTINUE
            ELSE
               IND = IND + 1
               IDIG = ICHAR('0') + IPRIM
               TSTRING(IND:IND) = CHAR(IDIG)
            ENDIF
            IND = IND + 1
            TSTRING(IND:IND) = SPDCAR(I-1)
         END IF
  100 CONTINUE
C*****************************************************************************
      IND = IND + 1
      TSTRING(IND:IND) = '|'
C*****************************************************************************
C * S H E L L S:
C*****************************************************************************
      IBLOCK = 0
      NBAS = 0
      DO 400 I = 1,IQM
         ISHELL = 0
         NCOMP = KHK(I)
         DO 500 J = 1,JCO(I)
            IBLOCK = IBLOCK + 1
            ISHELL  = ISHELL  + NRC(IBLOCK)
            NBAS = NBAS + NCOMP*NRC(IBLOCK)
  500    CONTINUE
         IF(ISHELL.GT.0) THEN
           IF (ISHELL.GE.10) THEN
#if defined (SYS_NEC)
C NECyuji
              NDIG = INT(DLOG10(DBLE(ISHELL ))+1)
#else
              NDIG = INT(LOG10(FLOAT(ISHELL))+1)
#endif
              ITEN = 10**NDIG
              DO 600 K = NDIG,1,-1
                 ITEN = ITEN/10
                 IND = IND + 1
                 IDIG = ICHAR('0') + INT(ISHELL/ITEN)
                 TSTRING(IND:IND) = CHAR(IDIG)
                 ISHELL=MOD(ISHELL,ITEN)
  600         CONTINUE
           ELSE
              IND = IND + 1
              IDIG = ICHAR('0') + ISHELL
              TSTRING(IND:IND) = CHAR(IDIG)
           ENDIF
           IND = IND + 1
           TSTRING(IND:IND) = SPDCAR(I-1)
         ENDIF
  400 CONTINUE
C*****************************************************************************
      IND = IND + 1
      TSTRING(IND:IND) = ']'
      END
C  /* Deck gtoinp */
      SUBROUTINE GTOINP(LUINFO,IQM,JCO,NUC,NRC,SEG,ALPHA,CPRIM,
     &                  CPRIMU,NBLOCK,KAOVEC,KPRIM)
#include <implicit.h>
#include <priunit.h>
#include <mxcent.h>
#include <maxaqn.h>
      PARAMETER (DSM=1.0D-30)
      CHARACTER*1 SPDCAR, FRMT
      CHARACTER*8 FMT1
      CHARACTER*12 FMT2
      LOGICAL SEG, FREE, SEGIJ
      DIMENSION JCO(IQM),NUC(KAOVEC),NRC(KAOVEC),SEG(KAOVEC),
     &          ALPHA(KPRIM,KAOVEC),
     &          CPRIM(KPRIM,KPRIM,KAOVEC),CPRIMU(KPRIM,KPRIM,KAOVEC)
#include <cbirea.h>
#include <molinp.h>
#include <ccom.h>
C
      NBLOCK = 0
      DO 100 I = 1, IQM
         DO 200 J = 1, JCO(I)
            NBLOCK = NBLOCK + 1
            IF(NBLOCK.GT.KAOVEC) GOTO 5000
C
            CALL DZERO(ALPHA (1,  NBLOCK),KPRIM)
            CALL DZERO(CPRIMU(1,1,NBLOCK),KPRIM*KPRIM)
            CALL DZERO(CPRIM (1,1,NBLOCK),KPRIM*KPRIM)
C
C           Card 8:
C
C           NUC - number of uncontracted shells in AO-block
C           NRC - number of contracted shells in AO-block
C
            CALL RDLINE(LUINFO)
            IF (J. EQ. 1) THEN
               READ (MLINE(NMLINE),'(BN,A1,I4,I5)')
     &              FRMT,NUCIJ,NRCIJ
            ELSE
               READ (MLINE(NMLINE),'(BN,A1,I4,1I5)') FRMT,NUCIJ,NRCIJ
            END IF
            IF (INPTST .OR. IPREAD .GT. 3) THEN
               WRITE(LUPRI,'(3X,A,I2,A,I4)') 'L= ',(I-1),'  Block: ',J
Chj-aug99:     if (uncont) force uncontracted in ACPORB
               MRCIJ = NRCIJ
               IF (UNCONT) MRCIJ = 0
               WRITE(LUPRI,'(6X,A,I5)') 'Primitives:  ',NUCIJ,
     &                                  'Shells    :  ',MRCIJ
               CALL FLSHFO(LUPRI)
            END IF
            SEGIJ = NRCIJ .GE. 0
            NUCIJ = ABS(NUCIJ)
            NRCIJ = ABS(NRCIJ)
            IF (NUCIJ.GT.KPRIM) GOTO 5010
            IF (NRCIJ.GT.KPRIM) GOTO 5020
C
C           Read in exponents and contraction coefficients
C
            CALL ACPORB(LUINFO,FRMT,NUCIJ,NRCIJ,ALPHA(1,NBLOCK),
     &                  CPRIMU(1,1,NBLOCK),KPRIM)
C
C           Identify segmented contractions
C
            CALL SEGORB(SEGIJ,NUCIJ,NRCIJ,CPRIMU(1,1,NBLOCK),KPRIM,DSM)
            SEG(NBLOCK) = SEGIJ
C
C        Reorder primitive orbitals
C
            CALL PRIORD(ALPHA(1,NBLOCK),CPRIMU(1,1,NBLOCK),NUCIJ,NRCIJ,
     &                  SEG(NBLOCK),KPRIM,DSM)
C
C        Normalize orbitals
C
            CALL NRMORB(I,NRCIJ,NUCIJ,ALPHA(1,NBLOCK),
     &                  CPRIM(1,1,NBLOCK),CPRIMU(1,1,NBLOCK),
     &                  KPRIM,NBLOCK)
C
            NUC(NBLOCK) = NUCIJ
            NRC(NBLOCK) = NRCIJ
 200     CONTINUE
  100 CONTINUE
      RETURN
C
C     Error messages:
C
 5000 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> GTOINP error, number of AO-blocks            ',NBLOCK,
     *  '                   current maximum number         ',KAOVEC
        CALL QUIT('Too many AO-blocks')
 5010 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> GTOINP error,'//
     *  'number of primitives per block      ',NUCIJ,
     *  '                   current maximum number              ',KPRIM
        CALL QUIT('Too many primitives')
 5020 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> GTOINP error, number of contracted functions      ',
     *  NRCIJ,
     *  '                   current maximum number              ',KPRIM
        CALL QUIT('Too many contracted functions')
      END
C  /* Deck cmbas */
      SUBROUTINE CMBAS(IQM,JCO,NUC,NRC,SEG,ALPHA,CPRIM,
     &                  CPRIMU,NBLOCK,KAOVEC,KPRIM)
#include <implicit.h>
#include <priunit.h>
#include <mxcent.h>
#include <maxaqn.h>
      LOGICAL SEG, FREE, SEGIJ
      DIMENSION JCO(IQM),NUC(KAOVEC),NRC(KAOVEC),SEG(KAOVEC),
     &          ALPHA(KPRIM,KAOVEC),
     &          CPRIM(KPRIM,KPRIM,KAOVEC),CPRIMU(KPRIM,KPRIM,KAOVEC),
     &          BASA(0:4), BASB(0:4)
#include <cbirea.h>
#include <molinp.h>
#include <ccom.h>
      DATA (BASA(I),I=0,4) /0.584342, 0.452615, 0.382362, 0.337027, 
     &                      0.304679/
      DATA (BASB(I),I=0,4) /0.424483, 0.309805, 0.251333, 0.215013,
     &                      0.189944/
C
      NBLOCK = 0
      DO 100 I = 1, IQM
         NBLOCK = NBLOCK + 1
         IF(NBLOCK.GT.KAOVEC) GOTO 5000
C
         CALL DZERO(ALPHA (1,  NBLOCK),KPRIM)
         CALL DZERO(CPRIMU(1,1,NBLOCK),KPRIM*KPRIM)
         CALL DZERO(CPRIM (1,1,NBLOCK),KPRIM*KPRIM)
C
         NUCI = 0
         NRCI = 0
         SEGIJ  = .TRUE.
         DO 110 J = NCMSTR, NCMEND
            NUCI = NUCI + 1
            NRCI = NRCI + 1
            IF (NUCI.GT.KPRIM) GOTO 5010
            IF (NRCI.GT.KPRIM) GOTO 5020
            ALPHA(NUCI,NBLOCK) = ((ZCMVAL/J)/
     &                           ((BASA(I-1)*J)/2+BASB(I-1)))**2
            CPRIMU(NUCI,NRCI,NBLOCK) = 1.0D0
  110    CONTINUE
         NUC(NBLOCK) = NUCI
         NRC(NBLOCK) = NRCI
C
         JCO(I) = 1
         SEG(NBLOCK) = SEGIJ
C
C        Normalize orbitals
C
         CALL NRMORB(I,NRCI,NUCI,ALPHA(1,NBLOCK),CPRIM(1,1,NBLOCK),
     &               CPRIMU(1,1,NBLOCK),KPRIM,NBLOCK)
C
  100 CONTINUE
      RETURN
C
C     Error messages:
C
 5000 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> CMBAS  error, number of AO-blocks            ',NBLOCK,
     *  '                   current maximum number         ',KAOVEC
        CALL QUIT('Too many AO-blocks')
 5010 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> CMBAS  error,'//
     *  'number of primitives per block      ',NUCI,
     *  '                   current maximum number              ',KPRIM
        CALL QUIT('Too many primitives')
 5020 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *  ' >>> CMBAS  error, number of contracted functions      ',
     *  NRCI,
     *  '                   current maximum number              ',KPRIM
        CALL QUIT('Too many contracted functions')
      END
C  /* Deck acporb */
      SUBROUTINE ACPORB(LUINFO,FRMT,NUCIJ,NRCIJ,ALPHA,CPRIMU,KPRIM)
#include <implicit.h>
#include <dummy.h>
#include <priunit.h>
#include <mxcent.h>
      PARAMETER(D1 = 1.0D0, D0 = 0.0D0)
      CHARACTER*1 FRMT
      CHARACTER*11 FMT1
      CHARACTER*15 FMT2
      CHARACTER*10 FMT3
      LOGICAL FREE
      DIMENSION ALPHA(KPRIM), CPRIMU(KPRIM,KPRIM)
#include <cbirea.h>
#include <molinp.h>
C
C     Card 9:
C
C     ALPHA  - exponent of primitive
C     CPRIMU - unnormalized contraction coefficients
C
      IF (FRMT .EQ. 'F' .OR. FRMT .EQ. 'f') THEN
         FREE = .TRUE.
      ELSE IF (FRMT .EQ. 'H' .OR. FRMT .EQ. 'h') THEN
         FREE = .FALSE.
         NCOL = 4
         FMT1 = '(BN,4F20.0)'
         FMT2 = '(BN,20X,3F20.0)'
         FMT3 = '(BN,F20.0)'
      ELSE
         FREE = .FALSE.
         NCOL = 8
         FMT1 = '(BN,8F10.0)'
         FMT2 = '(BN,10X,7F10.0)'
         FMT3 = '(BN,F10.0)'
      END IF
      IF(NRCIJ.NE.0) THEN
        DO 100 L = 1, NUCIJ
           CALL RDLINE(LUINFO)
           IF (FREE) THEN
#if defined (SYS_CRAY) || defined (VAR_NOFREE) || defined (SYS_T3D) || defined (SYS_T90)
              ISTART = 1
              CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,ALPHA(L),'REA')
              DO M = 1, NRCIJ
                 CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,
     &                       CPRIMU(L,M),'REA')
              END DO
#else
              if (wrtlin) then 
                 write(lupri,*) mline(nmline)
                 call flush(lupri)
              endif
              
              READ (MLINE(NMLINE),*) ALPHA(L), (CPRIMU(L,M),M=1,NRCIJ)
#endif
           ELSE
              READ (MLINE(NMLINE),FMT1) ALPHA(L),
     &           (CPRIMU(L,M), M = 1, MIN(NRCIJ,NCOL - 1))
              DO 200 K = 2, (NRCIJ - 1)/(NCOL - 1) + 1
                 CALL RDLINE(LUINFO)
                 READ (MLINE(NMLINE),FMT2) (CPRIMU(L,M),
     &              M = 1 + (NCOL-1)*(K-1), MIN(NRCIJ,(NCOL-1)*K))
  200         CONTINUE
           END IF
  100   CONTINUE
C
Chj-aug99:
C     If (uncont) force uncontracted
C     (this cannot be done earlier, because we must read CPRIMU from file
C      to position LUINFO correctly)
C
          IF (UNCONT) THEN
            NRCIJ = NUCIJ
            DO IJ = 1, NUCIJ
               DO JI = 1, IJ - 1
                  CPRIMU(IJ,JI) = D0
                  CPRIMU(JI,IJ) = D0
               END DO
               CPRIMU(IJ,IJ) = D1
            END DO
          END IF
      ELSE
C
C     Read only exponents
C
        NRCIJ = NUCIJ
        DO 300 L = 1, NUCIJ
           CALL RDLINE(LUINFO)
           IF (FREE) THEN
#if defined (SYS_CRAY) || defined (VAR_NOFREE) || defined (SYS_T3D) || defined (SYS_T90)
              ISTART = 1
              CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,ALPHA(L),'REA')
#else
              READ (MLINE(NMLINE),*) ALPHA(L)
#endif
           ELSE
              READ (MLINE(NMLINE),FMT3) ALPHA(L)
           END IF
           CPRIMU(L,L) = D1
  300   CONTINUE
      ENDIF
C
C     Test print
C
      IF (INPTST .OR. IPREAD .GT. 3) THEN
         WRITE(LUPRI,'(A)') 'Contraction matrix:'
         DO 400 L = 1, NUCIJ
            WRITE (LUPRI,'(E16.10)') ALPHA(L)
            WRITE (LUPRI,'(6(2X,F10.8))') (CPRIMU(L,M),M=1,NRCIJ)
  400    CONTINUE
      END IF
      RETURN
      END
C  /* Deck segorb */
      SUBROUTINE SEGORB(SEGIJ,NUCIJ,NRCIJ,CPRIMU,KPRIM,DSM)
#include <implicit.h>
#include <priunit.h>
      LOGICAL SEGIJ
      DIMENSION CPRIMU(KPRIM,KPRIM)
C
      DO 100 L = 1, NUCIJ
         NONZER = 0
         DO 200 M = 1, NRCIJ
            IF (ABS(CPRIMU(L,M)).GT.DSM) NONZER = NONZER + 1
  200    CONTINUE
         SEGIJ = SEGIJ .AND. (NONZER .LE. 1)
  100 CONTINUE
      RETURN
      END
C  /* Deck nrmorb */
      SUBROUTINE NRMORB(I,NRCIJ,NUCIJ,ALPHA,CPRIM,CPRIMU,KPRIM,NBLOCK)
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
      PARAMETER (D0 = 0.0D0, D1 = 1.0D0, D2 = 2.0D0, D4 = 4.0D0,
     &           DP25 = 0.25D0, DP5 = 0.5D0, DP75 = 0.75D0,
     &           THRMIN = 1.D-17)
      CHARACTER*1 SPDCAR
      DIMENSION ALPHA(KPRIM), CPRIM(KPRIM,KPRIM), CPRIMU(KPRIM,KPRIM)
C
      PIPPI = (DP5/PI)**DP75
      DO 100 N = 1, NRCIJ
         SUM = D0
         DO 200 L = 1, NUCIJ
         DO 200 M = 1, NUCIJ
            T = D2*SQRT(ALPHA(L)*ALPHA(M))/(ALPHA(L)+ALPHA(M))
            SUM = SUM + CPRIMU(L,N)*CPRIMU(M,N)*(T**(I + DP5))
  200    CONTINUE
         IF (SQRT(SUM) .LT. THRMIN) GOTO 1000
         SUM=D1/SQRT(SUM)
         DO 300 L=1, NUCIJ
            CPRIM(L,N)=CPRIMU(L,N)*SUM*(D4*ALPHA(L))**(DP5*I+DP25)*PIPPI
  300    CONTINUE
  100 CONTINUE
      RETURN
 1000 CONTINUE
        WRITE (LUPRI,'(/1X,A,2(I3,A),A1,A/A,2I4)')
     &    'INPUT ERROR: CGTO no.',N,' for block',NBLOCK,
     &    ' of ',SPDCAR(I-1),' type has zero norm.',
     &    ' Contraction matrix: ',NUCIJ,NRCIJ
         CALL QUIT('CGTO with zero norm.')
      END
C  /* Deck orbpro */
      SUBROUTINE ORBPRO(NONTYP,NONT,IQM,NBLCK,JCO,NUC,NRC,SEG,
     &           ALPHA,CPRIM,CPRIMU,KATOM,KANG,KBLOCK,KPRIM,
     &           ISHELL,IPRIM,IPRIMD,IORB,IORBD,LCOMP)
C******************************************************************************
C
C     Process basis data
C
C******************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
      PARAMETER (D0 = 0.0D0, D2 = 2.0D0, D4 = 4.0D0, DP5 = 0.50D0,
     &           DP75 = 0.75D0)
C
#include <cbirea.h>
      LOGICAL SEG,SPHER
      DIMENSION NONT(KATOM),IQM(KATOM),NBLCK(KATOM),
     &          JCO(KANG,KATOM),NUC(KBLOCK),NRC(KBLOCK),
     &          SEG(KBLOCK),ALPHA(KPRIM,KBLOCK),
     &          CPRIM(KPRIM,KPRIM,KBLOCK),CPRIMU(KPRIM,KPRIM,KBLOCK)
#include <ccom.h>
#include <nuclei.h>
#include <primit.h>
#include <shells.h>
#include <symmet.h>
#include <r12int.h>
#include <aosotr.h>
#include <gnrinf.h>
C
C
#include <ibtfun.h>
      ICENT  = 0
      IBLOCK = 0
      DO 10 I = 1,NONTYP
         DO 20 N = 1,NONT(I)
            ICENT = ICENT + 1
            KBCH = IBLOCK
            NDEG = NUCDEG(ICENT)
            DO 30 J = 1,IQM(I)
               KKK = 0
               NCOMP = KHK(J)
               NCCMP = KCK(J)
               SPHER = SPH(J)
               DO 40 K = 1, JCO(J,I)
                  KBCH = KBCH + 1
                  NCONT = NRC(KBCH)
                  IF(NCONT.GT.MXCONT) GOTO 5000
                  DO 50 KK = 1, NCONT
                     KKK = KKK + 1
                     ISHELL = ISHELL + 1
C*****************************************************************************
C     Data on the AO-block associated with a given shell(ISHELL):
C       NUCO    - number of uncontracted functions
C       NRCO    - number of contracted functions
C     Data on a given shell in an AO-block:
C       NCENT   - index of symmetry independent center
C       NUMCF   - index of shell in AO-block
C       NBCH    - index of block in AO-vector
C       LAMN    - name of center
C       ISTBAO  - stabiliser: basic sym. op. that do not move center
C       NHKT    - angular quantum number (s=1,p=2,d=3 etc.)
C       KHKT    - number of spherical (Cartesian) components
C       KCKT    - number of Cartesian components
C       SEGM    - segmented contraction
C       LCLASS  - component: large(1) or small(0)
C       CENT    - coordinates of center
C*****************************************************************************
                     NUCO  (ISHELL) = NUC(KBCH)
                     NRCO  (ISHELL) = NCONT
                     JSTRT (ISHELL) = IPRIM
                     NSTRT (ISHELL) = IORB
                     KSTRT (ISHELL) = IORBD
                     NCENT (ISHELL) = ICENT
                     NUMCF (ISHELL) = KK
                     NUMCFT(ISHELL) = KKK
                     NBCH  (ISHELL) = KBCH
                     SHARE (ISHELL) = .FALSE.
                     ISTBAO(ISHELL) = ISTBNU(ICENT)
                     NHKT  (ISHELL) = J
                     KHKT  (ISHELL) = NCOMP
                     SPHR  (ISHELL) = SPHER
                     KCKT  (ISHELL) = NCCMP
                     SEGM  (ISHELL) = SEG(KBCH)
                     LCLASS(ISHELL) = LCOMP
                     CENT(ISHELL,1,1) = CORD(1,ICENT)
                     CENT(ISHELL,2,1) = CORD(2,ICENT)
                     CENT(ISHELL,3,1) = CORD(3,ICENT)
C                    Basis-set identifier (WK/UniKa/04-11-2002).
                     MBSID(ISHELL) = MULBSI(ICENT)
                     IORB  = IORB  + NCOMP
                     IORBD = IORBD + NCOMP*NDEG
                     IF (.NOT. SEGM(ISHELL) .AND. LCOMP .EQ. 1)
     &                         SEGBAS = .FALSE.
   50             CONTINUE
                  DO 60 L = 1, NUC(KBCH)
                     IPRIM = IPRIM + 1
C*****************************************************************************
C       PRIEXP  - exponent of primitive shell
C       CCO     - unnormalized contraction coefficient
C       PRICCF  - normalized contraction coefficient
C       PRICRX  - x-coordinate of center
C       PRICRY  - y-coordiante of center
C       PRICRZ  - z-coordinate of center
C*****************************************************************************
                     PRIEXP(IPRIM) = ALPHA(L,KBCH)
                     DO 70  M = 1, NCONT
                        PRICCF(IPRIM,M) = CPRIM(L,M,KBCH)
   70                CONTINUE
                     PRICRX(IPRIM) = CORD(1,ICENT)
                     PRICRY(IPRIM) = CORD(2,ICENT)
                     PRICRZ(IPRIM) = CORD(3,ICENT)
                     IPRIMD = IPRIMD + NCOMP*NDEG
   60             CONTINUE
C
   40          CONTINUE
   30       CONTINUE
   20    CONTINUE
         IBLOCK = IBLOCK + NBLCK(I)
   10 CONTINUE
C
      RETURN
C
C       Error messages:
C
 5000 CONTINUE
        WRITE (LUPRI,'(/A,I6/A,I6)')
     *   ' >>> ORBPRO error, '//
     *   'no. of contracted functions per AO-block',NCONT,
     *   '                  '//
     *   ' current maximum number                  ',MXCONT
      CALL QUIT('Too many contracted per AO-block')
      END
C  /* Deck dkpro */
      SUBROUTINE DKPRO(NONTYP,NONT,IQM,NBLCK,JCO,NUC,NRC,SEG,
     &           ALPHA,CPRIM,CONTC,KATOM,KANG,KBLOCK,KPRIM,
     &           IPRIMD,IORBD)
C******************************************************************************
C
C     Set up a contraction matrix for use in contraction of 
C     Douglas-Kroll integrals
C
C******************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
#if defined (SYS_T3D)
      PARAMETER ( MAXPRD = 14 )
#else
      PARAMETER ( MAXPRD = 25 )
#endif
      PARAMETER (D0 = 0.0D0, D2 = 2.0D0, D4 = 4.0D0, DP5 = 0.50D0,
     &           DP75 = 0.75D0)
C
#include <cbirea.h>
      LOGICAL SEG,SPHER
      DIMENSION NONT(KATOM),IQM(KATOM),NBLCK(KATOM),
     &          JCO(KANG,KATOM),NUC(KBLOCK),NRC(KBLOCK),
     &          SEG(KBLOCK),ALPHA(KPRIM,KBLOCK),
     &          CPRIM(KPRIM,KPRIM,KBLOCK)
      DIMENSION CONTC(IPRIMD,IORBD)
      DIMENSION LPRIM(MAXPRD)
#include <ccom.h>
#include <nuclei.h>
#include <primit.h>
#include <shells.h>
#include <symmet.h>
#include <aosotr.h>
#include <gnrinf.h>
C
C
#include <ibtfun.h>
      ICENT  = 0
      IBLOCK = 0
      IPR    = 1
      IRB    = 1
      CALL DZERO(CONTC,IPRIMD*IORBD)
      DO 10 I = 1,NONTYP
         DO 20 N = 1,NONT(I)
            ICENT = ICENT + 1
            KBCH = IBLOCK
            NDEG = NUCDEG(ICENT)
            DO 30 J = 1,IQM(I)
               KKK = 0
               NCOMP = KHK(J)
               NCCMP = KCK(J)
               SPHER = SPH(J)
               DO 40 K = 1, JCO(J,I)
                  KBCH = KBCH + 1
                  NCONT = NRC(KBCH)
C
C     Quick sort of primitive exponents if necessary
C
                  DO L1 = 1, NUC(KBCH)
                     LPRIM(L1) = L1
                  END DO
                  DO L1 = 1, NUC(KBCH) - 1
                     DO L2 = L1 + 1, NUC(KBCH)
                        IF(ALPHA(L2,KBCH) .GT. ALPHA(L1,KBCH)) THEN
                           IDUM = LPRIM(L2)
                           LPRIM(L2) = LPRIM(L1)
                           LPRIM(L1) = IDUM
                        END IF
                     END DO
                  END DO
C
C     Core for setting up contraction matrix
C
                  DO ICOMP = 1, NCOMP
                     IF (ICOMP .GT. 1) THEN
                        IPR = IPR - NDEG*(NCOMP*NUC(KBCH) - 1)
                        IRB = IRB - NDEG*NCONT*NCOMP + 1
                     END IF
                     DO LJ = 1, NUC(KBCH)
                        L = LPRIM(LJ)
                        IF (L .GT. 1) IRB = IRB - NCONT*NCOMP*NDEG
     &                       - (NDEG - 1)
                        PRFA  = ((D2*PI)**(DP75))
     &                       *((D4*ALPHA(L,KBCH))**(-DP5*(J + DP5)))
                        DO IDEG = 1, NDEG
                           IF (IDEG .GT. 1) IRB =IRB
     &                          -NCONT*NCOMP*NDEG + 1
                           DO M = 1, NCONT
                              CONTC(IPR,IRB) = CPRIM(L,M,KBCH)*PRFA
                              IRB = IRB + NCOMP*NDEG
                           END DO
                           IPR = IPR + 1
                        END DO
                        IPR = IPR + NDEG*NCOMP - NDEG
                     END DO
                  END DO
                  IPR = IPR - NCOMP*NDEG + NDEG
                  IRB = IRB - NCOMP*NDEG + 1
C
   40          CONTINUE
   30       CONTINUE
   20    CONTINUE
         IBLOCK = IBLOCK + NBLCK(I)
 10   CONTINUE
C
C     Write contraction matrix to file
C
      LUCNMT = -9000
      CALL GPOPEN(LUCNMT,'CNTMAT','NEW',' ','FORMATTED',
     &            IDUMMY,.FALSE.)
      WRITE (LUCNMT,*) ((CONTC(I,J),I=1,IPRIMD),J=1,IORBD)
      CALL GPCLOSE(LUCNMT,'KEEP')
C
      RETURN
      END
C  /* Deck orbout */
      SUBROUTINE ORBOUT(NONTYP,NONT,IQM,NBLCK,JCO,NUC,NRC,SEG,
     &           IPCON,KATOM,KANG,KBLOCK,KPRIM,CPRIMU,NRMPRI)
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
      PARAMETER (D0 = 0.0D0)
C
#include <ccom.h>
#include <cbirea.h>
#include <nuclei.h>
#include <primit.h>
      CHARACTER*10 CHRSEG
      LOGICAL SEG, NRMPRI
      DIMENSION NONT(KATOM),IQM(KATOM),NBLCK(KATOM),
     &          JCO(KANG,KATOM),NUC(KBLOCK),NRC(KBLOCK),
     &          CPRIMU(KPRIM,KPRIM,KBLOCK),
     &          SEG(KBLOCK)
      DIMENSION IPCON(KPRIM)
C
C     P R I M I T I V E S
C     ===================
C
      IF (.NOT.NRMPRI) THEN
        CALL HEADER('Orbital exponents and contraction coefficients',1)
      ELSE
        CALL HEADER
     &  ('Orbital exponents and normalized contraction coefficients',1)
      END IF
      IPRIMD = 0
      IPRIM =  0
      ICENT  = 0
      IBLOCK = 0
      DO 100 I = 1, NONTYP
         DO 110 N = 1, NONT(I)
            ICENT = ICENT + 1
            NDEG  = NUCDEG(ICENT)
            KBCH  = IBLOCK
            DO 200 J = 1, IQM(I)
            DO 200 K = 1, JCO(J,I)
               KBCH = KBCH + 1
               NNUC  = NUC(KBCH)
               NNRC  = NRC(KBCH)
            IF (NNUC .EQ. 0) GO TO 200
               ITYP = NHKOFF(J)
               IPSTRT = IPRIM + 1
               IPRIM =  IPRIM + NNUC
               IF (SEG(KBCH)) THEN
                  CHRSEG = 'seg. cont.'
               ELSE
                  CHRSEG = 'gen. cont.'
               END IF
               IF (NNRC .LE. 5) THEN
                  DO 300 ICOMP = 1, KHK(J)
                     ITYP = ITYP + 1
                     DO 330 L = 1, NDEG
                        IPRIMD = IPRIMD + 1
                        IF (NDEG .GT. 1) THEN
                           WRITE (LUPRI,1000) NAMN(ICENT),'#',L,
     &                          GTOTYP(ITYP),
     &                          IPRIMD,PRIEXP(IPSTRT),
     &                          (CPRIMU(1,MM,KBCH),MM=1,NNRC)
                        ELSE
                           WRITE (LUPRI,1010) NAMN(ICENT),GTOTYP(ITYP),
     &                          IPRIMD,PRIEXP(IPSTRT),
     &                          (CPRIMU(1,MM,KBCH),MM=1,NNRC)
                        END IF
                        IF (NNUC .GT. 1) THEN
                           IPRIMD = IPRIMD + 1
                           WRITE (LUPRI,1020) CHRSEG,
     &                          IPRIMD,PRIEXP(IPSTRT+1),
     &                          (CPRIMU(2,MM,KBCH),MM=1,NNRC)
                        END IF
                        DO 350 M = 3, NNUC
                           IPRIMD = IPRIMD + 1
                           WRITE (LUPRI,1030) IPRIMD,
     &                          PRIEXP(IPSTRT-1+M),
     &                          (CPRIMU(M,MM,KBCH),MM=1,NNRC)
 350                    CONTINUE
 330                  CONTINUE
 300               CONTINUE
               ELSE
                  DO 400 ICOMP = 1, KHK(J)
                     ITYP = ITYP + 1
                     DO 430 L = 1, NDEG
                        IPRIMD = IPRIMD + 1
                        IF (NDEG .GT. 1) THEN
                           WRITE (LUPRI,1005) NAMN(ICENT),'#',L,
     &                          GTOTYP(ITYP),
     &                          IPRIMD,PRIEXP(IPSTRT),
     &                          (CPRIMU(1,MM,KBCH),MM=1,NNRC)
                        ELSE
                           WRITE (LUPRI,1015) NAMN(ICENT),GTOTYP(ITYP),
     &                          IPRIMD,PRIEXP(IPSTRT),
     &                          (CPRIMU(1,MM,KBCH),MM=1,NNRC)
                        END IF
                        IF (NNUC .GT. 1) THEN
                           IPRIMD = IPRIMD + 1
                           WRITE (LUPRI,1025) CHRSEG,
     &                          IPRIMD,PRIEXP(IPSTRT+1),
     &                          (CPRIMU(2,MM,KBCH),MM=1,NNRC)
                        END IF
                        DO 450 M = 3, NNUC
                           IPRIMD = IPRIMD + 1
                           WRITE (LUPRI,1035) IPRIMD,
     &                          PRIEXP(IPSTRT-1+M),
     &                          (CPRIMU(M,MM,KBCH),MM=1,NNRC)
 450                    CONTINUE
 430                 CONTINUE
 400              CONTINUE
               END IF
 200        CONTINUE
 110     CONTINUE
         IBLOCK = IBLOCK + NBLCK(I)
 100  CONTINUE
 1000 FORMAT(/2X,A4,A1,I1,1X,A4,I4,F16.6,2X,5F8.4)
 1010 FORMAT(/2X,A4,3X,      A4,I4,F16.6,2X,5F8.4)
 1020 FORMAT( 3X,A10,           I4,F16.6,2X,5F8.4)
 1030 FORMAT(13X,               I4,F16.6,2X,5F8.4)
 1005 FORMAT(/2X,A4,A1,I1,1X,A4,I4,F16.6,2X,5F8.4/,(35X,5F8.4))
 1015 FORMAT(/2X,A4,3X,      A4,I4,F16.6,2X,5F8.4/,(35X,5F8.4))
 1025 FORMAT( 3X,A10,           I4,F16.6,2X,5F8.4/,(35X,5F8.4))
 1035 FORMAT(13X,               I4,F16.6,2X,5F8.4/,(35X,5F8.4))
C
      IF (NRMPRI) RETURN
C
C       C O N T R A C T I O N
C       =====================
C
C       Looping is over
C                       - atomic type
C                         - symmetry independent center
C                           - shell
C                             - component
C                               - degeneracy of center
C
      CALL HEADER('Contracted Orbitals',1)
      IPRIMD  = 0
      IORBD   = 0
      IPRIM   = 0
      IORB    = 0
      ICENT   = 0
      IBLOCK  = 0
      DO 500 I = 1,NONTYP
         DO 510 N = 1,NONT(I)
            ICENT = ICENT + 1
            NDEG  = NUCDEG(ICENT)
            KBCH  = IBLOCK
            DO 600 J = 1,IQM(I)
               NCOMP = KHK(J)
               DO 610 K = 1,JCO(J,I)
                  KBCH = KBCH + 1
                  NNUC = NUC(KBCH)
                  NNRC  = NRC(KBCH)
                  IPSTRT = IPRIM + 1
                  IPRIM  = IPRIM + NNUC
                  IOSTRT = IORB + 1
                  IORB = IORB + NNRC
                  DO 700 L = 1,NNRC
                     JPRIM = 0
                     JPRIMD = IPRIMD
                     DO 750 M = IPSTRT,IPRIM
                        JPRIMD = JPRIMD + 1
                        IF(PRICCF(M,L).NE.0.00D0) THEN
                           JPRIM = JPRIM + 1
                           IPCON(JPRIM) = JPRIMD
                        ENDIF
  750                CONTINUE
                     ITYP = NHKOFF(J)
                     IOFF = 0
                     DO 800 ICOMP = 1, NCOMP
                        ITYP = ITYP + 1
                        IF(NDEG.GT.1) THEN
                           DO 810 LL = 1,NDEG
                              IORBD = IORBD + 1
                              WRITE(LUPRI,1040)
     &                           IORBD,NAMN(ICENT),'#',LL,GTOTYP(ITYP),
     &                           ((IPCON(M)+IOFF),M=1,JPRIM)
                              IOFF = IOFF + NNUC
  810                      CONTINUE
                        ELSE
                           IORBD = IORBD + 1
                           WRITE(LUPRI,1050) IORBD,NAMN(ICENT),
     &                        GTOTYP(ITYP),((IPCON(M)+IOFF),M=1,JPRIM)
                           IOFF = IOFF + NNUC
                        ENDIF
  800                CONTINUE
  700             CONTINUE
                  IPRIMD = IPRIMD + NNUC*NDEG*NCOMP
  610          CONTINUE
  600       CONTINUE
  510    CONTINUE
         IBLOCK = IBLOCK + NBLCK(I)
  500 CONTINUE
      WRITE (LUPRI,'(/)')
 1040 FORMAT(I4,2X,A4,A1,I1,2X,A4,24I4)
 1050 FORMAT(I4,2X,A4,4X,A4,24I4)
C
      RETURN
      END
C  /* Deck nucpro */
      SUBROUTINE NUCPRO(WORK,LWORK)
C******************************************************************************
C
C     Process molecular data
C
C******************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
      PARAMETER (D0 = 0.0D0, DP5 = 0.5D0)
C
#include <cbirea.h>
      DIMENSION WORK(LWORK)
#include <ccom.h>
#include <nuclei.h>
#include <frame.h>
#include <primit.h>
#include <shells.h>
#include <symmet.h>
#include <aosotr.h>
C
C
#include <ibtfun.h>
C
C     Statement function to "convert" 0 - 7 to a printable
C     "binary" form
C
      IFAKBN(I) = 25*IBTAND(I,4) + 5*IBTAND(I,2) + IBTAND(I,1)
C
C     *************************************************************
C     ***** Calculate Distances ,Nuclear Potential Energy and *****
C     ***** Nuclear Contributions to Dipole Moment            *****
C     * LOOPS:
C     * 10      - loop over first symmetry independent centre
C     * 20+IF   - loop over dependent centers
C     * 30      - loop over second symmetry independent centre
C     * 40+IF   - loop over dependent centers
C     ************************************************************
C
      DPNUC(1) = D0
      DPNUC(2) = D0
      DPNUC(3) = D0
      NUCDEP    = 0
      NUCPRE(1) = 0
      NFLOAT    = 0
      DO 100 N = 1, NUCIND
         IVARB = ISTBNU(N)
         NDEG  = MULT(IVARB)
         IF (IPREAD .GE. 5)
     &      WRITE (LUPRI,1000) NAMN(N),(CORD(I,N),I=1,3),
     &                        IFAKBN(ISTBNU(N)), NDEG - 1
         NUCDEG(N) = NDEG
         NUCPRE(N + 1) = NUCPRE(N) + NDEG
         IF (NINT(CHARGE(N)) .EQ. 0 .AND. NAMN(N) .NE. 'cav')
     &        NFLOAT = NFLOAT + 1
         DPNUC(1) = DPNUC(1) + CORD(1,N)*CHARGE(N)*FMULT(IVARB)
         DPNUC(2) = DPNUC(2) + CORD(2,N)*CHARGE(N)*FMULT(IVARB)
         DPNUC(3) = DPNUC(3) + CORD(3,N)*CHARGE(N)*FMULT(IVARB)
         II = 0
         DO 200 LA = 0,MAXREP
            IF (IBTAND(IVARB,LA) .EQ. 0) THEN
               II = II + 1
               NUCDEP = NUCDEP + 1
               NUCNUM(N,LA+1) = NUCDEP
               IF (NDEG .EQ. 1 ) THEN
                  NAMDEP(NUCDEP)     = NAMEX(3*N)(1:4)//'  '
                  NAMDPX(3*NUCDEP-2) = NAMEX(3*N-2)
                  NAMDPX(3*NUCDEP-1) = NAMEX(3*N-1)
                  NAMDPX(3*NUCDEP  ) = NAMEX(3*N  )
                  NDEGNM(NUCDEP)     = 1
               ELSE
                  ICHARD = ICHAR('0') + II
                  NAMDEP(NUCDEP)     = NAMEX(3*N)(1:4)//' '
     &                //CHAR(ICHARD)
                  NAMDPX(3*NUCDEP-2) = NAMEX(3*N-2)(1:3)
     &                //CHAR(ICHARD)//NAMEX(3*N-2)(5:6)
                  NAMDPX(3*NUCDEP-1) = NAMEX(3*N-1)(1:3)
     &                //CHAR(ICHARD)//NAMEX(3*N-1)(5:6)
                  NAMDPX(3*NUCDEP  ) = NAMEX(3*N  )(1:3)
     &                //CHAR(ICHARD)//NAMEX(3*N  )(5:6)
                  NDEGNM(NUCDEP)     = II
               END IF
            ELSE
               NUCNUM(N,LA+1) = 0
            END IF
  200    CONTINUE
  100 CONTINUE
      NATOMS = NUCDEP - NFLOAT
      IF (NUCDEP .GT. MXCENT) GOTO 5010
C
C     Nuclear repulsion energy
C     ========================
C
      POTNUC = D0
      DO 300 N = 1, NUCIND
         DO 310 M = N, NUCIND
            DO 320 KB = 0, MAXREP
            IF (IBTAND(KB,ISTBNU(M)) .EQ. 0) THEN
               IF (M.EQ.N .AND. KB.EQ.0) GO TO 320
               DS = (CORD(1,N)-CORD(1,M)*PT(IBTAND(ISYMAX(1,1),KB)))**2
     &            + (CORD(2,N)-CORD(2,M)*PT(IBTAND(ISYMAX(2,1),KB)))**2
     &            + (CORD(3,N)-CORD(3,M)*PT(IBTAND(ISYMAX(3,1),KB)))**2
               DIST = SQRT(DS)
               IF (DIST.LT.0.1.AND.CHARGE(M)*CHARGE(N).NE.D0) GOTO 5000
               IF (IBTAND(KB,ISTBNU(N)) .EQ. 0) THEN
                  IF((ABS(CHARGE(M)) .GT. 100.0D0) .AND.
     &               (ABS(CHARGE(N)) .GT. 100.0D0)) GOTO 320
                  IF (DIST.GT.D0) THEN
                     HKAB  = FMULT(IBTAND(ISTBNU(M),ISTBNU(N)))
                     IF (M .EQ. N) HKAB = DP5*HKAB
                     POTNUC = POTNUC + CHARGE(M)*CHARGE(N)*HKAB/DIST
                  END IF
               END IF
            END IF
  320       CONTINUE
  310    CONTINUE
  300 CONTINUE
C
C     **********************************************************
C     ***** Calculate symmetry-adapted nuclear coordinates *****
C     **********************************************************
C
      CALL SYMNCO(LWORK,WORK)
C
      RETURN
C
C     Error messages:
C
 5000 CONTINUE
      WRITE (LUPRI,'(3(A,I3),A,D15.5)')
     &     ' The nucleus',N,' is too close to the',KB,
     &     'th transformation of nucleus no.',M,' DIST=',DIST
      CALL QUIT('Nuclei too close.')
 5010 CONTINUE
      WRITE (LUPRI,'(///1X,A,/,2(1X,A,I3/),/,1X,A,I3,A)')
     &      ' Allowed number of atoms exceeded.',
     &      ' Number of atoms in input:',NUCDEP,
     &      ' Number of atoms allowed: ',MXCENT,
     &      ' Increase MXCENT to ',NUCDEP,'.'
      CALL QUIT('Too many atoms in READIN.')
C
 1000 FORMAT(2X,A4,5X,3F10.5,6X,/,
     &       16X, 'Stabilizer ',I3,',   with ',I2,
     &       ' symmetry equivalent atoms',/)
      END
C  /* Deck syminp */
      SUBROUTINE SYMINP(NSYMOP,KASYM,IFXYZ,CLASS)
C*****************************************************************************
C
C     This subroutine sets up point group symmetry and looks at
C     the behaviour of principal axes and rotations under point group
C     symmetry
C
C     tsaue - 940825 - major revision: tagged on SYMGRP + polish
C
C*****************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <maxmom.h>
#include <maxorb.h>
#include <mxcent.h>
C
#include <symmet.h>
#include <ccom.h>
#include <cbirea.h>
      CHARACTER*1 KASYM(3,3)
      CHARACTER*(*) CLASS
      DIMENSION IFXYZ(3),IS(0:7),IGEN(3)
#include <chrxyz.h>
      DATA IS/0,1,1,2,1,2,2,3/
#include <sdpre.h>
#include <ibtfun.h>
C
C     Initialization
C     ==============
C
C     PT is parity of a bitstring:
C       1 for an even number of ones: 000,011,110,101
C      -1 for an odd  number of ones: 001,010,100,111
C
      PT(0) =  1.0D0
      PT(1) = -1.0D0
      PT(2) = -1.0D0
      PT(3) =  1.0D0
      PT(4) = -1.0D0
      PT(5) =  1.0D0
      PT(6) =  1.0D0
      PT(7) = -1.0D0
      DO 5 I = 1,3
         IFXYZ(I)    = 0
         ISYMAX(I,1) = 0
         IGEN(I)     = 0
    5 CONTINUE
C
C     Determine:
C     IGEN(I)   - basic operations
C     ISYMAX(I) - behavior of principal axes under basic operations
C     ===============================================================
C
      IAXIS = 0
      MAXREP = 2**NSYMOP - 1
      IF (NSYMOP.GT.0.AND.IPREAD .GT. 0) THEN
         CALL HEADER('Symmetry Operations',1)
         WRITE (LUPRI,'(A,I2,/)') '  Symmetry operations:',NSYMOP
      END IF
      DO 100 J = 1,NSYMOP
        DO 110 I = 1,3
        IF (KASYM(I,J).NE.' ') THEN
          K = ICHAR(KASYM(I,J)) - ICHAR('W')
          IGEN(J)     = IGEN(J)     + 2**(K-1)
          ISYMAX(K,1) = ISYMAX(K,1) + 2**(J-1)
        END IF
  110   CONTINUE
        IAXIS = IBTOR(IAXIS,IGEN(J))
  100 CONTINUE
C
C     Determine IFXYZ
C     ===============
C     Do we really need it ????
C
      IND = 0
      DO 140 I = 1,NSYMOP
        IND = IBTOR(IND,IGEN(I))
  140 CONTINUE
      DO 141 I = 1,3
        IFXYZ(I) = IBTAND(IBTSHR(IND,(I-1)),1)
  141 CONTINUE
C
C     Determine:
C     ISYMAX(I,2) - behaviour of principal rotations under basic operations
C     =====================================================================
C
      ISYMAX(1,2) = IBTXOR(ISYMAX(2,1),ISYMAX(3,1))
      ISYMAX(2,2) = IBTXOR(ISYMAX(3,1),ISYMAX(1,1))
      ISYMAX(3,2) = IBTXOR(ISYMAX(1,1),ISYMAX(2,1))
C
C     Determine:
C     IPTAX   - coordinate axis: pointer analogous to IPTSYM
C     NAXREP  - number of coordinate axis in each symmetry
C     ========================================================
C
      CALL IZERO(IPTAX,6)
      CALL IZERO(IPTXYZ(1,0,1),48)
      DO 200 ITYPE = 1,2
        IPTAXI = 0
        DO 205 IREP = 0, MAXREP
           NAXIS = 0
           DO 210 ICOOR = 1, 3
              IF (IBTXOR(IREP,ISYMAX(ICOOR,ITYPE)) .EQ. 0) THEN
                 NAXIS  = NAXIS + 1
                 IPTAXI = IPTAXI + 1
                 IPTAX(ICOOR,ITYPE) = IPTAXI
                 IPTXYZ(NAXIS,IREP,ITYPE) = ICOOR
              END IF
  210      CONTINUE
           NAXREP(IREP,ITYPE) = NAXIS
  205   CONTINUE
  200 CONTINUE
      IF (IPREAD.GT. 20) THEN
         WRITE (LUPRI,'(A,3I5)') '  IPTAX(*,1)  ',
     &                           (IPTAX(I,1),I=1,3)
         WRITE (LUPRI,'(A,3I5)') '  IPTAX(*,2)  ',
     &                           (IPTAX(I,2),I=1,3)
         WRITE (LUPRI,'(A,8I5)') '  NAXREP(*,1) ',
     &                           (NAXREP(I,1),I=0,MAXREP)
         WRITE (LUPRI,'(A,8I5)') '  NAXREP(*,2) ',
     &                           (NAXREP(I,2),I=0,MAXREP)
      END IF
C
C     Determine group & properties
C
      CALL SYMGRP(IGEN,NSYMOP,CLASS)
C
C     For DIRAC: double group symmetry
C
      IF(DIRAC) CALL DBLGRP
C
C     Determine MULT(I) and FMULT(I) - multiplicity of center
C     =======================================================
C
      DO 101 I = 0,7
         MULT(I)  = 2**MAX(0,NSYMOP-IS(I))
         FMULT(I) = SDPRE(MULT(I))
  101 CONTINUE
C
      RETURN
C
      END
C  /* Deck sympro */
      SUBROUTINE SYMPRO(LVALUE,MVALUE,NVALUE,IRREP,DOOWN)
C*****************************************************************************
C
C     SYMPRO generates the symmetry orbitals (SOs) from the list of
C     symmetry independent atomic orbitals(AOs).
C     A given SO of irrep L is given as:
C
C         SO(L,a) = SUM{i} [CTRAN(NSORB,i)*G(i)*AO(NSORB)]
C
C     Here {G(i)} is a set of symmetry operators transforming AO(NSORB)
C     into all corresponding orbitals centered on symmetry related sites
C     in the molecule. The loop over i is only allowed to encounter
C     elements that do not contain any basic operations belonging to the
C     stabiliser of the centre; thus any G uniquely defines transformation
C     to a given centre.
C
C     By allowing all symmetry operations to work on the list of
C     symmetry independent AOs a list of symmetry dependent AOs
C     is generated (counted by NAORB). Redundancies are removed by
C     limiting symmetry operations to the set G(i) and the list thus
C     reduced to the list of non-trivial symmetry dependent AOs
C     (counted by NSORB).
C
C******************************************************************************
C
C     This subroutine determines the following parameters:
C
C     ISYMAO  -  indicates how an atomic orbital behaves under the basic
C                symmetry operations. When a basic operation changes the
C                sign of the AO (centered at origo) the corresponding bit
C                gets the value 1.
C
C     CTRAN   -  transformation coefficients (+1 or -1)
C     IPIND   -  packed integer
C     IPTSYM  -  pointer from redundant list of symmetry dependent AOs
C                to list of non-trivial symmetry dependent AOs. The
C                pointer is zero if the AO does not contribute to the
C                irrep.
C     ITRAN   -  given an operation G(i): pointer from list of symmetry
C                dependent AOs to list of symmetry independent AOs
C     JPRX    -  AO label
C     JTRAN   -  index of operation G moving a given AO to another centre
C     MAMN    -  name of AO centre
C     NPARNU  -  offset pointer from non-symmetric operators for given
C                irrep
C     NPARSU  -  offset pointer for symmetry dependent AOs for given irrep
C     NSORB    -  number of symmetry dependent AOs
C     NSYM    -  number of irreps that the AOs contribute to
C*************************************************************************
C
C     The code originally resided inside READIN
C     tuh 120988
C
C     Polished and annotated - tsaue March 10 1993
C*************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxcent.h>
#include <maxorb.h>
      PARAMETER (D0 = 0.0D0)
C
      LOGICAL DOOWN
      DIMENSION LVALUE(MXAQN), MVALUE(MXAQN), NVALUE(MXAQN),
     &          IRREP(MXCORB)
#include <nuclei.h>
#include <ccom.h>
#include <shells.h>
#include <symmet.h>
#include <pincom.h>
#include <aosotr.h>
#include <sphtrm.h>
#include <huckel.h>
#include <r12int.h>
#include <cbirea.h>
C
#include <ibtfun.h>
C*****************************************************************************
C Determine ISYMAO:
C       ISYMAO is a bitstring indicating how atomic orbitals centered in
C       origo behaves under the basic symmetry operations
C*****************************************************************************
C
C     I. Cartesian functions
C     ----------------------
C
      IF (DOCART) THEN
         DO 100 I = 1, NHTYP
            CALL LMNVAL(I,I*(I + 1)/2,LVALUE,MVALUE,NVALUE)
            DO 100 J = 1, I*(I + 1)/2
                LVAR = MOD(LVALUE(J),2)*ISYMAX(1,1)
                MVAR = MOD(MVALUE(J),2)*ISYMAX(2,1)
                NVAR = MOD(NVALUE(J),2)*ISYMAX(3,1)
                ISYMAO(I,J) = IBTXOR(LVAR,IBTXOR(MVAR,NVAR))
  100    CONTINUE
C
C     II. Your own scheme
C     -------------------
C
      ELSE IF (DOOWN) THEN
         IJK = 0
         DO 200 I = 1, NHTYP
            DO 210 K = 1, KHK(I)
               ISYMAO(I,K) = -1
  210       CONTINUE
            CALL LMNVAL(I,I*(I + 1)/2,LVALUE,MVALUE,NVALUE)
            DO 220 J = 1, I*(I + 1)/2
                LVAR = MOD(LVALUE(J),2)*ISYMAX(1,1)
                MVAR = MOD(MVALUE(J),2)*ISYMAX(2,1)
                NVAR = MOD(NVALUE(J),2)*ISYMAX(3,1)
                DO 220 K = 1, KHK(I)
                   IJK = IJK + 1
                   IF (ABS(CSP(IJK)).GT.D0) THEN
                      IF (ISYMAO(I,K) .EQ. -1) THEN
                         ISYMAO(I,K) = IBTXOR(LVAR,IBTXOR(MVAR,NVAR))
                      ELSE
                         WRITE (LUPRI,'(/A/A/A,2I5)')
     &                   ' Incorrect Cartesian transformation input:',
     &                   '  Components belonging to different irreps '
     &                   //'have been combined.',
     &                   '  Angular quantum number and component:',I-1,K
                         CALL QUIT('Error in molecule input')
                      END IF
                   END IF
  220       CONTINUE
  200    CONTINUE
      ELSE
C
C     III. Spherical harmonics
C     ------------------------
C
         DO 300 I = 0, NHTYP - 1
            II = I + 1
            IF (I .EQ. 0) THEN
               ISYMAO(II,1) = IREPLM(0,0)
            ELSE IF (I .EQ. 1) THEN
               ISYMAO(II,1) = IREPLM(1, 1)
               ISYMAO(II,2) = IREPLM(1,-1)
               ISYMAO(II,3) = IREPLM(1, 0)
            ELSE
               DO 310 J = -I,I
                  JJ = J + I + 1
                  ISYMAO(II,JJ) = IREPLM(I,J)
  310          CONTINUE
            END IF
  300    CONTINUE
      END IF
C*****************************************************************************
C Determine transformation from AOs to SOs :
C   * DO-loops:
C       400     - run over irreducible representations
C       410     - run over shells
C       420     - run over components, thus (60+70):run over orbitals
C       430     - run over the symmetryoperations that have no part in the
C               stabilizer of the center, that is run over a unique set
C               of symmetry operations transforming between symmetry
C               dependent centers
C   * Counting variables:
C       NSORB   -
C       NAORBD  -
C       NAORB   -
C       NAA     -
C       NSORBD  -
C       JKB     -
C       IRREPN  -
C*****************************************************************************
      IHNMAO    = 0
      NSORB     = 0
      NPARSU(1) = 0
      NSYM      = 0
      CALL IZERO(NAOS,8)
      CALL IZERO(NCOS,16)
      CALL IZERO(IRREP,MXCORB)
      CALL DZERO(CTRAN,8*MXCORB)
C
C     Run over Irreducible Representations LAMBDA
C
      DO 400 LA = 0, MAXREP
         NAORBD = 0
         NAORB  = 0
         IBLOCK = 0
         DO 410 IA = 1, KMAX
            MULA   = ISTBAO(IA)
            NHKTA  = NHKT(IA)
            KHKTA  = KHKT(IA)
            NUMCFA = NUMCF(IA)
C           IC is basis-set identifier for multiple basis sets (WK/UniKA/04-11-2002).
            IF (LMULBS) THEN
               IC     = MBSID(IA)
            ELSE
               IC     = LCLASS(IA)
            END IF
            IF (NUMCFA .EQ. 1) IBLOCK = IBLOCK + 1
            DO 420 NA = 1, KHKTA
               NAORB = NAORB+1
               IVARB = IBTXOR(LA,ISYMAO(NHKTA,NA))
C
C              If orbital contributes to this representation:
C
c                (IVARB is a bitstring of basic operations with
C                1 in the positions where the basic operations
C                has a different parity for the irrep and the
C                AO(when centered in origo). These basic
C                operations with different parities must then
C                not be part of the stabilizer of the center
C                for the AO).
C
               IF (IBTAND(MULA,IVARB) .EQ. 0) THEN
                  NSORB = NSORB + 1
                  JKB = 0
C
C                 loop over symmetry dependent centers
C
                  DO 430 KB = 0, MAXREP
                  IF (IBTAND(KB,MULA) .EQ. 0) THEN
                     JKB              = JKB + 1
                     NAORBD           = NAORBD + 1
                     CTRAN(NSORB,JKB) = PT(IBTAND(KB,IVARB))
                     ITRAN(NSORB,JKB) = NAORBD
                  END IF
  430             CONTINUE
                  NAOS(LA+1)    = NAOS(LA+1) + 1
                  NCOS(LA+1,IC) = NCOS(LA+1,IC) + 1
                  IPTYP(NSORB)  = NHKOFF(NHKTA) + NA
                  IPCEN(NSORB)  = NCENT(IA)
                  ICLASS(NSORB) = IC
                  IF (IC .EQ. 2 .AND. ADDSTO) THEN
                     IHNMAO = IHNMAO + 1
                     IHUCPT(IA) = IHNMAO
                     HUCCHR = CHARGE(NCENT(IA))
                     NHUCCO = NUMCF(IA)
                     CALL HUCFUN(HUCCHR,NHKTA,NHUCCO,HUCEXC(IHNMAO))
                  END IF
                  IRREPN        = IRREP(NAORB)
                  IRREP(NAORB)  = IRREPN + 1
                  IPIND(NSORB)  = IA*2**16 + NA*2**8 + IRREPN
                  JTRAN(NSORB)  = JKB
                  INDGEN(NSORB) = IRREPN*2**24 + NA*2**16 + NUMCFA*2**8
     &                                                    + IBLOCK
                  IPTSYM(NAORB,LA) = NSORB
               ELSE
                  IPTSYM(NAORB,LA) = 0
                  NAORBD = NAORBD + MULT(MULA)
               END IF
  420       CONTINUE
  410    CONTINUE
         IF (LA .GT. 0) NPARSU(LA+1) = NPARSU(LA) + NPARLA
         NBASI  = NAOS(LA+1)
         NPARLA = NBASI*(NBASI + 1)/2
         IF (NBASI .GT. 0) NSYM = NSYM + 1
  400 CONTINUE
C
C     Compute symmetry offsets for non-symmetric operators
C     (Note case IREPO = 0 is thereby excluded)
C
      DO 500 IREPO = 1,MAXREP
         IBLK = 0
         DO 500 IREPA = 0,MAXREP
            IREPB = IBTXOR(IREPO,IREPA)
            IF (IREPA .GT. IREPB) THEN
               NPARNU(IREPO+1,IREPA+1) = IBLK
               IBLK = IBLK + NAOS(IREPA+1)*NAOS(IREPB+1)
            ENDIF
 500  CONTINUE
      RETURN
      END
C  /* Deck symout */
      SUBROUTINE SYMOUT
C*****************************************************************************
C
C     Print routine for symmetry
C     Extended to write a SYMINFO file for use with mean-field SO integrals
C
C*****************************************************************************
#include <implicit.h>
#include <dummy.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxcent.h>
#include <maxorb.h>
C
#include <nuclei.h>
#include <ccom.h>
#include <shells.h>
#include <symmet.h>
#include <pgroup.h>
#include <pincom.h>
#include <cbirea.h>
#include <aosotr.h>
      CHARACTER COMP(2)*1
#include <r12int.h>
#include <chrsgn.h>
C
#include <ibtfun.h>
C
C     Write SYMINFO file
C
      LUSYMF = 0
      CALL GPOPEN(LUSYMF,'SYMINFO',' ',' ','FORMATTED',IDUMMY,.FALSE.)
      WRITE (LUSYMF,'(A,/A)')
     &     'Symmetry information from Dalton (Hermit module)',
     &     'funct #, unique centre #, L, M , Func.type #, # of '//
     &     'sym.gen.functions , Phases'
C
C*****************************************************************************
C       S Y M M E T R Y      O R B I T A L S
C*****************************************************************************
      IF (MAXREP.GT.0.AND.IPREAD.GT.0) THEN
         CALL HEADER('Symmetry Orbitals',1)
         WRITE (LUPRI,'(A,11X,8I4)')
     *        '  Number of orbitals in each symmetry: ',
     *        (NAOS(I),I=1,MAXREP+1)
      END IF
      IF(DIRAC) THEN
        COMP(1) = 'L'
        COMP(2) = 'S'
        IF (MAXREP.GT.0.AND.IPREAD.GT.0) THEN
           WRITE (LUPRI,'(A,8I3)')
     *          '  Number of large orbitals in each symmetry: ',
     &          (NCOS(I,1),I=1,MAXREP+1)
           WRITE (LUPRI,'(A,8I3)')
     *          '  Number of small orbitals in each symmetry: ',
     &          (NCOS(I,2),I=1,MAXREP+1)
        END IF
      ELSE IF (LMULBS) THEN
C       Output for multiple basis sets. Determine total numbers of orbital-basis 
C       (MBAS1) and auxiliary-basis (MBAS2) functions (WK/UniKA/04-11-2002).
        COMP(1) = 'M'
        COMP(2) = 'A'
        IF (MAXREP.GT.0.AND.IPREAD.GT.0) THEN
           WRITE (LUPRI,'(/A,8I4)')
     *          '  Number of main orbitals in each symmetry:       ',
     &          (NCOS(I,1),I=1,MAXREP+1)
           WRITE (LUPRI,'(A,8I4)')
     *          '  Number of auxiliary functions in each symmetry: ',
     &          (NCOS(I,2),I=1,MAXREP+1)
        END IF
        DO I=1,MAXREP+1
         MBAS1(I) = NCOS(I,1)
         MBAS2(I) = NCOS(I,2)
        END DO
      ELSE
        COMP(1) = ' '
        COMP(2) = ' '
      ENDIF
      I=0
      DO 10 LA=1,MAXREP+1
        NBI=NAOS(LA)
        IF (NBI.GT.0) THEN
           IF (MAXREP.GT.0.AND.IPREAD.GT.0) 
     &          WRITE (LUPRI,'(//2X,A,2X,A3,A1,I2,A1/)')
     &          'Symmetry',REP(LA-1),'(',LA,')'
          IPLMAX = 0
          IPNUM  = 1
          IPLBKP = 0
          ICNTBK = 0
          DO 20 L=1,NBI
            I=I+1
            ICENT = IPCEN(I)
            J=NUCDEG(ICENT)
            IF (MAXREP.GT.0.AND.IPREAD.GT.0)
     &         WRITE (LUPRI,1060) I,NAMN(ICENT),COMP(ICLASS(I)),
     +            GTOTYP(IPTYP(I)), ITRAN(I,1),
     *            (CHRSGN(NINT(CTRAN(I,K))),ITRAN(I,K),K=2,J)
            IF (IPTYP(I) .EQ. 1) THEN
               IPL = 0
               IPM = 0
            ELSE IF (IPTYP(I) .LE. 4) THEN
               IF (IPTYP(I) .EQ. 4) IPM = 0
               IF (IPTYP(I) .EQ. 2) IPM = 1
               IF (IPTYP(I) .EQ. 3) IPM = -1
               IPL = 1
            ELSE IF (IPTYP(I) .LE. 9) THEN
               IPM = IPTYP(I) - 7
               IPL = 2
            ELSE IF (IPTYP(I) .LE. 16) THEN
               IPM = IPTYP(I) - 13
               IPL = 3
            ELSE IF (IPTYP(I) .LE. 25) THEN
               IPM = IPTYP(I) - 21
               IPL = 4
            END IF
            IF (IPL .EQ. IPLBKP .AND. .NOT. ICENT .NE. ICNTBK) THEN
               IF (IPTYP(I) .LE. IPLMAX) THEN
                  IPNUM = IPNUM + 1
               END IF
            ELSE
               IPNUM = 1
            END IF
            IPLMAX = IPTYP(I)
            IPLBKP = IPL
            ICNTBK = ICENT
            WRITE (LUSYMF,1070) I, ICENT, IPL, IPM, IPNUM,
     *           J, (NINT(CTRAN(I,K)),K=1,J)
   20     CONTINUE
        ELSE
           IF (MAXREP.GT.0.AND.IPREAD.GT.0)
     &        WRITE (LUPRI,'(//2X,A,2X,A3,A1,I2,A1)')
     *        'No orbitals in symmetry',REP(LA-1),'(',LA,')'
        END IF
  10  CONTINUE
      IF (MAXREP .GT. 0 .AND. IPREAD .GT. 0) THEN
         IF (IPREAD .GT. 10) THEN
            WRITE(LUPRI,'(10X,A,/)') 'Symmetry pointer indices'
            WRITE(LUPRI,'(4X,8I4)')
     &           ((IPTSYM(I,J),J = 0,MAXREP),I=1,NORBS)
            IF (NFLOAT .GT. 0) WRITE (LUPRI,'(/10X,A,I4)')
     *           'Number of floating orbitals :',NFLOAT
         END IF
         WRITE (LUPRI,'(/A,3(2X,A3,A1,I1,A1))')
     &        '  Symmetries of electric field:',
     &        (REP(ISYMAX(I,1)),'(',ISYMAX(I,1)+1,')',I=1,3)
         WRITE (LUPRI,'(/A,3(2X,A3,A1,I1,A1))')
     &        '  Symmetries of magnetic field:',
     &        (REP(ISYMAX(I,2)),'(',ISYMAX(I,2)+1,')',I=1,3)
      END IF
 1060 FORMAT(I5,3X,A6,1X,A1,3X,A4,5X,I3,7(2X,A,1X,I3))
 1070 FORMAT(I4,13I6)
      WRITE (LUSYMF,'(A)') 'END'
      CALL GPCLOSE(LUSYMF,'KEEP')
      RETURN
      END
C  /* Deck symnco */
      SUBROUTINE SYMNCO(LWORK,WORK)
#include <implicit.h>
#include <priunit.h>
#include <aovec.h>
#include <mxcent.h>
#include <maxaqn.h>
#include <maxmom.h>
#include <maxorb.h>
C
#include <cbirea.h>
#include <nuclei.h>
#include <symmet.h>
      DIMENSION WORK(LWORK)
#include <chrxyz.h>
#include <ibtfun.h>
      LENGTH = 48*NUCIND
      CALL IZERO(IPTCNT(1,0,1),LENGTH)
      IOFFT = 0
      IOFFR = 0
      IOFFTN = 0
      DO 100 IREP = 0,MAXREP
         ICENTA = 0
         ICENTB = 0
         DO 110 ICENT = 1,NUCIND
            MULC = ISTBNU(ICENT)
            DO 200 IDIRN = 1,3
               ICENTA = ICENTA + 1
               IF (IBTAND(MULC,IBTXOR(IREP,ISYMAX(IDIRN,1))).EQ.0)THEN
                  IOFFT = IOFFT + 1
                  IPTCNT(ICENTA,IREP,1) = IOFFT
               ENDIF
               IF (IBTAND(MULC,IBTXOR(IREP,ISYMAX(IDIRN,2))).EQ.0)THEN
                  IOFFR = IOFFR + 1
                  IPTCNT(ICENTA,IREP,2) = IOFFR
               ENDIF
  200       CONTINUE
            DO 300 IDIR1 = 1, 3
            DO 300 IDIR2 = IDIR1, 3
               ICENTB = ICENTB + 1
               ISYMIJ = IBTXOR(ISYMAX(IDIR1,1),ISYMAX(IDIR2,1))
               IF (IBTAND(MULC,IBTXOR(IREP,ISYMIJ)) .EQ. 0) THEN
                  IOFFTN = IOFFTN + 1
               ENDIF
  300       CONTINUE
  110    CONTINUE
  100 CONTINUE
C
      IOFF = 0
      DO 400 IREP = 0, MAXREP
         DO 410 ICENT = 1, NUCIND
            IPTNUC(ICENT,IREP) = 0
  410    CONTINUE
         DO 420 ICENT = 1, NUCIND
            MULC = ISTBNU(ICENT)
            IF (IBTAND(MULC,IREP) .EQ. 0) THEN
               IOFF = IOFF + 1
               IPTNUC(ICENT,IREP) = IOFF
            END IF
  420    CONTINUE
  400 CONTINUE
C
      IF (IPREAD .GE. 20) THEN
         CALL HEADER('Symmetry-adapted nuclear coordinates',-1)
         WRITE(LUPRI,'(11X,8I4)') (IREP, IREP = 0,MAXREP)
         ICENTA = 0
         DO 500 ICENT = 1,NUCIND
            WRITE(LUPRI,'(4X,A1,2X,A1,8I4)')
     *      NAMN(ICENT),'X', (IPTCNT(ICENTA+1,IREP,1),IREP = 0,MAXREP)
            WRITE(LUPRI,'(4X,A1,2X,A1,8I4)')
     *      NAMN(ICENT),'Y', (IPTCNT(ICENTA+2,IREP,1),IREP = 0,MAXREP)
            WRITE(LUPRI,'(4X,A1,2X,A1,8I4)')
     *      NAMN(ICENT),'Z', (IPTCNT(ICENTA+3,IREP,1),IREP = 0,MAXREP)
            ICENTA = ICENTA + 3
  500    CONTINUE
         CALL HEADER('Symmetry-adapted nuclear magnetic moments',-1)
         WRITE(LUPRI,'(11X,8I4)') (IREP, IREP = 0,MAXREP)
         ICENTA = 0
         DO 510 ICENT = 1,NUCIND
            WRITE(LUPRI,'(4X,A1,2X,A1,8I4)')
     *      NAMN(ICENT),'X', (IPTCNT(ICENTA+1,IREP,2),IREP = 0,MAXREP)
            WRITE(LUPRI,'(4X,A1,2X,A1,8I4)')
     *      NAMN(ICENT),'Y', (IPTCNT(ICENTA+2,IREP,2),IREP = 0,MAXREP)
            WRITE(LUPRI,'(4X,A1,2X,A1,8I4)')
     *      NAMN(ICENT),'Z', (IPTCNT(ICENTA+3,IREP,2),IREP = 0,MAXREP)
            ICENTA = ICENTA + 3
  510    CONTINUE
         CALL HEADER('Symmetry-adapted nuclei',-1)
         WRITE (LUPRI,'(11X,8I4)') (IREP, IREP = 0, MAXREP)
         DO 520 ICENT = 1, NUCIND
            WRITE(LUPRI,'(4X,A1,2X,A1,8I4)')
     &      NAMN(ICENT),CHRXYZ(1),(IPTNUC(ICENT,IREP),IREP = 0,MAXREP)
  520    CONTINUE
      END IF
C
C     ***************************
C     **** Initialize IPTCOR ****
C     ***************************
C
      NCOOR  = 3*NUCDEP
      KCSTRA = 1
      KSCTRA = KCSTRA + NCOOR*NCOOR
      KLAST  = KSCTRA + NCOOR*NCOOR
      IF (KLAST.GT.LWORK) CALL STOPIT('NUCPRO','TRACOR',KLAST,LWORK)
      CALL TRACOR(WORK(KCSTRA),WORK(KSCTRA),1,NCOOR,IPREAD)
      CALL TRACOR(WORK(KCSTRA),WORK(KSCTRA),2,NCOOR,IPREAD)
      CALL TRACR(NCOOR)
      END
C  /* Deck pricar */
      SUBROUTINE PRICAR(WORK,LWORK)
C
C     This subroutine prints information about atomic coordinates
C
C     tuh 081188 - Bush elected
C
#include <implicit.h>
#include <dummy.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxcent.h>
#include <maxorb.h>
#include <gnrinf.h>
C
      CHARACTER*4 NAME
      INTEGER NBASE(8), NSIGN(8)
      LOGICAL LINEAR
      DIMENSION WORK(LWORK)
C
#include <nuclei.h>
#include <symmet.h>
#include <pgroup.h>
#include <cbirea.h>
#include <frame.h>
C
#include <orgcom.h>
#include <chrxyz.h>
#include <chrsgn.h>
#include <chrnos.h>
#include <ibtfun.h>
C
      NCOOR = 3*NUCDEP
C
C     *********************************
C     ***** Cartesian Coordinates *****
C     *********************************
C
      IF (IPREAD .GT. 0) THEN
         CALL HEADER('Cartesian Coordinates',1)
         WRITE (LUPRI,'(A,I3,//)') '  Total number of coordinates:',
     &                                NCOOR
      END IF
      ICRX = 1
      ICRY = 2
      ICRZ = 3
      NATOMS = 0
      KMASS  = ICRX + NCOOR
      DO 100 ICENT = 1, NUCIND
         MULCNT = ISTBNU(ICENT)
         NAME   = NAMEX(3*ICENT)(1:4)
         IF (MULT(MULCNT) .EQ. 1) THEN
            IF (IPREAD .GT. 0) THEN
               WRITE (LUPRI,'(1X,I3,3X,A,5X,A,3X,F15.10)')
     *               ICRX, NAME,CHRXYZ(-1), CORD(1,ICENT)
               WRITE (LUPRI,'(1X,I3,12X,A,3X,F15.10)')
     *               ICRY, CHRXYZ(-2), CORD(2,ICENT)
               WRITE (LUPRI,'(1X,I3,12X,A,3X,F15.10,/)')
     *               ICRZ, CHRXYZ(-3), CORD(3,ICENT)
            END IF
            ICRX = ICRX + 3
            ICRY = ICRY + 3
            ICRZ = ICRZ + 3
            WORK(ICRX) = CORD(1,ICENT)
            WORK(ICRY) = CORD(2,ICENT)
            WORK(ICRZ) = CORD(3,ICENT)
            WORK(KMASS + NATOMS) = DISOTP(NINT(CHARGE(ICENT)),1,'MASS')
            NATOMS = NATOMS + 1
         ELSE
            JATOM = 0
            DO 200 ISYMOP = 0, MAXOPR
               IF (IBTAND(ISYMOP,MULCNT) .EQ. 0) THEN
                  JATOM  = JATOM + 1
                  WORK(KMASS + NATOMS) = 
     *                 DISOTP(NINT(CHARGE(ICENT)),1,'MASS')
                  WORK(ICRX) = PT(IBTAND(ISYMAX(1,1),ISYMOP))
     *                        *CORD(1,ICENT)
                  WORK(ICRY) = PT(IBTAND(ISYMAX(2,1),ISYMOP))
     *                        *CORD(2,ICENT)
                  WORK(ICRZ) = PT(IBTAND(ISYMAX(3,1),ISYMOP))
     *                        *CORD(3,ICENT)
                  WORK(KMASS) = DISOTP(NINT(CHARGE(ICENT)),1,'MASS')
                  WORK(KMASS) = DISOTP(NINT(CHARGE(ICENT)),1,'MASS')
                  NATOMS = NATOMS + 1
                  IF (IPREAD .GT. 0) THEN
                     WRITE (LUPRI,'(1X,I3,3X,A,I2,3X,A,3X,F15.10)')
     *                     ICRX, NAME,JATOM,CHRXYZ(-1),WORK(ICRX)
                     WRITE (LUPRI,'(1X,I3,12X,A,3X,F15.10)')
     *                     ICRY,CHRXYZ(-2),WORK(ICRY)
                     WRITE (LUPRI,'(1X,I3,12X,A,3X,F15.10,/)')
     *                     ICRZ,CHRXYZ(-3),WORK(ICRZ)
                  END IF
                  ICRX = ICRX + 3
                  ICRY = ICRY + 3
                  ICRZ = ICRZ + 3
               END IF
  200       CONTINUE
         END IF
  100 CONTINUE
C
C     ********************************
C     ***** Symmetry Coordinates *****
C     ********************************
C
      ISTRT = NCOOR+ NATOMS + 1
      IF (LWORK .LT. 2*NCOOR*NCOOR) CALL STOPIT('PRICAR','TRACOR',
     &                                          2*NCOOR*NCOOR,LWORK)
      CALL TRACOR(WORK(ISTRT),WORK(ISTRT + NCOOR*NCOOR),1,NCOOR,IPREAD)
      IF (MAXREP .GT. 0) THEN
         IF (IPREAD .GT. 0) THEN
            CALL HEADER('Symmetry Coordinates',1)
            WRITE (LUPRI,'(A,8I3)')
     *            '  Number of coordinates in each symmetry: ',
     *            (NCRREP(I,1),I=0,MAXREP)
         END IF
         DO 300 ISYM = 0, MAXREP
         IF (NCRREP(ISYM,1) .GT. 0) THEN
            IF (IPREAD .GT. 0) THEN
               WRITE (LUPRI,'(//A,I2/)') '  Symmetry', ISYM + 1
            END IF
            DO 400 IATOM = 1, NUCIND
               DO 500 ICOOR = 1, 3
                  ISCOOR = IPTCNT(3*(IATOM - 1) + ICOOR,ISYM,1)
                  IF (ISCOOR .GT. 0) THEN
                     NB = 0
                     DO 600 I = 1, NCOOR
                        IADR = ISTRT + (I - 1)*NCOOR + ISCOOR
                        NSGN = NINT(WORK(IADR))
                        IF (NSGN .NE. 0) THEN
                           NB = NB + 1
                           NBASE(NB) = I
                           NSIGN(NB) = NSGN
                        END IF
  600                CONTINUE
                     IF (IPREAD .GT. 0) THEN
                     IF (NB .EQ. 1) THEN
                        WRITE (LUPRI,'(I4,3X,A,2X,A,I5)') ISCOOR,
     &                     NAMEX(3*IATOM)(1:4), CHRXYZ(-ICOOR), NBASE(1)
                     ELSE
                        WRITE (LUPRI,'(I4,3X,A,2X,A,3X,A,I3,'
     &                   //CHRNOS(NB-1)//'(2X,A,I4),A,I1)')
     &                   ISCOOR,NAMEX(3*IATOM)(1:4),CHRXYZ(-ICOOR),' [',
     &                   NBASE(1),(CHRSGN(NSIGN(I)),NBASE(I),I=2,NB),
     &                   ' ]/',NB
                     END IF
                     END IF
                  END IF
  500          CONTINUE
  400       CONTINUE
         END IF
  300    CONTINUE
      END IF
C
C     Print internuclear distances
C
      IF ((IPREAD .GT. 0) .OR. (GEOALL)) 
     &     CALL GEOANA(CORD,.TRUE.,.FALSE.,NBONDS,.FALSE.,
     &                 IDUMMY,WORK(ISTRT),LWORK)
C
C     As a new default, we (almost) always print a rotational analysis, kr-02
C
      IF (IPREAD .GT. 0) CALL ROTANA(WORK(1),WORK(KMASS),WORK(ISTRT),
     &            CMXYZ,AIMOM,BIMOM,CIMOM,LINEAR,NATOMS,NCOOR,IPREAD)
C
      IF (IPREAD .GT. 0) THEN
         WRITE(LUPRI,'(//A,F18.12)')'  Nuclear repulsion energy :',
     &                               POTNUC
      END IF
      RETURN
      END
C  /* Deck priord */
      SUBROUTINE PRIORD(ALPHA,CPRIMU,NPRI,NRCI,SEG,KPRIM,DSM)
#include <implicit.h>
#include <maxorb.h>
      LOGICAL SEG
      DIMENSION ALPHA(KPRIM), CPRIMU(KPRIM,KPRIM)
C
C     *****************************
C     *** Segmented contraction ***
C     *****************************
C
      IDONE = 0
      IF (SEG) THEN
         DO 100 ICONTR = 1, NRCI
            ISTART = IDONE + 1
            NLEFT  = NPRI - IDONE
C
C           Find first primitive
C           ====================
C
            IMXA = ISTART + IDAMAX(NLEFT,ALPHA(ISTART),1) - 1
            CALL DSWAP(1,ALPHA(ISTART),1,ALPHA(IMXA),1)
            CALL DSWAP(NRCI,CPRIMU(ISTART,1),KPRIM,CPRIMU(IMXA,1),
     &                 KPRIM)
C
C           Find corresponding contracted function
C           ======================================
C
            IMXC = IDAMAX(NRCI,CPRIMU(ISTART,1),KPRIM)
            CALL DSWAP(NPRI,CPRIMU(1,ICONTR),1,CPRIMU(1,IMXC),1)
C
C           Collect other primitives contributing to same contracted
C           ========================================================
C
            IPRI = 1
            DO 200 I = ISTART + 1, NPRI
               IF (ABS(CPRIMU(I,ICONTR)) .GT. DSM) THEN
                  CALL DSWAP(1,ALPHA(I),1,ALPHA(ISTART+IPRI),1)
                  CALL DSWAP(NRCI,CPRIMU(I,1),KPRIM,
     &                            CPRIMU(ISTART+IPRI,1),KPRIM)
                  IPRI = IPRI + 1
               END IF
  200       CONTINUE
C
C           Sort primitives
C           ===============
C
            IF (IPRI .GT. 2) THEN
               DO 300 I = ISTART + 1, ISTART + IPRI - 2
                  DO 400 J = I + 1, ISTART + IPRI - 1
                     IF (ALPHA(J) .GT. ALPHA(I)) THEN
                        CALL DSWAP(1,ALPHA(I),1,ALPHA(J),1)
                        CALL DSWAP(NRCI,CPRIMU(I,1),KPRIM,
     &                                  CPRIMU(J,1),KPRIM)
                     END IF
  400             CONTINUE
  300          CONTINUE
            END IF
C
            IDONE = IDONE + IPRI
  100    CONTINUE
C
C     ***************************
C     *** General contraction ***
C     ***************************
C
      ELSE
         DO 500 I = 1, NPRI - 1
            DO 600 J = I + 1, NPRI
            IF(ALPHA(J) .GT. ALPHA(I)) THEN
               CALL DSWAP(1,ALPHA(I),1,ALPHA(J),1)
               CALL DSWAP(NRCI,CPRIMU(I,1),KPRIM,CPRIMU(J,1),KPRIM)
           END IF
  600      CONTINUE
  500   CONTINUE
      END IF
      RETURN
      END
C  /* Deck nucsiz */
      SUBROUTINE NUCSIZ(IPREAD,CHARGE,DELTA)
C.......................................................................
C
C     For a nucleus of atomic no. "charge", calculate the exponent delta
C     for a gaussian charge distribution approximation to the finite nuc
C.......................................................................
#include <implicit.h>
#include <priunit.h>
      DIMENSION ASYMB(103), AMASS(103)
      CHARACTER*2 ASYMB
      DATA (ASYMB(I),I = 1,103)
     1/'H ', 'He', 'Li', 'Be', 'B ', 'C ', 'N ', 'O ', 'F ', 'Ne',
     2 'Na', 'Mg', 'Al', 'Si', 'P ', 'S ', 'Cl', 'Ar', 'K ', 'Ca',
     3 'Sc', 'Ti', 'V ', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
     4 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y ', 'Zr',
     5 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn',
     6 'Sb', 'Te', 'I ', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd',
     7 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb',
     8 'Lu', 'Hf', 'Ta', 'W ', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',
     9 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th',
     O 'Pa', 'U ', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm',
     1 'Md', 'No', 'Lr' /
      DATA (AMASS(I),I = 1,92)
     1/ 1.0078246D0, 4.002601D0, 7.01600D0, 9.01218D0, 11.009307D0,
     2  12.000000D0, 14.0030738D0, 15.9949141D0,
     *  18.9984022D0, 19.992441D0,
     3  22.9898D0, 23.98504D0, 26.98153D0, 27.976929D0, 30.973764D0,
     4  31.9720727D0, 34.9688531D0, 39.962386D0, 38.96371D0, 39.96259D0,
     5  44.95592D0, 48.D0, 50.9440D0, 51.9405D0, 54.9380D0,
     6  55.9349D0, 58.9332D0, 57.9353D0, 62.9296D0, 63.9291D0,
     7  68.9257D0, 73.9219D0, 74.9216D0, 79.9165D0, 78.91839D0,
     8  83.91151D0, 84.9117D0, 87.9056D0, 88.9059D0, 89.9043D0,
     9  92.9060D0, 97.9055D0, 98.D0, 101.9037D0, 102.9048D0,
     O  107.90389D0, 106.90509D0, 113.9036D0, 114.9041D0, 120.D0,
     1  120.9038D0, 129.9067D0, 126.90466D0, 131.90416D0, 132.9051D0,
     2  137.9050D0, 138.9061D0, 139.9053D0, 140.9074D0, 141.9075D0,
     3  145.D0, 151.9195D0, 152.9209D0, 157.9241D0, 159.9250D0,
     4  163.9288D0, 164.9303D0, 165.9304D0, 168.9344D0, 173.9390D0,
     5  174.9409D0, 179.9468D0, 180.9480D0, 183.9510D0, 186.9560D0,
     6  192.D0, 192.9633D0, 194.9648D0, 196.9666D0, 201.970625D0,
     7  204.9745D0, 207.9766D0, 208.9804D0, 209.D0, 210.D0,
     8  222.D0, 223.D0, 226.D0, 227.D0, 232.D0, 231.D0, 238.D0 /
      DATA (AMASS(I),I = 93,103)
     1/ 237.D0, 244.D0, 243.D0,
     2  247.D0, 247.D0, 251.D0, 252.D0, 257.D0,
     3  258.D0, 259.D0, 260.D0/
      INUC = NINT(CHARGE)
      A = CHARGE*2.556D0
      IF (INUC.LE.103) A = AMASS(INUC)
      A = A**(1.0D0/3.0D0)
      DELTA = 1.5D10*(.52917706D0/(.836D0*A+0.57D0))**2
      IF(IPREAD.GE.0) THEN
        CALL HEADER('Output from NUCSIZ',-1)
        WRITE(LUPRI,'(2X,A2,A,1P,D15.5/)') ASYMB(INUC),
     &   '  : Exponent for gaussian charge distribution : ',DELTA
        ENDIF
      RETURN
      END
C  /* Deck sphlab */
      SUBROUTINE SPHLAB(IORDER,LABINT)
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
      CHARACTER LABINT(MXQN**2)*4
      CHARACTER SPDCAR*1, SIGNJ*1
#include <chrnos.h>
C
      IOFF = 0
      DO 100 I = 0, IORDER
         IF (I .EQ. 0) THEN
            LABINT(1) = '1s  '
            IOFF = IOFF + 1
         ELSE IF (I .EQ. 1) THEN
            LABINT(2) = '2px '
            LABINT(3) = '2py '
            LABINT(4) = '2pz '
            IOFF = IOFF + 3
         ELSE
            DO 200 J = -I, I
               IADR = IOFF + J + I + 1
               IF (J .LT. 0) THEN
                  SIGNJ = '-'
               ELSE IF (J .EQ. 0) THEN
                  SIGNJ = ' '
               ELSE
                  SIGNJ = '+'
               END IF
               LABINT(IADR) = CHRNOS(I+1)//SPDCAR(I)//
     &                        CHRNOS(ABS(J))//SIGNJ
  200       CONTINUE
            IOFF = IOFF + 2*I + 1
         END IF
  100 CONTINUE
      RETURN
      END
C  /* Deck carlab */
      SUBROUTINE CARLAB(IORDER,LABINT)
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
      DIMENSION IX(MXAQN), IY(MXAQN), IZ(MXAQN)
      CHARACTER LABINT(MXQN*(MXQN+1)*(MXQN+2)/6)*4
      CHARACTER SPDCAR*1
#include <chrnos.h>
#include <ibtfun.h>
      J = 0
      DO 100 I = 0, IORDER
         IF (I .LE. 3) THEN
            J = J + (I + 1)*(I + 2)/2
            CALL SETCLB(I,LABINT,MXQN*(MXQN+1)*(MXQN+2)/6)
         ELSE
            CALL LMNVAL(I+1,(I + 1)*(I + 2)/2,IX,IY,IZ)
            DO 200 K = 1, (I + 1)*(I + 2)/2
               J  = J + 1
               NX = IX(K)
               NY = IY(K)
               NZ = IZ(K)
               LABINT(J) = SPDCAR(I)//CHRNOS(NX)//CHRNOS(NY)//CHRNOS(NZ)
  200       CONTINUE
         END IF
  100 CONTINUE
      RETURN
      END
C  /* Deck aotoao */
      SUBROUTINE AOTOAO(IAOAO,IPREAD)
C
C     This subroutine sets up pointer IAOAO which convertes between
C     two different orderings of AO's: from the ordering
C     of MOLECULE to an ordering in which the outer loop is over
C     atoms. (This orderings are identical when no symmetry is used.)
C
C     The purpose of this ordering is to make the AO's appear in the
C     same order as in the corresponding run with no symmetry.
C
C     tuh 120988
C
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxcent.h>
#include <maxorb.h>
C
      DIMENSION IAOAO(MXCORB)
C
#include <symmet.h>
#include <nuclei.h>
#include <shells.h>
C
#include <ibtfun.h>
C
      IF (IPREAD .GE. 10) CALL TITLER('Output from AOTOAO','*',103)
C
C     Loop over all atoms
C
      IAO   = 0
      JATOM = 0
      DO 100 IATOM = 1, NUCIND
         ISTABA = ISTBNU(IATOM)
         DO 200 ISYMOP = 0, MAXREP
         IF (IBTAND(ISYMOP,ISTABA) .EQ. 0) THEN
            JATOM = JATOM + 1
C
C           Loop over all orbitals
C
            JAO = 0
            DO 300 ISHELL = 1, KMAX
               ICENT  = NCENT(ISHELL)
               ISTABO = ISTBAO(ISHELL)
               DO 400 ICMP = 1, KHKT(ISHELL)
                  DO 500 JSYMOP = 0, MAXREP
                  IF (IBTAND(JSYMOP,ISTABO) .EQ. 0) THEN
                     JAO = JAO + 1
                     JCENT = NUCNUM(ICENT,JSYMOP+1)
                     IF (JATOM .EQ. JCENT) THEN
                        IAO = IAO + 1
                        IAOAO(JAO) = IAO
                     END IF
                  END IF
  500             CONTINUE
  400          CONTINUE
  300       CONTINUE
C
C           End loop over orbitals
C
         END IF
  200    CONTINUE
  100 CONTINUE
C
C     End loop over atoms
C
      IF (IPREAD .GE. 10) THEN
         CALL HEADER('I - IAOAO',6)
         DO 600 I = 1, IAO
            WRITE (LUPRI,'(4X,I5,1X,I5)') I, IAOAO(I)
  600    CONTINUE
      END IF
      RETURN
      END
C/* Deck cntao */
      SUBROUTINE CNTAO(IPRINT)
C 
C     tuh
C
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxcent.h>
#include <maxorb.h>
C
#include <symmet.h>
#include <nuclei.h>
#include <shells.h>
C
#include <ibtfun.h>
C
      IORB = 0
      DO 100 LA = 0, MAXREP
      DO 200 IA = 1, KMAX
         DO 300 NA = 1, KHKT(IA)
            IVARB = IBTXOR(LA,ISYMAO(NHKT(IA),NA))
            IF (IBTAND(ISTBAO(IA),IVARB) .EQ. 0) THEN
               IORB = IORB + 1
               ICNTAO(IORB)  = NCENT(IA)
            END IF
  300    CONTINUE
  200 CONTINUE
  100 CONTINUE
C
      IF (IPRINT .GE. 10) THEN
         CALL HEADER('ICNTAO',-1)
         DO 400 I = 1, IORB
            WRITE (LUPRI,'(4X,I5,1X,I5)') I, ICNTAO(I)
  400    CONTINUE
      END IF
      RETURN
      END
C  /* Deck magcor */
      SUBROUTINE MAGCOR(IPREAD)
C
C     Printing of symmetrized nuclear magnetic moments
C
C     tuh March 1991
C
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxcent.h>
#include <maxorb.h>
C
      INTEGER NBASE(8), NSIGN(8), NRTREP(0:7)
C
#include <cbiher.h>
#include <nuclei.h>
#include <symmet.h>
#include <pgroup.h>
#include <chrxyz.h>
#include <chrsgn.h>
C
#include <ibtfun.h>
C
      IF (NMRISS .AND. MAXREP .GT. 0) THEN
         IF (IPREAD .GT. 0) THEN
            WRITE (LUPRI,'(/)')
            CALL HEADER('Symmetrized nuclear magnetic moments',1)
         END IF
         DO 100 IREP = 0, MAXREP
            NRTREP(IREP) = 0
            DO 110 ICENT = 1, NUCIND
               DO 120 ICOOR = 1, 3
                  ISCOOR = IPTCNT(3*(ICENT - 1) + ICOOR,IREP,2)
                  IF (ISCOOR .GT. 0) NRTREP(IREP) = NRTREP(IREP) + 1
 120           CONTINUE
 110        CONTINUE
 100     CONTINUE
         IF (IPREAD .GT. 0) THEN
            WRITE (LUPRI,'(A,8I3)')
     &           '  Number of components in each symmetry: ',
     &           (NRTREP(I),I=0,MAXREP)
         END IF
C
         DO 200 IREP = 0, MAXREP
         IF (NRTREP(IREP) .GT. 0) THEN
            IF (IPREAD .GT. 0) THEN
              WRITE (LUPRI,'(//2X,A,2X,A3,A1,I2,A1/)')
     &           'Symmetry',REP(IREP),'(',IREP,')'
            END IF
            DO 210 ICENT = 1, NUCIND
               DO 220 ICOOR = 1, 3
                  ISCOOR = IPTCNT(3*(ICENT - 1) + ICOOR,IREP,2)
                  IF (ISCOOR .GT. 0) THEN
                     IVAR = IBTXOR(IREP,ISYMAX(ICOOR,2))
                     NB = 0
                     DO 230 ISYMOP = 0, MAXOPR
                     IF (IBTAND(ISYMOP,ISTBNU(ICENT)) .EQ. 0) THEN
                        NB = NB + 1
                        NSIGN(NB) = NINT(PT(IBTAND(ISYMOP,IVAR)))
                        NBASE(NB) = 3*(NUCNUM(ICENT,ISYMOP+1)-1) + ICOOR
                     END IF
 230                 CONTINUE
                     IF (IPREAD .GT. 0) THEN
                        WRITE (LUPRI,
     &                  '(2X,A,I3,3X,A,2X,A,3X,I2,7(2X,A,1X,I2))')
     &                  'I',ISCOOR, NAMEX(3*ICENT)(1:4), CHRXYZ(-ICOOR),
     &                  NBASE(1), (CHRSGN(NSIGN(I)),NBASE(I),I=2,NB)
                     END IF
                  END IF
  220          CONTINUE
  210       CONTINUE
         END IF
  200    CONTINUE
      END IF
      RETURN
      END
C  /* Deck tracor */
      SUBROUTINE TRACOR(CSTRA,SCTRA,ITYPE,NCOOR,IPRINT)
C
C     Sets up transformation matrices between Cartesian and symmetry
C     nuclear coordinates
C
C     tuh Jun 29 1988
C
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <mxcent.h>
#include <maxorb.h>
#include <thrzer.h>
      PARAMETER (D0 = 0.0D0)
C
#include <nuclei.h>
#include <symmet.h>
C
      DIMENSION CSTRA(NCOOR,NCOOR), SCTRA(NCOOR,NCOOR)
C
#include <ibtfun.h>
C
      CALL DZERO(CSTRA,NCOOR*NCOOR)
      CALL DZERO(SCTRA,NCOOR*NCOOR)
C
C     *****************************************************************
C     **** Transformation matrix Cartesian to symmetry coordinates ****
C     *****************************************************************
C
      DO 100 IREP = 0, MAXREP
         NCRREP(IREP,ITYPE) = 0
         DO 110 ICENT = 1, NUCIND
            MULCNT = ISTBNU(ICENT)
            DO 120 ICOOR = 1, 3
               IF (ITYPE .EQ. 1) THEN
                  ISCOOR = IPTCNT(3*(ICENT-1)+ICOOR,IREP,1)
                  IF (ISCOOR .GT. 0) THEN
                     NCRREP(IREP,1) = NCRREP(IREP,1) + 1
                     IVAR = IBTXOR(IREP,ISYMAX(ICOOR,1))
                     DO 130 ISYMOP = 0, MAXOPR
                        IF (IBTAND(ISYMOP,MULCNT) .EQ. 0) THEN
                           ICCOOR = 3*(NUCNUM(ICENT,ISYMOP+1) - 1)+ICOOR
                           CSTRA(ISCOOR,ICCOOR)=PT(IBTAND(ISYMOP,IVAR))
                        END IF
 130                 CONTINUE
                  END IF
               ELSE
                  LSCOOR = IPTCNT(3*(ICENT-1)+ICOOR,IREP,2)
                  IF (LSCOOR .GT. 0) THEN
                     NCRREP(IREP,2) = NCRREP(IREP,2) + 1
                     IVAR = IBTXOR(IREP,ISYMAX(ICOOR,2))
                     DO 140 ISYMOP = 0, MAXOPR
                        IF (IBTAND(ISYMOP,MULCNT) .EQ. 0) THEN
                           ICCOOR = 3*(NUCNUM(ICENT,ISYMOP+1) - 1)+ICOOR
                           CSTRA(LSCOOR,ICCOOR)=PT(IBTAND(ISYMOP,IVAR))
                        END IF
 140                 CONTINUE
                  END IF
               END IF
 120        CONTINUE
 110     CONTINUE
 100  CONTINUE
      IF (IPRINT .GE. 20) THEN
         IF (ITYPE .EQ. 1) THEN
            WRITE (LUPRI,'(/A,8I3,/)')
     *           '  Number of coordinates in each symmetry: ',
     *           (NCRREP(I,1),I=0,MAXREP)
            CALL HEADER('Transformation from Cartesian to symmetry '
     *                //'coordinates',-1)
         ELSE
            CALL HEADER('Transformation from rotational cartesian '//
     &                  'to symmetry coordinates',-1)
         END IF
         DO 200 ISYM = 1, NCOOR
            WRITE (LUPRI,'(9F6.2)') (CSTRA(ISYM,J),J=1,NCOOR)
 200     CONTINUE
      END IF
C
C     Inverted matrix
C
      DO 210 I = 1, NCOOR
         DO 220 J = 1, NCOOR
           SCTRA(I,J) = CSTRA(J,I)
  220    CONTINUE
  210 CONTINUE
      DO 230 ICOL = 1, NCOOR
         SUM1 = D0
         SUM2 = D0
         DO 240 IROW = 1, NCOOR
            SUM1 = SUM1 + ABS(SCTRA(IROW,ICOL))
  240    CONTINUE
         IF (SUM1 .LT. THRZER) GOTO 230
         DO 250 IROW = 1, NCOOR
            SCTRA(IROW,ICOL) = SCTRA(IROW,ICOL)/SUM1
  250    CONTINUE
  230 CONTINUE
C
      RETURN
      END
C  /* Deck tracr */
      SUBROUTINE TRACR(NCOOR)
C
C     Set up IPTCOR - points from symmetry coordinate to generating
C     Cartesian coordinate. Extracted from old TRACOR routine by
C     K.Ruud, Dec-96
C
#include <implicit.h>
#include <mxcent.h>
#include <maxaqn.h>
#include <maxorb.h>
C
#include <symmet.h>
C
      DO 400 ITYPE = 1, 2
         IJ = 0
         DO 410 J = 0, MAXREP
            DO 420 I = 1, NCOOR
               IF (IPTCNT(I,J,ITYPE) .NE. 0) THEN
                  IJ = IJ + 1
                  IPTCOR(IJ,ITYPE) = I
               END IF
  420       CONTINUE
  410    CONTINUE
  400 CONTINUE
      RETURN
      END
C  /* Deck setclb */
      SUBROUTINE SETCLB(I,LABINT,NDIM)
#include <implicit.h>
      CHARACTER LABINT(NDIM)*4
      IF (I .EQ. 0) THEN
         LABINT(1) = 's   '
      ELSE IF (I .EQ. 1) THEN
         LABINT(2) = 'px  '
         LABINT(3) = 'py  '
         LABINT(4) = 'pz  '
      ELSE IF (I .EQ. 2) THEN
         LABINT(5)  = 'dxx '
         LABINT(6)  = 'dxy '
         LABINT(7)  = 'dxz '
         LABINT(8)  = 'dyy '
         LABINT(9)  = 'dyz '
         LABINT(10) = 'dzz '
      ELSE IF (I .EQ. 3) THEN
         LABINT(11)  = 'fxxx'
         LABINT(12)  = 'fxxy'
         LABINT(13)  = 'fxxz'
         LABINT(14)  = 'fxyy'
         LABINT(15)  = 'fxyz'
         LABINT(16)  = 'fxzz'
         LABINT(17)  = 'fyyy'
         LABINT(18)  = 'fyyz'
         LABINT(19)  = 'fyzz'
         LABINT(20)  = 'fzzz'
      END IF
      RETURN
      END
C  /* Deck spdcar */
      FUNCTION SPDCAR(IORDER)
#include <implicit.h>
      CHARACTER*1 SPDCAR
      IF (IORDER .EQ. 0) THEN
         SPDCAR = 's'
      ELSE IF (IORDER .EQ. 1) THEN
         SPDCAR = 'p'
      ELSE IF (IORDER .EQ. 2) THEN
         SPDCAR = 'd'
      ELSE IF (IORDER .LE. 6) THEN
         SPDCAR = CHAR(ICHAR('f') + IORDER - 3)
      ELSE
C
C        Note: j is not used - therefore this special case
C
         SPDCAR = CHAR(ICHAR('k') + IORDER - 7)
      END IF
      RETURN
      END
C  /* Deck sphinp */
      SUBROUTINE SPHINP(LUINFO,WORK,LWORK,DOOWN,MXSPD)
C
C     Calculate spherical harmonic transformation coefficients
C     or, if DOOWN true, read user specified coefficients.
C
#include <implicit.h>
#include <priunit.h>
      PARAMETER (D1 = 1.0D0)
#include <mxcent.h>
#include <maxaqn.h>
#include <sphtrm.h>
#include <molinp.h>
#include <ccom.h>
#include <cbirea.h>
      CHARACTER*1 KEY
      LOGICAL DOOWN
      DIMENSION WORK(LWORK)
C
      IF (DOOWN) THEN
         WRITE(LUPRI,'(/A)') 
     &   '  Reading user specified transformation matrices for GTOs.'
      ELSE IF (IPREAD .GT. 4) THEN
         WRITE(LUPRI,'(/A)') 
     &   '  Calculation of transformation matrices for spherical GTOs.'
      END IF
C
      MXSPD = MXQN
C
      IOFF = 1
      DO 100 I = 1, MXQN
         KCK(I)    = I*(I+1)/2
         ISPADR(I) = IOFF
         IOFF      = IOFF + KCK(I)**2
         IF (DOOWN) THEN
            SPH(I) = .TRUE.
         ELSE
            IF (DOCART) THEN
               KHK(I) = I*(I+1)/2
               SPH(I) = .FALSE.
            ELSE
               KHK(I) = 2*I - 1
               SPH(I) = I .GT. 2
            END IF
         END IF
  100 CONTINUE
C
      SPHNRM = .TRUE.
C
      IF (DOCART) THEN
         CALL CARLAB(MXQN-1,GTOTYP)
      ELSE
         CALL DZERO(CSP,NCSP)
         IF (.NOT.DOOWN) THEN
            CALL SPHLAB(MXQN-1,GTOTYP)
            KCSPT = 1
            KWRK  = KCSPT + (MXQN*(MXQN + 1)/2)*(2*MXQN - 1)
            IF (KWRK .GT. LWORK) CALL STOPIT('SPHINP',' ',KWRK,LWORK)
            LWRK  = LWORK - KWRK + 1
            DO 200 LVAL = 0, MXQN - 1
               NLM = 2*LVAL + 1
               NXYZ = (LVAL+1)*(LVAL+2)/2
               IF (LVAL .EQ. 0) THEN
                  CSP(1)  = D1
               ELSE IF (LVAL .EQ. 1) THEN
                  CSP (2) = D1
                  CSP (6) = D1
                  CSP(10) = D1
               ELSE
                  IF (OLDNRM) THEN
C                    use old Dalton 1.0 normalization
                     MINTEG = 0
                     SPHNRM = .FALSE.
                  ELSE
C                    generate normalized s,p,d,f,g,h,i GTO's
                     MINTEG = 2
                  END IF
                  CALL SPHCOM(LVAL,WORK(KCSPT),NLM,NXYZ,1,MINTEG,
     &                        WORK(KWRK),LWRK,IPREAD)
                  CALL MTRSP(NXYZ,NLM,WORK(KCSPT),NXYZ,
     &                       CSP(ISPADR(LVAL+1)),NLM)
               END IF
  200       CONTINUE
         ELSE
            CALL RDLINE(LUINFO)
            READ (MLINE(NMLINE),'(BN,I5)') MXSPD
            IF (MXSPD .GT. MXQN) THEN
              WRITE (LUPRI,'(/A/I10,A,I4//A//A/A)')
     &        ' ERROR: specified MXSPD for GTO transformation matrix',
     &        MXSPD,' is greater than allowed max value of',MXQN,
     &        ' Dump of last two lines read from .mol file:',
     &        MLINE(NMLINE-1),MLINE(NMLINE)
              CALL QUIT('ERROR in reading .mol file, see output')
            END IF
            IOFF = 1
            DO 300 I = 1, MXSPD
               CALL RDLINE(LUINFO)
               READ (MLINE(NMLINE),'(BN,4X,A1,I5)')  KEY, KHK(I)
               IF (KHK(I) .GT. KCK(I)) THEN
                 WRITE (LUPRI,'(/A,I5,A,I3/A,I5,A//A//A)')
     &           ' ERROR: you specified',KHK(I),
     &           ' components for GTO transformation matrix for L =',
     &           I-1,' and that is greater than',KCK(I),
     &           ', the number of Cartesian components.',
     &           ' Dump of last line read from .mol file:',MLINE(NMLINE)
                 CALL QUIT('ERROR in reading .mol file, see output')
               END IF
               CALL RDCSP(LUINFO,CSP(ISPADR(I)),GTOTYP(IOFF),
     &           KHK(I),KCK(I))
               IOFF = IOFF + KHK(I)
  300       CONTINUE
         END IF
         IF (DOOWN .OR. IPREAD .GT. 4) THEN
            CALL HEADER('Cartesian transformation matrices',-1)
            IF (DOOWN) THEN
               WRITE (LUPRI,'(A/)') '  to user specified combinations'
            ELSE
               WRITE (LUPRI,'(A/)') '  to spherical harmonics'
            END IF
            IOFF = 0
            DO 400 I = 1, MXSPD
               KHKI = KHK(I)
               KCKI = KCK(I)
               WRITE (LUPRI,'(A,I5//A/,(5X,15(A4,1X)))')
     &            '  Coefficients for angular quantum number ',I-1,
     &            '  to GTOs with labels:',(GTOTYP(IOFF+J),J=1,KHKI)
               IOFF = IOFF + KHKI
               CALL OUTPUT(CSP(ISPADR(I)),1,KHKI,1,KCKI,KHKI,KCKI,1,
     &                     LUPRI)
 400        CONTINUE
            CALL FLSHFO(LUPRI)
         END IF
      END IF
      RETURN
      END
C  /* Deck rdcsp */
      SUBROUTINE RDCSP(LUINFO,CSP,GTOTYP,KHKI,KCKI)
#include <implicit.h>
#include <priunit.h>
#include <mxcent.h>
#include <molinp.h>
      CHARACTER*4 GTOTYP(*)
      DIMENSION CSP(KHKI,KCKI)
      DO 100 I = 1, KHKI
         CALL RDLINE(LUINFO)
         READ (MLINE(NMLINE),'(BN,1X,A,5F15.0:/,(5X,5F15.0))')
     &          GTOTYP(I), (CSP(I,J),J=1,KCKI)
  100 CONTINUE
      RETURN
      END
C  /* Deck rdline */
      SUBROUTINE RDLINE(LUINFO)
#include <implicit.h>
#include <priunit.h>
#include <mxcent.h>
#include <maxorb.h>
#include <molinp.h>
#include <infpar.h>
   10 CONTINUE
      NMLINE = NMLINE + 1
C
C     Only the master in a parallel calc. reads the input file.
C     The slaves get the input transferred from the master in
C     the common block MOLINP. /hjaaj
C
      IF (.NOT. SLAVE) READ (LUINFO,'(A)') MLINE(NMLINE)
      IF (NMLINE.GT.KMLINE) THEN
         WRITE (LUPRI,'(//A,/A,I5)')
     &      ' READIN ERROR: Too many lines in input -,',
     &      ' Increase dimension in /MOLINP/ to at least',NMLINE
         CALL QUIT('*** ERROR *** Too many input lines for READIN')
      END IF
      IF((MLINE(NMLINE)(1:1).EQ.'#') .OR. (MLINE(NMLINE)(1:1).EQ.'!'))
     &         GOTO 10
      RETURN
      END
C  /* Deck wronel */
      SUBROUTINE WRONEL(TITLE,NONTYP,NONT,IQM,IFXYZ,KATOM,JCO2,KANG)
C
C     Write interface records
C
#include <implicit.h>
#include <priunit.h>
#include <mxcent.h>
#include <dummy.h>
#include <maxorb.h>
#include <maxaqn.h>
C
      CHARACTER*72 TITLE(2)
      CHARACTER*8 CDATE,CTIME
      CHARACTER*8 TABLE1(4), TABLE2(4), TABLE3(4), TABLE4(4), TABLE5(4)
      DIMENSION QPOL(6), QQ(3), IFXYZ(3), JFXYZ(3)
      DIMENSION CHRN(MXCENT), COOO(MXCENT,3),
     &          INAMN(MXCORB), IGTO(MXCORB), RTITLE(24)
      DIMENSION NONT(KATOM), IQM(KATOM), JCO2(KANG,KATOM,2)
#include <ccom.h>
#include <shells.h>
#include <symmet.h>
#include <aosotr.h>
#include <frame.h>
#include <inftap.h>
#include <nuclei.h>
#include <sphtrm.h>
      DATA TABLE1 /'********','        ','        ','ISORDK  '/,
     &     TABLE2 /'********','        ','        ','SCFINP  '/,
     &     TABLE3 /'********','        ','        ','SYMINPUT'/,
     &     TABLE4 /'********','        ','        ','TESTDATA'/,
     &     TABLE5 /'********','        ','        ','SPHERICA'/
      DATA QPOL/6*DUMMY/, QQ/3*DUMMY/, JFXYZ/3*IDUMMY/
#include <ibtfun.h>
C
      CALL GETDAT(CDATE,CTIME)
      TABLE1(2) = CDATE
      TABLE2(2) = CDATE
      TABLE3(2) = CDATE
      TABLE4(2) = CDATE
      TABLE5(2) = CDATE
      TABLE1(3) = CTIME
      TABLE2(3) = CTIME
      TABLE3(3) = CTIME
      TABLE4(3) = CTIME
      TABLE5(3) = CTIME
C
      READ (TITLE(1),'(12A6)') (RTITLE(I),I= 1,12)
      READ (TITLE(2),'(12A6)') (RTITLE(I),I=13,24)
C
      ICENT = 0
      DO 100 N = 1, NUCIND
      DO 100 IREP = 0,MAXREP
         IF (IBTAND(ISTBNU(N),IREP) .EQ. 0) THEN
            ICENT = ICENT + 1
            CHRN(ICENT)   = CHARGE(N)
            COOO(ICENT,1) = PT(IBTAND(ISYMAX(1,1),IREP))*CORD(1,N)
            COOO(ICENT,2) = PT(IBTAND(ISYMAX(2,1),IREP))*CORD(2,N)
            COOO(ICENT,3) = PT(IBTAND(ISYMAX(3,1),IREP))*CORD(3,N)
      END IF
  100 CONTINUE
C
      I = 0
      DO 200 ISYMOP = 0, MAXREP
         NBI = NAOS(ISYMOP+1)
         DO 220 L = 1,NBI
            I = I + 1
            READ(  NAMN(IPCEN(I)),'(A4)') INAMN(I)
            READ(GTOTYP(IPTYP(I)),'(A4)') IGTO(I)
  220    CONTINUE
  200 CONTINUE
C
C     0 - unlabeled first record
C     ==========================
C
      REWIND LUONEL
      WRITE (LUONEL) RTITLE,MAXREP+1,(NAOS(I),I=1,MAXREP+1), POTNUC
C
C     1 - ISORDK
C     ==========
C
      WRITE (LUONEL) TABLE1
      WRITE (LUONEL) DUMMY, DUMMY, DUMMY, DUMMY
      WRITE (LUONEL) CHRN, NUCDEP, COOO
C
C     2 - SCFINP
C     ==========
C
      WRITE (LUONEL) TABLE2
      WRITE (LUONEL) RTITLE,
     &               MAXREP+1, (NAOS(I), I = 1,MAXREP+1),
     &               POTNUC,
     &               KMAX, (NCENT(I), I = 1,KMAX),
     &               NBASIS, ( JTRAN(I),             I = 1,NBASIS),
     &                       ((ITRAN(I,J), J = 1,8), I = 1,NBASIS),
     &                       ((CTRAN(I,J), J = 1,8), I = 1,NBASIS),
     &               NBASIS, ( INAMN(I),             I = 1,NBASIS),
     &                       ( IGTO(I),              I = 1,NBASIS),
     &               DPNUC,
     &               NUCDEP, ((COOO(I,J),J=1,3),I=1,NUCDEP),
     &               IFXYZ, DUMMY, QPOL, QQ, JFXYZ
C
C     3 - SYMINPUT
C     ============
C
      WRITE (LUONEL) TABLE3
      WRITE (LUONEL) NBASIS,(INAMN(I),I=1,NBASIS),(IGTO(I),I=1,NBASIS),
     &               POTNUC,DUMMY,DUMMY,DUMMY
C
C     4 - TESTDATA
C     ============
C
C     Information for testing magnetic integrals
C
      WRITE (LUONEL) TABLE4
      WRITE (LUONEL) NONTYP, (NONT(I), I = 1, NONTYP),
     &               (IQM(I), (JCO2(J,I,1),J=1,IQM(I)), I = 1, NONTYP),
     &               (IDUMMY,I=1,5)
C
C     5 - SPHERICA
C     ============
C
C     Information for testing spherical transformation
C
      IDOCRT = 1
      IF (.NOT.DOCART) IDOCRT = 0
      WRITE (LUONEL) TABLE5
      WRITE (LUONEL) KMAX, IDOCRT, (NHKT(I),I = 1,KMAX), (IDUMMY,I=1,5)
      WRITE (LUONEL) MAXREP, (ISTBAO(I),I=1,KMAX), (IDUMMY,I=1,6)
      WRITE (LUONEL) MXQN, MXAQN, ((ISYMAO(I,J),I=1,MXQN),J=1,MXAQN)
      WRITE (LUONEL) (CSP(I),I=1,NCSP),(ISPADR(I),I=1,MXQN)
C
      RETURN
      END
C  /* Deck reapri */
      SUBROUTINE REAPRI
#include <implicit.h>
#include <priunit.h>
#include <dummy.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
C
#include <abainf.h>
#include <cbirea.h>
C
#include <molinp.h>
#include <ccom.h>
#include <nuclei.h>
#include <frame.h>
#include <primit.h>
#include <shells.h>
#include <symmet.h>
#include <aosotr.h>
#include <chrsgn.h>
C
      CALL HEADER('Test output from REAPRI',-1)
      WRITE(LUPRI,'(A,F12.6)') '  THRS  ', THRS
      WRITE(LUPRI,'(A,I5)')    '  NHTYP ', NHTYP
      WRITE(LUPRI,'(A,L5)')    '  DOCART', DOCART
      WRITE(LUPRI,*) 'charge ',(CHARGE(i),i=1,nucind)
      WRITE(LUPRI,*) 'cord1',(cord(1,i),i=1,nucind)
      WRITE(LUPRI,*) 'cord2',(cord(2,i),i=1,nucind)
      WRITE(LUPRI,*) 'cord2',(cord(3,i),i=1,nucind)
      WRITE(LUPRI,*) 'noorbt ',(noorbt(i),i=1,nucind)
      WRITE(LUPRI,*) 'nucind,nucdep',NUCIND, NUCDEP, NUCNUM(i,8)
      WRITE(LUPRI,*) 'nucpre ',(nucpre(i),i=1,nucind)
      WRITE(LUPRI,*) 'nucnum ',((NUCNUM(i,j),i=1,nucind),j=1,8)
      WRITE(LUPRI,*) 'nucdeg ',(nucdeg(i),i=1,nucind)
      WRITE(LUPRI,*) 'istbnu ',(istbnu(i),i=1,nucind)
      WRITE(LUPRI,*) 'ntraco,itraco',NTRACO, (ITRACO(i),i=1,3)
      WRITE(LUPRI,*) 'NATOMS, NFLOAT, NBASIS, NPBAS',
     &          NATOMS, NFLOAT, NBASIS, NPBAS
      WRITE(LUPRI,*) 'namex ',(namex(i),i=1,3*nucind)
      WRITE(LUPRI,*) 'namdep',(namdep(i),i=1,nucdep)
      WRITE(LUPRI,*) 'namdpx',(namdpx(i),i=1,nucdep)
      call header('priexp',-1)
      call output(priexp,1,1,1,mxprim,1,mxprim,1,lupri)
      call header('priccf',-1)
      call output(priccf,1,mxprim,1,mxcont,mxprim,mxcont,1,lupri)
      call header('pricrx',-1)
      call output(pricrx,1,mxprim,1,3,mxprim,3,1,lupri)
      WRITE(LUPRI,*) ' kmax ', kmax
      call header('cent',-1)
      call output(cent,1,kmax,1,3,kmax,3,1,lupri)
      WRITE(LUPRI,*) ' nhkt ',(nhkt(i),i=1,kmax)
      WRITE(LUPRI,*) ' khkt ',(khkt(i),i=1,kmax)
      WRITE(LUPRI,*) ' kckt ',(kckt(i),i=1,kmax)
      WRITE(LUPRI,*) ' istbao ',(istbao(i),i=1,kmax)
      WRITE(LUPRI,*) ' nuco ',(nuco(i),i=1,kmax)
      WRITE(LUPRI,*) ' jstrt ',(jstrt(i),i=1,kmax)
      WRITE(LUPRI,*) ' nstrt ',(nstrt(i),i=1,kmax)
      WRITE(LUPRI,*) ' mst ',(mst(i),i=1,kmax)
      WRITE(LUPRI,*) ' ncent ',(ncent(i),i=1,kmax)
      WRITE(LUPRI,*) ' share ',(share(i),i=1,kmax)
      WRITE(LUPRI,*) ' nrco ',(nrco(i),i=1,kmax)
      WRITE(LUPRI,*) ' numcf ',(numcf(i),i=1,kmax)
      WRITE(LUPRI,*) ' nbch ',(nbch(i),i=1,kmax)
      WRITE(LUPRI,*) ' kstrt ',(kstrt(i),i=1,kmax)
      WRITE(LUPRI,*) ' segm ',(segm(i),i=1,kmax)
      WRITE(LUPRI,*) ' iptshl ',(iptshl(i),i=1,kmax)
      WRITE(LUPRI,*) ' numcft ',(numcft(i),i=1,kmax)
      WRITE(LUPRI,*) ' sphr ',(sphr(i),i=1,kmax)
      WRITE(LUPRI,*) ' fmult ',(fmult(i),i=0,7)
      WRITE(LUPRI,*) ' pt ',(pt(i),i=0,7)
      WRITE(LUPRI,*) ' mult ',(mult(i),i=0,7)
      WRITE(LUPRI,*) ' maxrep, maxopr ',MAXREP, MAXOPR
      WRITE(LUPRI,*) ' isymax ',((isymax(i,j),i=1,3),j=1,2)
      WRITE(LUPRI,*) ' isymao ',((isymao(i,j),i=1,mxqn),j=1,mxaqn)
      WRITE(LUPRI,*) ' nparsu ',(nparsu(i),i=1,8)
      WRITE(LUPRI,*) ' naos ',(naos(i),i=1,8)
      WRITE(LUPRI,*) ' nparnu ',((nparnu(i,j),i=1,8),j=1,8)
      WRITE(LUPRI,*) ' iptsym ',((iptsym(i,j),i=1,norbs),j=0,7)
      WRITE(LUPRI,*) ' iptcnt ',
     &     (((iptcnt(i,j,k),i=1,3*nucdep),j=0,7),k=1,2)
      WRITE(LUPRI,*) ' ncrrep ',((ncrrep(i,j),i=0,7),j=1,2)
      WRITE(LUPRI,*) ' iptcor ',((iptcor(i,j),i=1,3*nucdep),j=1,2)
      WRITE(LUPRI,*) ' naxrep ',((naxrep(i,j),i=0,7),j=1,2)
      WRITE(LUPRI,*) ' iptax ',((iptax(i,j),i=1,3),j=1,2)
      WRITE(LUPRI,*) ' iptxyz ',(((iptxyz(i,j,k),i=1,3),j=0,7),k=1,2)
      WRITE(LUPRI,*) ' iptnuc ',((iptnuc(i,j),i=1,nucdep),j=0,7)
      call header('ctran',-1)
      call output(ctran,1,nbasis,1,8,mxcorb,8,1,lupri)
      WRITE(LUPRI,*) ' itran ',((itran(i,j),i=1,nbasis),j=1,8)
      WRITE(LUPRI,*) ' iaoao ',(iaoao(i),i=1,nbasis)
      return
      end
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
C  /* Deck symgrp */
      SUBROUTINE SYMGRP(IGEN,NSYMOP,CLASS)
C*****************************************************************************
C
C     Given the group generators, this subroutine will identify
C     Abelian subgroup and set up group multiplication table,
C     character table and direct product table. Irreps are identified.
C
C     tsaue - august 1994
C
C*****************************************************************************
#include <implicit.h>
#include <priunit.h>
#include <maxaqn.h>
#include <maxorb.h>
#include <mxcent.h>
C
#include <symmet.h>
#include <inftap.h>
#include <pgroup.h>
#include <cbirea.h>
      LOGICAL LSYMOP(0:7)
      DIMENSION IGEN(3),IROTS(3),IREFL(3)
      CHARACTER*(*) CLASS
      CHARACTER*3 GROUPS(0:7)
      DATA IROTS/3,5,6/
      DATA IREFL/4,2,1/
#include <ibtfun.h>
C
C     Symmetry operations
C     ===================
C
C         zyx
C     0   000    E   identity
C     1   001   Oyz  reflection in the yz-plane
C     2   010   Oxz  reflection in the xz-plane
C     3   011   C2z  rotation about the z-axis
C     4   100   Oxy  reflection in the xy-plane
C     5   101   C2y  rotation about the y-axis
C     6   110   C2x  rotation about the x-axis
C     7   111    i   inversion centre
C
      SYMOP(0) = ' E '
      SYMOP(1) = 'Oyz'
      SYMOP(2) = 'Oxz'
      SYMOP(3) = 'C2z'
      SYMOP(4) = 'Oxy'
      SYMOP(5) = 'C2y'
      SYMOP(6) = 'C2x'
      SYMOP(7) = ' i '
C
C     Point groups
C     ============
C
      GROUPS(0) = 'C1 '
      GROUPS(1) = 'C2 '
      GROUPS(2) = 'Cs '
      GROUPS(3) = 'Ci '
      GROUPS(4) = 'D2 '
      GROUPS(5) = 'C2v'
      GROUPS(6) = 'C2h'
      GROUPS(7) = 'D2h'
      DO 5 I = 0,7
        LSYMOP(I) = .FALSE.
    5 CONTINUE
C
C     Activate all symmetry operations of the group
C     =============================================
C
      DO 10 I = 1,NSYMOP
        LSYMOP(IGEN(I)) = .TRUE.
        DO 20 J = 1,(I-1)
          IND      = IBTXOR(IGEN(I),IGEN(J))
          LSYMOP(IND) = .TRUE.
          DO 30 K = 1,(J-1)
            LSYMOP(IBTXOR(IND,IGEN(K))) = .TRUE.
   30     CONTINUE
   20   CONTINUE
   10 CONTINUE
C
C     List group operations in preferred order,
C       that is construct pointer LSOP
C     =========================================
C
C     Identity
C
      IND = 0
      ISOP(IND) = 0
C
C     Rotations
C
      NROTS = 0
      DO 40 I = 1,3
      IF(LSYMOP(IROTS(I))) THEN
        IND         = IND + 1
        ISOP(IND) = IROTS(I)
        NROTS       = NROTS + 1
      ENDIF
   40 CONTINUE
C
C     Inversion
C
      NINVC = 0
      IF(LSYMOP(7)) THEN
        IND         = IND + 1
        ISOP(IND) = 7
        NINVC       = 1
      ENDIF
C
C     Reflections
C
      NREFL = 0
      DO 50 I = 1,3
      IF(LSYMOP(IREFL(I))) THEN
        IND         = IND + 1
        ISOP(IND) = IREFL(I)
        NREFL       = NREFL + 1
      ENDIF
   50 CONTINUE
      IF(IND.NE.MAXREP) CALL QUIT('SYMGRP:IND.NE.MAXREP!')
C
C     Classify group
C     ==============
C     tsaue - Here I have devised a highly empirical formula, but
C             it works !!!
C
      IGROUP = MIN(7,NINT((4*NROTS+8*NINVC+6*NREFL)/3.0))
      GROUP  = GROUPS(IGROUP)
C
C     Generate character table
C     ========================
C
      DO 60 I = 0,MAXREP
        IXVAL(0,I) = 1
        DO 70 J = 1,NSYMOP
          IXVAL(IGEN(J),I) = NINT(PT(IBTAND(IBTSHR(I,(J-1)),1)))
          DO 80 K = 1,(J-1)
            IND      = IBTXOR(IGEN(J),IGEN(K))
            IXVAL(IND,I)  = IXVAL(IGEN(J),I)*IXVAL(IGEN(K),I)
            DO 90 L = 1,(K-1)
              IXVAL(IBTXOR(IND,IGEN(L)),I)
     &           = IXVAL(IND,I)*IXVAL(IGEN(L),I)
   90       CONTINUE
   80     CONTINUE
   70   CONTINUE
   60 CONTINUE
C
C     Classify irrep
C     ==============
C
      DO 100 I = 0,MAXREP
        REP(I) = 'A  '
        IPOS = 2
C
C       Rotational symmetry
C
        IF(NROTS.EQ.3) THEN
          IND = (1-IXVAL(ISOP(1),I))+(1-IXVAL(ISOP(2),I))/2
          IF(IND.NE.0) THEN
            REP(I)(1:1) = 'B'
            REP(I)(2:2) = CHAR(ICHAR('0')+IND)
            IPOS = 3
          ENDIF
        ELSEIF(NROTS.EQ.1) THEN
          IF(IXVAL(ISOP(1),I).EQ.-1) REP(I)(1:1) = 'B'
          IF(NREFL.EQ.2) THEN
            IF(IBTAND(IBTSHR(ISOP(1),1),1).EQ.1) THEN
              IND = 2
            ELSE
              IND = 3
            ENDIF
            IF(IXVAL(ISOP(IND),I).EQ.1) THEN
              REP(I)(2:2) = '1'
            ELSE
              REP(I)(2:2) = '2'
            ENDIF
          ENDIF
        ELSEIF(NREFL.EQ.1) THEN
C
C       Mirror symmetry
C
          IF(IXVAL(ISOP(1),I).EQ.1) THEN
            REP(I)(2:2) = ''''
          ELSEIF(IXVAL(ISOP(1),I).EQ.-1) THEN
            REP(I)(2:2) = '"'
          ENDIF
        ENDIF
C
C       Inversion symmetry
C
        IF(NINVC.EQ.1) THEN
          IND = NROTS+1
          IF(IXVAL(ISOP(IND),I).EQ.1) THEN
            REP(I)(IPOS:IPOS) = 'g'
          ELSE
            REP(I)(IPOS:IPOS) = 'u'
          ENDIF
        ENDIF
  100 CONTINUE
C
C     Output section
C     ==============
C
      IF(IPREAD.GT.0) THEN
        CALL HEADER('SYMGRP:Point group information',-1)
C
C       Group name
C
        IF (CLASS(1:3) .EQ. 'N/A') THEN
           WRITE(LUPRI,'(A,A3)') 'Point group: ',GROUP
           IF (LUCME.GT.0)
     &     WRITE(LUCME,'(A,A3)') 'Point group: ',GROUP
        ELSE
           WRITE(LUPRI,'(A,A)') 'Full group is:  ',CLASS
           WRITE(LUPRI,'(A,A3)') 'Represented as: ',GROUP
           IF (LUCME.GT.0) THEN
              WRITE(LUCME,'(A,A)') 'Full group is:  ',CLASS
              WRITE(LUCME,'(A,A3)') 'Represented as: ',GROUP
           END IF
        END IF
C
C       Group generators
C
        IF(NSYMOP.GT.0) THEN
          WRITE(LUPRI,'(/3X,A/)')
     &        '* The point group was generated by:'
          DO 110 I = 1,NSYMOP
          IF    (SYMOP(IGEN(I))(1:1).EQ.'C') THEN
            WRITE(LUPRI,'(6X,3A)')
     &        'Rotation about the ',SYMOP(IGEN(I))(3:3),'-axis'
          ELSEIF(SYMOP(IGEN(I))(1:1).EQ.'O') THEN
            WRITE(LUPRI,'(6X,3A)')
     &        'Reflection in the ',SYMOP(IGEN(I))(2:3),'-plane'
          ELSE
            WRITE(LUPRI,'(6X,A)')
     &        'Inversion centre'
          ENDIF
  110     CONTINUE
C
C         Group multiplication table
C
          WRITE(LUPRI,'(/3X,A/)') '* Group multiplication table'
          WRITE(LUPRI,'(8X,A1,8(1X,A3,1X))')'|',(SYMOP(ISOP(I)),
     &        I = 0,MAXREP)
          WRITE(LUPRI,'(3X,A6,8A5)') '-----+',('-----',I = 0,MAXREP)
          DO 120 I = 0,MAXREP
            WRITE(LUPRI,'(4X,A3,1X,A1,8(1X,A3,1X))')
     &        SYMOP(ISOP(I)),'|',
     &        (SYMOP(IBTXOR(ISOP(I),ISOP(J))),J = 0,I)
  120     CONTINUE
        ENDIF
C
C       Character table
C
        WRITE(LUPRI,'(/3X,A/)') '* Character table'
        WRITE(LUPRI,'(8X,A1,8(1X,A3,1X))') '|',(SYMOP(ISOP(J)),
     &               J = 0,MAXREP)
        WRITE(LUPRI,'(3X,A6,8A5)') '-----+',('-----',I = 0,MAXREP)
        DO 130 I = 0,MAXREP
          WRITE(LUPRI,'(4X,A3,1X,A1,8(1X,I3,1X))')
     &      REP(I),'|',(IXVAL(ISOP(J),I),J=0,MAXREP)
  130   CONTINUE
C
C       Direct product table
C
        WRITE(LUPRI,'(/3X,A/)') '* Direct product table'
        WRITE(LUPRI,'(8X,A1,8(1X,A3,1X))')'|',(REP(I),I = 0,MAXREP)
        WRITE(LUPRI,'(3X,A6,8A5)') '-----+',('-----',I = 0,MAXREP)
        DO 140 I = 0,MAXREP
          WRITE(LUPRI,'(3X,1X,A3,1X,A1,8(1X,A3,1X))')
     &      REP(I),'|',(REP(IBTXOR(I,J)),J = 0,I)
  140   CONTINUE
      ENDIF
C
      RETURN
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
C  /* Deck dblgrp */
      SUBROUTINE DBLGRP
C*****************************************************************************
C
C     Written by t.saue - october 1994 - odense
C
C     This routine will analyze the fermion irreps in the molecular symmetry
C     and, if possible, set up a transformation within AO - basis to a
C     symmetry-adapted spinor basis. details are given below.
C
C*****************************************************************************
#include <implicit.h>
#include <priunit.h>
      PARAMETER(DM1 = -1.0D0,D1 = 1.0D0)
#include <maxaqn.h>
#include <maxorb.h>
#include <mxcent.h>
C
#include <cbirea.h>
#include <symmet.h>
#include <pgroup.h>
#include <dgroup.h>
C
#include <ibtfun.h>
C
      IXYZ = IBTXOR(ISYMAX(1,1),ISYMAX(1,2))
C
C     KPHASE - reflects the Kramers restricted structure of the
C              unfolded matrix
C     ================================================================
C
C        AR AI BR BI
C     AR  1 -1  1 -1
C     AI  1  1  1  1
C     BR -1 -1  1  1
C     BI  1 -1 -1  1
C
      KPHASE(1,1) =  1
      KPHASE(2,1) =  1
      KPHASE(3,1) = -1
      KPHASE(4,1) =  1
      KPHASE(1,2) = -1
      KPHASE(2,2) =  1
      KPHASE(3,2) = -1
      KPHASE(4,2) = -1
      KPHASE(1,3) =  1
      KPHASE(2,3) =  1
      KPHASE(3,3) =  1
      KPHASE(4,3) = -1
      KPHASE(1,4) = -1
      KPHASE(2,4) =  1
      KPHASE(3,4) =  1
      KPHASE(4,4) =  1
C
C     Determine number of fermion irreps
C     ==================================
C
      NFSYM = 1
      IF(NINVC.EQ.1) NFSYM = 2
C
C     Spinor structure
C     ================
C
      IREP = 0
      DO 10 I = 1,NFSYM
        IF(I.EQ.1) THEN
          JSPINR(1,1,1) = 0
          JSPINR(1,2,1) = IXYZ
        ELSEIF(I.EQ.2) THEN
          JSPINR(1,1,2) = IXYZ
          JSPINR(1,2,2) = 0
        ENDIF
        JBTOF(JSPINR(1,1,I),1) = I
        JBTOF(JSPINR(1,2,I),2) = I
        DO 20 II = 1,3
          IM = 5 - II
          JSPINR(IM,1,I) = IBTXOR(JSPINR(1,1,I),ISYMAX(II,2))
          JSPINR(IM,2,I) = IBTXOR(JSPINR(1,2,I),ISYMAX(II,2))
          JBTOF(JSPINR(IM,1,I),1) = I
          JBTOF(JSPINR(IM,2,I),2) = I
   20   CONTINUE
   10 CONTINUE
C
C     Determine NZ - parameter
C     ========================
C       NZ = 4  quaternionic group  no    totally symmetric rotations
C       NZ = 2  complex group       one   totally symmetric rotation
C       NZ = 1  real group          three totally symmetric rotations
C
      NZ = 1
      DO 30 I = 1,3
        IF(ISYMAX(I,2).EQ.0) THEN
          NZ   = NZ + 1
          ITOT = I
        ENDIF
   30 CONTINUE
C
C     Matrix packing
C     ==============
C
      IF(NZ.EQ.4) THEN
        JAPINT(1) = 4
        JAPINT(2) = 3
        JAPINT(3) = 2
      ELSEIF(NZ.EQ.2) THEN
          JAPINT(ITOT)            = 2
          JAPINT(MOD(ITOT,3)+1) = 2
          JAPINT(MOD((ITOT+1),3)+1) = 1
      ELSE
        JAPINT(1) = 1
        JAPINT(2) = 1
        JAPINT(3) = 1
      ENDIF
C
C     Set up JCSYM for complex and real groups
C     ========================================
C
      IF(NZ.LT.4) THEN
        CALL IZERO(JCSYM,32)
        DO 40 IFR = 1,NFSYM
          JCSYM(JSPINR(1,1,IFR),1,1) = 1
          JCSYM(JSPINR(1,2,IFR),2,1) = 1
          DO 50 II = 1,3
            IM = 5 - II
            JCSYM(JSPINR(IM,1,IFR),1,JAPINT(II)) = IM
            JCSYM(JSPINR(IM,2,IFR),2,JAPINT(II)) = IM
   50     CONTINUE
   40   CONTINUE
      ENDIF
C
C     Output section
C     ==============
C
      IF(IPREAD.GE.1) THEN
        CALL TITLER('Output from DBLGRP','*',103)
        IF    (NFSYM.EQ.1) THEN
          WRITE(LUPRI,'(3X,A)') '* One fermion irrep'
        ELSEIF(NFSYM.EQ.2) THEN
          WRITE(LUPRI,'(3X,A)') '* Two fermion irreps'
        ENDIF
        IF    (NZ.EQ.4) THEN
          WRITE(LUPRI,'(3X,A)') '* Quaternionic group. NZ = 4'
        ELSEIF(NZ.EQ.2) THEN
          WRITE(LUPRI,'(3X,A)') '* Complex group. NZ = 2'
        ELSEIF(NZ.EQ.1) THEN
          WRITE(LUPRI,'(3X,A)') '* Real group. NZ = 1'
        ENDIF
        CALL HEADER('Spinor structure',-1)
        WRITE(LUPRI,'(/2(3X,A,I2,9X)/)')
     &     ('* Fermion irrep no.:',I,I=1,NFSYM)
        WRITE(LUPRI,'(2(6X,A2,2X,A1,2(2X,A3),2X,A1,10X))')
     &     ('La','|',REP(JSPINR(1,1,I)),REP(JSPINR(2,1,I)),'|',
     &      I=1,NFSYM)
        WRITE(LUPRI,'(2(6X,A2,2X,A1,2(2X,A3),2X,A1,10X))')
     &     ('Sa','|',REP(JSPINR(1,2,I)),REP(JSPINR(2,2,I)),'|',
     &      I=1,NFSYM)
        WRITE(LUPRI,'(2(6X,A2,2X,A1,2(2X,A3),2X,A1,10X))')
     &     ('Lb','|',REP(JSPINR(3,1,I)),REP(JSPINR(4,1,I)),'|',
     &      I=1,NFSYM)
        WRITE(LUPRI,'(2(6X,A2,2X,A1,2(2X,A3),2X,A1,10X))')
     &   ('Sb','|',REP(JSPINR(3,2,I)),REP(JSPINR(4,2,I)),'|',
     &    I=1,NFSYM)
        IF(NZ.LT.4) THEN
          CALL HEADER('Matrix packing',-1)
          WRITE(LUPRI,'(3X,I2,2X,A1,A1,A,2X,I2)')
     &         ((5-II),'(',CHAR(ICHAR('W')+II),')  -->',JAPINT(II),
     &          II=1,3)
          CALL HEADER('Transformation matrix',-1)
          WRITE(LUPRI,'(8X,8(A3,2X))') (REP(IRP), IRP = 0,MAXREP)
          WRITE(LUPRI,'(8X,8(A1,1X,A1,2X))') ('L','S',IRP = 0,MAXREP)
          DO 210 JZ = 1,NZ
            WRITE(LUPRI,'(3X,I1,4X,8(I1,1X,I1,2X))')
     &        JZ,((JCSYM(IRP,IC,JZ),IC = 1,2),IRP=0,MAXREP)
  210     CONTINUE
        ENDIF
      ENDIF
      RETURN
C
      END
C  /* Deck zmat */
      SUBROUTINE ZMAT(NONT,KATOM)
C
C  Modified for incorporation in HERMIT/SIRIUS/ABACUS, K.Ruud, May-95
C  Based on program ZMAT from CCQC/ Nov. 1988 (H.J.Aa.Jensen)
C**********************************************************
C*** LAST UPDATED ON SEPTEMBER 11, 1986 BY R. REMINGTON ***
C* REASON: TO OBTAIN HIGHER ACCURACY BY INCREASING THE  ***
C* NUMBER OF DIGITS FOR PI AND CHANGE ATAN TO DATAN #143 **
C**********************************************************
C***LAST UPDATED ON FEBRUARY 01, 1985 BY YUKIO YAMAGUCHI***
C**********************************************************
C   THIS PROGRAM CALCULATES CARTESIAN COORDINATES OF A SYSTEM
C   SPECIFIED BY INTERNAL COORDINATES.
C
#include <implicit.h>
#include <dummy.h>
#include <priunit.h>
#include <mxcent.h>
      PARAMETER (D0 = 0.0D0)
#include <nuclei.h>
#include <molinp.h>
      COMMON/CBZMAT/IZ(MXCENT,4),BL(MXCENT),ALP(MXCENT),BET(MXCENT)
      DIMENSION NONT(KATOM)
C
      NUCIND = NUCIND + 1
      IF (NUCIND .GT. MXCENT) GOTO 5000
      IZ(NUCIND,1) = 0
      IZ(NUCIND,2) = 0
      IZ(NUCIND,3) = 0
      IZ(NUCIND,4) = 0
      BL(NUCIND)=D0
      ALP(NUCIND)=D0
      BET(NUCIND)=D0
      READ (MLINE(NMLINE),'(A4)') NAMN(NUCIND)
C
      IF(NUCIND .EQ. 1) GO TO 200
      IF(NUCIND .EQ. 2) GO TO 201
      IF(NUCIND .EQ. 3) GO TO 202
      GO TO 203
#if defined (SYS_CRAY) || defined (VAR_NOFREE) || defined (SYS_T3D) || defined (SYS_T90)
 200  ISTART = 5
      CALL FREFRM(MLINE(NMLINE),ISTART,INUM,DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,CHARGE(NUCIND),'REA')
      GO TO 204
 201  ISTART = 5
      CALL FREFRM(MLINE(NMLINE),ISTART,INUM,DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IZ(NUCIND,1),DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,BL(NUCIND),'REA')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,CHARGE(NUCIND),'REA')
      GO TO 204
 202  ISTART = 5
      CALL FREFRM(MLINE(NMLINE),ISTART,INUM,DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IZ(NUCIND,1),DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,BL(NUCIND),'REA')
      CALL FREFRM(MLINE(NMLINE),ISTART,IZ(NUCIND,2),DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,ALP(NUCIND),'REA')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,CHARGE(NUCIND),'REA')
      GO TO 204
 203  ISTART = 5
      CALL FREFRM(MLINE(NMLINE),ISTART,INUM,DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IZ(NUCIND,1),DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,BL(NUCIND),'REA')
      CALL FREFRM(MLINE(NMLINE),ISTART,IZ(NUCIND,2),DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,ALP(NUCIND),'REA')
      CALL FREFRM(MLINE(NMLINE),ISTART,IZ(NUCIND,3),DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,BET(NUCIND),'REA')
      CALL FREFRM(MLINE(NMLINE),ISTART,IZ(NUCIND,4),DUMMY,'INT')
      CALL FREFRM(MLINE(NMLINE),ISTART,IDUMMY,CHARGE(NUCIND),'REA')
#else
 200  READ (MLINE(NMLINE)(5:80),*) INUM,CHARGE(NUCIND)
      GO TO 204
 201  READ (MLINE(NMLINE)(5:80),*)
     &     INUM,IZ(NUCIND,1),BL(NUCIND),CHARGE(NUCIND)
      GO TO 204
 202  READ (MLINE(NMLINE)(5:80),*)
     &     INUM,IZ(NUCIND,1),BL(NUCIND),IZ(NUCIND,2),
     &     ALP(NUCIND),CHARGE(NUCIND)
      GO TO 204
 203  READ (MLINE(NMLINE)(5:80),*)
     &     INUM,IZ(NUCIND,1),BL(NUCIND),IZ(NUCIND,2),
     &     ALP(NUCIND),IZ(NUCIND,3),BET(NUCIND),
     &     IZ(NUCIND,4),CHARGE(NUCIND)
#endif
 204  CONTINUE
      NMLINE = NMLINE + 1
      NCLINE(NUCIND) = NMLINE
      NONT(NUCIND) = 1
      NAMEX(3*NUCIND)     = NAMN(NUCIND)//' z'
      NAMEX(3*NUCIND - 1) = NAMN(NUCIND)//' y'
      NAMEX(3*NUCIND - 2) = NAMN(NUCIND)//' x'
C
      RETURN
C
C     Error message:
C
 5000 CONTINUE
        WRITE (LUPRI,'(/A/A,I5)')
     &    ' Too many atomic centers: MXCENT exceed in ZMAT,',
     &    ' Current limit:',MXCENT
        CALL QUIT('*** ERROR *** MXCENT exceeded in ZMAT')
      END
C  /* Deck buildz */
      SUBROUTINE BUILDZ(IPRINT,NONTYP,NSYMOP,NONT,IQM,NBLCK,JCO,NUC,NRC,
     &                  SEG,ALPHA,CPRIM,CPRIMU,KATOM,KANG,KBLOCK,
     &                  KPRIM,KAOVEC,DOOWN,MXSPD)
C
C     Modified for HERMIT/SIRIUS/ABACUS -> K.Ruud, May-95
C
#include <implicit.h>
#include <priunit.h>
#include <mxcent.h>
#include <maxaqn.h>
#include <codata.h>
      PARAMETER (D0 = 0.0D0, D1 = 1.0D0, D2 = 2.0D0)
      PARAMETER (DSM = 1.0D-30)
      PARAMETER (AR=PI/180.0D+00)
      PARAMETER (CORMAX = 1.D5)
      LOGICAL NOORBI , DOOWN
      COMMON/CBZMAT/IZ(MXCENT,4),BL(MXCENT),ALP(MXCENT),BET(MXCENT)
      DIMENSION A(MXCENT),B(MXCENT),CZ(MXCENT,3),D(MXCENT)
      DIMENSION U1(3),U2(3),U3(3),U4(3),VJ(3),VP(3),V3(3)
      DIMENSION NONT(KATOM),IQM(KATOM,2),JCO(KANG,KATOM,2),
     &          NBLCK(KATOM,2),NUC(KBLOCK,2),NRC(KBLOCK,2),
     &          SEG(KBLOCK,2),
     &          ALPHA(KPRIM,KBLOCK,2),CPRIM(KPRIM,KPRIM,KBLOCK,2),
     &          CPRIMU(KPRIM,KPRIM,KBLOCK,2), CHNON(MXCENT)
      CHARACTER SPDCAR*1, NAVNK*4, CRT*1
      DIMENSION IBLOCK(2)
#include <nuclei.h>
#include <gnrinf.h>
#include <ccom.h>
#include <molinp.h>
#include <cbisol.h>
Cjth - these files are included to make Huckel work
#include <maxorb.h>
#include <huckel.h>
    1 FORMAT(/,2X,' INTERNAL COORDINATES'/)
    2 FORMAT(2X,I3,67X,F15.5)
    3 FORMAT(2X,I3,I5,F14.7,48X,F15.5)
    4 FORMAT(2X,I3,I5,F14.7,I5,F14.7,29X,F15.5)
    5 FORMAT(2X,I3,I5,F14.7,I5,F14.7,I5,F14.7,I5,F15.5)
C    6 FORMAT(//,25X,' CARTESIAN COORDINATES in Angstrom',
C     $      /,14X,'X',24X,'Y',24X,'Z'/)
    7 FORMAT(2X,I3,3(F20.10,5X))
    8 FORMAT(//,25X,' CARTESIAN COORDINATES in bohr',
     $      /,14X,'X',24X,'Y',24X,'Z'/)
    9 format(3f20.10)
C
      IF (SOLVNT) NUCIND = NUCIND - 1
      IF (IPRINT .GT. 2) THEN
         WRITE(LUPRI,1)
         WRITE(LUPRI,2) 1,CHARGE(1)
         IF (NUCIND .LE. 1) GOTO 201
         WRITE(LUPRI,3) 2,IZ(2,1),BL(2),CHARGE(2)
         IF(NUCIND.LE.2) GO TO 201
         WRITE(LUPRI,4) 3,IZ(3,1),BL(3),IZ(3,2),ALP(3),
     &                  CHARGE(3)
         IF(NUCIND.LE.3) GO TO 201
         DO 101 I=4,NUCIND
            WRITE(LUPRI,5) I,IZ(I,1),BL(I),IZ(I,2),ALP(I),
     &                     IZ(I,3),BET(I),IZ(I,4),CHARGE(I)
 101     CONTINUE
 201  CONTINUE
      END IF
      DO 102 I = 1,NUCIND
         DO 102 J = 1,3
            CZ(I,J) = D0
 102  CONTINUE
      DO 20 I = 1,NUCIND
         ALP(I) = ALP(I)*AR
         BET(I) = BET(I)*AR
 20   CONTINUE
      CZ(2,3) = BL(2)
      IF ((NUCIND-3) .GE. 0) THEN
         CZ(3,1) = BL(3)*DSIN(ALP(3))
         IF ((IZ(3,1)-1) .EQ. 0) THEN
            CZ(3,3) = BL(3)*DCOS(ALP(3))
         ELSE
            CZ(3,3) = CZ(2,3)-BL(3)*DCOS(ALP(3))
         END IF
         DO 80 I = 4,NUCIND
            IF((ABS(CZ(I-1,1))-1.0D-6) .LT. D0) THEN
               CZ(I,1) = BL(I)*DSIN(ALP(I))
               ITEMP = IZ(I,1)
               JTEMP = IZ(I,2)
               CZ(I,3) = CZ(ITEMP,3) - BL(I)*DCOS(ALP(I))*
     &                   DSIGN(D1,CZ(ITEMP,3) - CZ(JTEMP,3))
            ELSE
               GOTO 90
            END IF
 80      CONTINUE
 90      CONTINUE
         K=I
         IF ((K-NUCIND) .LE. 0) THEN
            DO 250 J = K,NUCIND
               CAJ = DCOS(ALP(J))
               SAJ = DSIN(ALP(J))
               CBJ = DCOS(BET(J))
               SBJ = DSIN(BET(J))
               IF(IZ(J,4) .EQ. 0) THEN
                  CALL VEC(U1,CZ,IZ(J,2),IZ(J,3))
                  CALL VEC(U2,CZ,IZ(J,1),IZ(J,2))
                  CALL VPROD(VP,U1,U2)
                  R = SQRT(D1 - (U1(1)*U2(1) + U1(2)*U2(2)
     &                 + U1(3)*U2(3))**2)
                  DO 120 I = 1,3
                     U3(I) = VP(I)/R
 120              CONTINUE
                  CALL VPROD(U4,U3,U2)
                  DO 130 I = 1,3
                     VJ(I) = BL(J)*(-U2(I)*CAJ + U4(I)*SAJ*CBJ
     &                    + U3(I)*SAJ*SBJ)
                     ITEMP = IZ(J,1)
                     CZ(J,I)=VJ(I)+CZ(ITEMP,I)
 130              CONTINUE
               ELSE
                  IF (IABS(IZ(J,4)) .EQ. 1) THEN
                     CALL VEC(U1,CZ,IZ(J,1),IZ(J,3))
                     CALL VEC(U2,CZ,IZ(J,2),IZ(J,1))
                     ZETA = -(U1(1)*U2(1) + U1(2)*U2(2) +U1(3)*U2(3))
                     A(J) = (-CBJ + ZETA*CAJ)/(D1 - ZETA*ZETA)
                     B(J) = (CAJ - ZETA*CBJ)/(D1 - ZETA*ZETA)
                     R=D0
                     GAMMA=PI/D2
                     IF (ZETA .LT. D0) THEN
                        R=PI
                        GAMMA = DATAN(SQRT(D1-ZETA*ZETA)/ZETA)+R
                     ELSE IF (ZETA .GT. D0) THEN
                        GAMMA = DATAN(SQRT(D1-ZETA*ZETA)/ZETA)+R
                     END IF
                     D(J) = D0
                     IF ((ABS(GAMMA+ALP(J)+BET(J)-D2*PI)-1.0D-6)
     &                    .GE. D0) THEN
                        D(J) = IZ(J,4)*(SQRT(D1+A(J)*CBJ-B(J)*CAJ))
     &                       /SQRT(D1-ZETA*ZETA)
                     END IF
                     CALL VPROD(V3,U1,U2)
                     DO 200 I = 1,3
                        U3(I) = A(J)*U1(I)+B(J)*U2(I)+D(J)*V3(I)
                        VJ(I)=BL(J)*U3(I)
                        ITEMP=IZ(J,1)
                        CZ(J,I)=VJ(I)+CZ(ITEMP,I)
 200                 CONTINUE
                  ELSE
                     CALL VEC(U1,CZ,IZ(J,1),IZ(J,3))
                     CALL VEC(U2,CZ,IZ(J,2),IZ(J,1))
                     ZETA = -(U1(1)*U2(1)+U1(2)*U2(2)+U1(3)*U2(3))
                     CALL VPROD(V3,U1,U2)
                     V3MAG = SQRT(V3(1)*V3(1)+V3(2)*V3(2)
     &                    + V3(3)*V3(3))
                     A(J) = V3MAG*CBJ/(D1-ZETA*ZETA)
                     B(J) = SQRT((D1-CAJ*CAJ-A(J)*CBJ*V3MAG)
     &                    /(D1-ZETA*ZETA))
                     IF((IZ(J,4)-2) .NE. 0) THEN
                        B(J)=-B(J)
                     END IF
                     D(J) = B(J)*ZETA+CAJ
                     DO 240 I = 1,3
                        U3(I) = B(J)*U1(I)+D(J)*U2(I)+A(J)*V3(I)
                        VJ(I) = BL(J)*U3(I)
                        ITEMP = IZ(J,1)
                        CZ(J,I) = VJ(I)+CZ(ITEMP,I)
 240                 CONTINUE
                  END IF
               END IF
 250        CONTINUE
         END IF
      END IF
C
C   ELIMINATE IMAGINARY ATOM(S)
C   Hmmm, what do we do here? Remove them or keep them as dummy atoms?
C   Check to see if there is a basis set associated with the center?
C   Is it at all possible to place a dummy atom on top of an already
C   existing center in internal coordinates? K.Ruud, May-95
C
C      NATOMS=0
C      DO 290 I=1,NUCIND
C         IF(ANZ(I) .NE. D0) THEN
C            NATOMS=NATOMS+1
C            CHRG(NATOMS) = DFLOAT( ANZ(I) )
C            DO 280 J=1,3
C               C(NATOMS,J)=CZ(I,J)
C 280        CONTINUE
C         END IF
C 290  CONTINUE
C
C
      IF (IPRINT .GT. 2) THEN
         WRITE(LUPRI,8)
         DO 305 I=1,NUCIND
            WRITE(LUPRI,7) I,(CZ(I,J)/XTANG,J=1,3)
 305     CONTINUE
      END IF
C
C     Move information to HERMIT common blocks
C
      DO 410 I=1,NUCIND
         DO 420 J = 1, 3
            CORD(J,I) = CZ(I,J)/XTANG
            IF (ABS(CORD(J,I)).GT. CORMAX) GOTO 5010
 420     CONTINUE
 410  CONTINUE
C
C     Update MOLECULE.INP. In order to work properly with the symmetry
C     detection routines we need to sort atoms with similar charge
C     together in a block.
C
      ITYP = 1
      DO 600 I = 1, NUCIND
         DO 601 J = 1, I - 1
            IF (CHARGE(I) .EQ. CHARGE(J)) THEN
               NONTYP = NONTYP - 1
               DO 603 L = 1, ITYP
                  IF (CHARGE(I) .EQ. CHNON(L))
     &                   NONT(L) = NONT(L) + 1
 603           CONTINUE
               CHARGK = CHARGE(I)
               XCORD  = CORD(1,I)
               YCORD  = CORD(2,I)
               ZCORD  = CORD(3,I)
               NAVNK  = NAMN(I)
               DO 602 K = I - 1, J + 1, -1
                  CHARGE(K + 1) = CHARGE(K)
                  CORD(1,K + 1) = CORD(1,K)
                  CORD(2,K + 1) = CORD(2,K)
                  CORD(3,K + 1) = CORD(3,K)
                  NAMN(K + 1)   = NAMN(K)
 602           CONTINUE
               CHARGE(J + 1) = CHARGK
               CORD(1,J + 1) = XCORD
               CORD(2,J + 1) = YCORD
               CORD(3,J + 1) = ZCORD
               NAMN(J + 1)   = NAVNK
               GOTO 600
            END IF
 601     CONTINUE
         NONT(ITYP) = 1
         CHNON(ITYP) = CHARGE(I)
         ITYP = ITYP + 1
 600  CONTINUE
      IF (DOCART) THEN
         CRT = 'C'
      ELSE IF (DOOWN) THEN
         CRT = 'X'
      ELSE
         CRT = ' '
      END IF
      WRITE(MLINE(5),'(A1,I4,I3,I2,10X,D10.2)') CRT,NONTYP,KCHARG,
     &                                          NSYMOP,THRS
      NMLINE = 6
      NHTYP = 0
      IBLOCK(1) = 1
      IBLOCK(2) = 1
      IATOM = 1
      NSETS = 1
      IF (ADDSTO) NSETS = 2
      DO 605 I = 1, NONTYP
         NOORBI  = .TRUE.
         WRITE(MLINE(NMLINE),'(6X,F4.0,I5)') CHARGE(IATOM),NONT(I)
         NMLINE = NMLINE + 1
         DO 606 J = 1, NONT(I)
            NCLINE(IATOM) = NMLINE
            WRITE(MLINE(NMLINE)(1:4),'(A4)') NAMN(IATOM)
            WRITE(MLINE(NMLINE)(5:24),'(F20.16)')  CORD(1,IATOM)
            WRITE(MLINE(NMLINE)(25:44),'(F20.16)') CORD(2,IATOM)
            WRITE(MLINE(NMLINE)(45:64),'(F20.16)') CORD(3,IATOM)
            WRITE(MLINE(NMLINE)(65:80),'(A16)') '                '
            NMLINE = NMLINE + 1
            IATOM = IATOM + 1
 606     CONTINUE
C
C     Add basis set to newly order atomic set
C
         DO J = 1,NSETS
            CALL BASLIB(IQM(I,J),JCO(1,I,J),NUC(IBLOCK(J),J),
     &                  NRC(IBLOCK(J),J),SEG(IBLOCK(J),J),
     &                  ALPHA(1,IBLOCK(J),J),
     &                  CPRIM(1,1,IBLOCK(J),J),CPRIMU(1,1,IBLOCK(J),J),
     &                  NBLOCK,KAOVEC,KPRIM,CHARGE(IATOM - 1),J,DSM)
            NBLCK(I,J) = NBLOCK
            IBLOCK(J) = IBLOCK(J) + NBLCK(I,J)
            NOORBI  = NOORBI  .AND. IQM(I,J).EQ.0
            IF (IQM(I,1) .GT. 0) THEN
               NHTYP = MAX(NHTYP,IQM(I,J))
               IF (NHTYP .GT. MXSPD) GOTO 5000
            END IF
         END DO
         DO 610 K = 1,NONT(I)
            NOORBT(K + IATOM - 2) = NOORBI
 610     CONTINUE
 605  CONTINUE
      NMLINE = NMLINE - 1
      IF (SOLVNT) NUCIND = NUCIND + 1
      RETURN
 5000 CONTINUE
         WRITE (LUPRI,'(6X,A,I3,3A/9X,2A)')
     &      '*  Input specifies highest orbital of atomic type ',
     &      I,' AS "',SPDCAR(NHTYP - 1),'".',
     &      ' Highest allowed orbital in this version: ',
     &      SPDCAR(MXSPD - 1)
         IF (NHTYP.GT.MXQN) WRITE (LUPRI,'(9X,2(A,I3),A)')
     &      ' Increase MXQN from',MXQN,' to',NHTYP,' and recompile.'
         CALL QUIT('Too high angular quantum no. specified in input.')
 5010 CONTINUE
        WRITE (LUPRI,'(A,E12.6,A/A/A,E12.6)')
     &    ' Atomic coordinate ',CORD(J,NUCIND),
     &    ' too large in BUILDZ',
     &    ' Note: Program is unstable for large coordinates.',
     &    ' Maximum coordinate value:',CORMAX
        CALL QUIT('*** ERROR: Atomic coordinate too large in BUILDZ')
      END
C  /* Deck vec */
      SUBROUTINE VEC(U,C,J,K)
#include <implicit.h>
#include <mxcent.h>
      PARAMETER (D0 = 0.0D0)
      DIMENSION C(MXCENT,3),R(3),U(3)
C
      R2=D0
      DO 101 I=1,3
         R(I)=C(J,I)-C(K,I)
         R2=R2+R(I)*R(I)
 101  CONTINUE
      R2=SQRT(R2)
      DO 102 I=1,3
         U(I)=R(I)/R2
  102 CONTINUE
      RETURN
      END
C  /* Deck vprod */
      SUBROUTINE VPROD(VP,X,Y)
#include <implicit.h>
      DIMENSION VP(3),X(3),Y(3)
C
      VP(1)=X(2)*Y(3)-X(3)*Y(2)
      VP(2)=X(3)*Y(1)-X(1)*Y(3)
      VP(3)=X(1)*Y(2)-X(2)*Y(1)
      RETURN
      END
C/*  Deck frefrm */
      SUBROUTINE FREFRM(STRING,ISTART,IVAL,RVAL,TYPE)
C
C     Simulate free format input for Cray computers when reading from an
C     internal file, K.Ruud-Feb.97
C
#include <implicit.h>
#include <priunit.h>
C      
      CHARACTER*80 STRING
      CHARACTER TYPE*3, FRMT*7
C
      IF (TYPE .EQ. 'INT') THEN
         IVAL = 0
      ELSE
         RVAL = 0.0D0
      END IF
      DO 10 IPOS = ISTART, 80
         IF (STRING(IPOS:IPOS) .NE. ' ') GO TO 20
 10   CONTINUE
C
 20   CONTINUE
      IEND = INDEX(STRING(IPOS:),' ')
      ILEN = IEND - ISTART - 1 + IPOS
      IF (TYPE .EQ. 'INT') THEN
         IF (ILEN .GT. 9) THEN
            WRITE (FRMT,'(2X,A2,I2,A1)') '(I',ILEN,')'
         ELSE
            WRITE (FRMT,'(3X,A2,I1,A1)') '(I',ILEN,')'
         END IF
         READ (STRING(ISTART:80),FRMT) IVAL
      ELSE IF (TYPE .EQ. 'REA') THEN
         IF (ILEN .GT. 9) THEN
            WRITE (FRMT,'(A2,I2,A3)') '(F',ILEN,'.0)'
         ELSE
            WRITE (FRMT,'(1X,A2,I1,A3)') '(F',ILEN,'.0)'
         END IF
         READ (STRING(ISTART:80),FRMT) RVAL
      ELSE
         WRITE (LUPRI,'(/,A)') 'Illegal variable type in FREFRM'
         CALL QUIT('Illegal variable type in FREFRM')
      END IF
      ISTART = IEND + IPOS
      RETURN
      END
C  /* Deck molout */
      SUBROUTINE MOLOUT(NONTYP,NONT,IQM,NBLCK,JCO,NUC,NRC,SEG,
     &     IPCON,KATOM,KANG,KBLOCK,KPRIM,CPRIMU,NRMPRI,KASYM,
     &     NSYMOP)
C
C     This routine based on TECORBOUT dumps a MOLECULE.INP file suitable
C     for direct processing by DALTON
C     Now also dumps a file MNF.INP for use for SO mean-field approximation
C     Written by K.Ruud 160297 
C
#include <implicit.h>
#include <priunit.h>
#include <pi.h>
#include <mxcent.h>
#include <maxorb.h>
#include <aovec.h>
#include <maxaqn.h>
      PARAMETER (D0 = 0.0D0)
C    
#include <ccom.h>
#include <cbirea.h>
#include <nuclei.h>
#include <primit.h>
#include <gnrinf.h>
#include <molinp.h>
      LOGICAL SEG, NRMPRI
      CHARACTER KASYM(3,3)*1, CRT*1
      DIMENSION NONT(KATOM),IQM(KATOM),NBLCK(KATOM),
     &     JCO(KANG,KATOM),NUC(KBLOCK),NRC(KBLOCK),
     &     CPRIMU(KPRIM,KPRIM,KBLOCK),SEG(KBLOCK)
      DIMENSION IPCON(KPRIM)
      CHARACTER*8 LTIME, LDATE
      CHARACTER*1 SPD(8)
      DATA SPD/'S','P','D','F','G','H','I','J'/
C
      LUTMP1 = 0
      LUTMP2 = 0
      LUSHB  = 0
      CALL GPOPEN(LUTMP1, 'DALTON.BAS',' ',' ','FORMATTED',IDUMMY,
     &            .FALSE.)
      CALL GPOPEN(LUTMP2,'MNF.INP',' ',' ','FORMATTED',IDUMMY,.FALSE.)
      CALL GPOPEN(LUSHB,'LUSH.BAS',' ',' ','FORMATTED',IDUMMY,.FALSE.)
      REWIND (LUSHB)
C    
      IPRIMD = 0
      IPRIM =  0
      ICENT  = 0
      IBLOCK = 0
C hj-aug99: find title lines, first skip initial comments
      ILINE = 1
   10 IF((MLINE(ILINE)(1:1).EQ.'#') .OR. (MLINE(ILINE)(1:1).EQ.'!'))THEN
         ILINE = ILINE + 1
         GO TO 10
      END IF
Chj:  ILINE must now point to line with first effective line (CARD 1)
      CALL GETDAT(LDATE,LTIME)
      WRITE (LUTMP1,'(2A,1X,A/A/2A)')
     &   '# DALTON.BAS with INTGRL directive created ',LDATE,LTIME,
     &   '# Directive in input mol file was:',
     &   '# > ',MLINE(ILINE)(1:76)
      IF (BASIS) THEN
         WRITE (LUTMP1,'(2A)')
     &   '# > ',MLINE(ILINE+1)(1:76)
         ILINE = ILINE + 2
      ELSE
         ILINE = ILINE + 1
      END IF
Chj:  skip any additional comment lines before title lines
   20 IF((MLINE(ILINE)(1:1).EQ.'#') .OR. (MLINE(ILINE)(1:1).EQ.'!'))THEN
         ILINE = ILINE + 1
         GO TO 20
      END IF
      CRT = ' '
      IF (DOCART) CRT = 'C'
      WRITE (LUTMP1,'(A/A/A)')
     &   'INTGRL',MLINE(ILINE),MLINE(ILINE + 1)
      ILINE = ILINE + 2
      WRITE (LUTMP1,'(A1,I4,I3,I2,9A1,1X,D10.2)')
     &     CRT,NONTYP,KCHARG,NSYMOP,((KASYM(I,J),I=1,3),J=1,3),THRS
      ISYCNT = 1
      WRITE(LUSHB,'(A/A)')'$BASIS',MLINE(2)
      DO 100 I = 1, NONTYP
         WRITE (LUTMP1,'(6X,F4.0,24(I5))') CHARGE(ICENT+1),NONT(I),
     &                             IQM(I),(JCO(J,I), J=1, IQM(I))
         DO N = 1, NONT(I)
            WRITE (LUTMP1,'(A4,3F20.13)') NAMN(ISYCNT),
     &           (CORD(J,ISYCNT), J = 1,3)
            WRITE(LUSHB,'(/F16.1,F19.10,2F20.10)')
     &         CHARGE(ICENT+1),(CORD(J,ISYCNT),J=1,3)
            ISYCNT = ISYCNT + 1
         END DO
         MNCENT = ICENT + 1
         DO 110 N = 1, NONT(I)
            ICENT = ICENT + 1
            NDEG  = NUCDEG(ICENT)
            KBCH  = IBLOCK
            WRITE (LUTMP2,*) CHARGE(MNCENT),IQM(I)-1
            II = 0
            DO 200 J = 1, IQM(I)
               DO 210 K = 1, JCO(J,I)
                  KBCH = KBCH + 1
                  NNUC  = NUC(KBCH)
                  NNRC  = NRC(KBCH)
                  IF (NNUC .EQ. 0) GO TO 200
                  WRITE (LUTMP2,*) NNUC,NNRC
                  ITYP = NHKOFF(J)
                  IPSTRT = IPRIM + 1
                  IPRIM =  IPRIM + NNUC
                  ITYP = ITYP + 1
                  IPRIMD = IPRIMD + 1
                     IF (N.EQ.1) THEN
                     WRITE (LUTMP1,'(A1,I4,I5)') 'H', NNUC, NNRC
                     ENDIF
                     DO 410 M = 1, NNUC
                        IPRIMD = IPRIMD + 1
                        IF (NNRC.LE.3) THEN
                        IF (N.EQ.1) THEN
                           WRITE (LUTMP1,1050) PRIEXP(IPSTRT-1+M),
     &                          (CPRIMU(M,MM,KBCH),MM=1,NNRC)
                        ENDIF
                           WRITE (LUTMP2,1050) PRIEXP(IPSTRT-1+M),
     &                          (CPRIMU(M,MM,KBCH),MM=1,NNRC)
                        ELSE
                        IF (N.EQ.1) THEN
                           WRITE (LUTMP1,1050) PRIEXP(IPSTRT - 1 + M),
     &                          (CPRIMU(M,MM,KBCH),MM = 1,3)
                        ENDIF
                           WRITE (LUTMP2,1050) PRIEXP(IPSTRT - 1 + M),
     &                          (CPRIMU(M,MM,KBCH),MM = 1,3)
                           DO NLOOP = 1, INT(NNRC/3) - 1
                           IF (N.EQ.1) THEN
                              WRITE (LUTMP1,1040) (CPRIMU(M,MM,KBCH),
     &                             MM = NLOOP*3 + 1, (NLOOP + 1)*3)
                           ENDIF
                              WRITE (LUTMP2,1040) (CPRIMU(M,MM,KBCH),
     &                             MM = NLOOP*3 + 1, (NLOOP + 1)*3)
                           END DO
                           IF (MOD(NNRC,3) .NE. 0) THEN
                           IF (N.EQ.1) THEN
                              WRITE (LUTMP1,1040) (CPRIMU(M,MM,KBCH),
     &                             MM = NNRC - MOD(NNRC,3) + 1, NNRC)
                           ENDIF
                              WRITE (LUTMP2,1040) (CPRIMU(M,MM,KBCH),
     &                             MM = NNRC - MOD(NNRC,3) + 1, NNRC)
                           END IF
                        ENDIF
 410                 CONTINUE
                  DO MM=1,NNRC
                     II=II+1
                     WRITE(LUSHB,'(I5,A5,I5)')II, SPD(J), NNUC
                     DO M=1,NNUC
                        WRITE(LUSHB,'(I5,D15.9,D20.10)')
     &                     M,PRIEXP(IPSTRT+M-1),CPRIMU(M,MM,KBCH)
                     END DO
                  END DO
 210           CONTINUE
 200        CONTINUE
 110     CONTINUE
         IBLOCK = IBLOCK + NBLCK(I)
 100  CONTINUE
C
      WRITE (LUTMP2,'(A)') 'END'
      CALL GPCLOSE(LUTMP1,'KEEP')
      CALL GPCLOSE(LUTMP2,'KEEP')
      CALL GPCLOSE(LUSHB ,'KEEP')
 1010 FORMAT(/2X,A4,3X,A4,3X,A10)
 1040 FORMAT(20X,3F20.10)
 1050 FORMAT(F20.10,3F20.10)
      RETURN
      END
C  /* Deck crtest */
      SUBROUTINE CRTEST(DOCART)
#include <implicit.h>
#include <priunit.h>
      LOGICAL DOCART
#include <cbieri.h>
C
      IF (RUNERI.AND.DOCART) THEN
         RUNERI = .FALSE.
         WRITE (LUPRI,'(1X,2A)')
     &   ' WARNING: Only spherical-harmonic basis implemented in ERI.',
     &   ' TWOINT is used instead.'
      END IF
      RETURN
      END
C  /* Deck isomas */
      FUNCTION ISOMAS(ICHARG,MASSNM)
C
C     Function to switch from mass number to isotope number sorted
C     according to abundance, K.Ruud-02
C
#include <implicit.h>
#include <priunit.h>
C
      CALL QENTER('ISOMAS')
      IORD = 0
      DO I = 1, 5
         QMASS = DISOTP(ICHARG,I,'MASS')
         IF (ANINT(QMASS) .EQ. MASSNM) IORD = I
      END DO
      IF (IORD .EQ. 0) THEN
         WRITE (LUPRI,'(/A,I3)') 'Unknown mass for atom with charge ',
     &        ICHARG
         CALL QUIT('Unknown mass for chosen atomic charge')
      ELSE
         ISOMAS = IORD
      END IF
      CALL QEXIT('ISOMAS')
      RETURN
      END
C  /* Deck stcmom */
      SUBROUTINE STCMOM
C
C     Enforce computation of Cartesian second moments.
C     Written by Wim Klopper (University of Karlsruhe, 31 October 2002).
C
#include <implicit.h>
#include <mxcent.h>
#include <cbiher.h>
      CARMOM = .TRUE.
      ONEPRP = .TRUE.
      IORCAR = MAX(2,IORCAR)
      RETURN
      END
C  /* Deck basmul */
      SUBROUTINE BASMUL(A,BASNAM,IPREAD)
C
C     Read basis set labels from input line.
C     Written by Wim Klopper (University of Karlsruhe, 31 October 2002).
C
#include <implicit.h>
#include <priunit.h>
#include <r12int.h>
      CHARACTER*80 A,BASNAM
      LOGICAL NEXTMB
      DO 20 I=1,80
       BASNAM(I:I) = ' '
       DO 20 J=1,MXMULB
        MULNAM(J)(I:I) = ' '
   20  CONTINUE
      N = 0
      NEXTMB = .FALSE.
      DO 10 I=1,80
       IF (A(I:I) .NE. ' ' .AND. .NOT. NEXTMB) THEN
        NEXTMB = .TRUE.
        K = I
       ELSE IF (A(I:I) .EQ. ' ' .AND. NEXTMB) THEN
        L = I - 1
        NEXTMB = .FALSE.
        N = N + 1
        IF (N .GT. MXMULB) CALL QUIT('Too many basis sets')
        MULNAM(N)(1:I-K) = A(K:L)
        IF (N .EQ. 1) BASNAM(1:I-K) = A(K:L)
        IF (IPREAD .GT. 1) THEN
          WRITE (LUPRI,'(/A)') ' Basis set "'//
     &    MULNAM(N)(1:I-K)//'" from the basis set library will be used.'
        END IF
       END IF
   10 CONTINUE
      LMULBS = LMULBS .OR. (N .GT. 1)
      NMULBS = N
      RETURN
      END
