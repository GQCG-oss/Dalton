#!/bin/sh
#########################################################################
#
# Shell script for running DALTON test suite
#
# by Christof Haettig and Kasper Hald, Sep. 2000
#
#########################################################################

#########################################################################
# define all the different test suites
#########################################################################
ESSENTIAL=""
#
SHORTNOCC="energy_direct energy_douglaskroll energy_nosymm energy_restart \
energy_symm geoopt_cartsad geoopt_cartsad2 geoopt_constrain1a \
geoopt_constrain1b geoopt_delintsad geoopt_exci2 geoopt_numgrd \
geoopt_preopt geoopt_prop geoopt_prop2 geoopt_redintmin geoopt_vrml \
prop_ecd prop_or prop_exci prop_nolondon prop_spinspin prop_spinspin2 \
prop_spinspin3 prop_spinspin4 prop_vibvcd rsp_2ndharm rsp_3rdharm \
rsp_3rdmom rsp_dresqr rsp_ecp rsp_exci rsp_excipolar2 rsp_hyperpolar \
rsp_lrso rsp_lrso2 rsp_mcdbterm rsp_mnf rsp_phosph rsp_polar rsp_propave \
rsp_socorr rsp_solvhyper rsp_soppa1excinosymm rsp_soppa1excisymm \
rsp_soppa3excinosymm rsp_soppa3excisymm rsp_soppafcnosymm rsp_soppafcsymm \
rsp_soppapolar rsp_soppapolarnosymm rsp_soppapolarsymm rsp_sreslrso \
rsp_sresqr walk_gradex walk_image walk_modeflw walk_polar walk_vibave \
walk_vibave2 energy_zmat r12_sym dpt_h2s prop_ctocd prop_soppactocd \
rsp_ctocdhyper prop_spinspin5 prop_nolondon_soppacc rsp_soppaccexci \
rsp_soppaccpolar prop_newtrasoppa prop_newtrasoppacc prop_newtramcscf \
dft_qr_sym energy_hsrohf energy_hsrohf_qc"

#
SHORTCC="cc_rsp_alpha2 cc_rsp_beta cc_rsp_beta2 cc_rsp_betafreq \
cc_rsp_betafreq2 cc_fop_drw2e cc_fop_prop cc_fop_prop2 cc_exgr_prop \
cc_rsp_excipolar cc_rsp_exci cc_energy_field cc_fop_prop3 cc_fop_prop4 \
cc_fop_freeze cc_rsp_gamma cc_rsp_gammafreq cc_rsp_gammafreq2 \
cc_rsp_mcdbterm cc_rsp_threephot cc_energy_triples cc_energy_triplesdirect \
cc_energy_triplesdirect2 cc_energy_triplesdirect3 cc_energy_triplet2 \
cc_rsp_twophot cc_rsp_twophot2 \
cc_rsp_twophot5 cc_rsp_twophotb cc_grad cc_geoopt_mp2 cc_fop_cc3 cc_rsp_ctocd \
cc_grad_ccpt_hf cc_geopt_ccpt_hf cc_geopt_ccpt_h2o"
#
SHORT="$SHORTNOCC $SHORTCC"
#
MEDIUM="energy_corehole energy_solv geoopt_cartmin geoopt_dckerr \
geoopt_delintmin geoopt_exci geoopt_mp2froz geoopt_redintsad \
geoopt_symbrk prop_expgrad prop_nucquad prop_roa rsp_dckerr rsp_esr \
rsp_esr2 rsp_mnfphosph rsp_solvesr walk_polar2"
#
MEDIUMCC="cc_rsp_alpha cc_rsp_gamma2 cc_rsp_gammadirect cc_rsp_oddisp \
cc_energy_triplet cc_rsp_twophotdirect cc_grad2 cc_grad3 cc_geoopt \
cc_rsp_solv cc_energy_triplet3"
#
MEDIUM="$MEDIUM $MEDIUMCC"
#
LONG="geoopt_prop3 prop_vibana rsp_excipolar rsp_twophot walk_solvmag"
#
LONGCC="cc_geoopt2"
#
LONG="$LONG $LONGCC"
#
PARALLEL="energy_parallel geoopt_parallel prop_parallel rsp_parallel"
#
DFT="dft_b3lyp_cart dft_b3lyp_nosym dft_b3lyp_sym dft_blyp_nosym \
dft_blyp_sym dft_energy_sym dft_lda_cart dft_lda_nosym dft_lda_sym \
dft_optimize_nosym dft_optimize_sym dft_lb94 dft_qr_sym dft_qr_nosym \
dft_lda_molhes_nosym dft_b3lyp_molhes_nosym"
#
DPT="dpt_hf dpt_h2s dpt_h2s_finp dpt_hbr_finm dpt_h2s_finm \
dpt_hbr dpt_hbr_finp dpt_h2s_ff"
#
R12="r12_damped r12_damped_herdir \
r12_sym r12_nosym r12_fc_sym r12_fc_nosym \
r12_aux_sym r12_aux_nosym r12_fc_aux_sym r12_fc_aux_nosym"
#
NUMDER="hfreqfromE hfreqfromg effgeom_fromE effgeom_fromE2 vibave_spinspin"
#
ALL="$SHORT $MEDIUM $LONG $DFT $NUMDER $R12 $DPT"
#
ALLCC="$SHORTCC $MEDIUMCC $LONGCC"
#
BENCHMARK="benchmark_eri_r12 benchmark_eri_r12xl \
benchmark_eri_adzs benchmark_her_adzs benchmark_eri_adz benchmark_her_adz"
#
#########################################################################
# function usage(): print usage information 
#########################################################################
usage() {
 cat <<'%EOF%'
usage: TEST [-h|-help|--help] [-keep] [-reftest] [-bell] [-benchmark]
            [-param "option list"] [-dalton script] [-log logfile] testcase

       -h | -help | --help  : show this help description
       -keep                : keep *.mol, *.dal, *.check and *.log files
       -reftest             : test reference file(s); do not run any
                              calculations
       -bell                : sound bell each time a test fails
       -benchmark           : print CPU time for each testcase as part of
                              the summary
       -param "option list" : pass "option list" to dalton-script
       -dalton script       : use script instead of the default
                              dalton-script "../dalton"
       -log logfile         : write output into logfile instead of the
                              default "TESTLOG"

       where testcase might be one of the following:
          essential            -- run a minimal set of essential testcases
          parallel             -- run all parallel testcases
          allcc                -- run all coupled-cluster testcases
          short                -- run all short testcases
          medium               -- run all medium length testcases
          long                 -- run all long testcases
          dft                  -- run all DFT testcases
          r12                  -- run all R12 testcases
          benchmark            -- run all BENCHMARK testcases
          dpt                  -- run all DPT testcases
          numder               -- run all numerical derivatives testcases
          all                  -- run all non-parallel testcases
                                  (= short + medium + long)
          <case1 [case2] ...>  -- run only the specified testcase(s)
%EOF%
exit 1
}

#########################################################################
# function myprint(string): print to stdout and $listing
#########################################################################
myprint(){
 echo "$1";
 echo "$1" >> $listing;
}

#########################################################################
#########################################################################
# start with real work:
#########################################################################
#########################################################################

#########################################################################
# set defaults and evaluate parameters
#########################################################################
TESTparams="$0 $*"
help=""
keep="false"
DALTON="../dalton"
paramlist=""
reftest=""
bell=""
benchmark=""
listing="TESTLOG"
emptystring="                                "

if [ `uname` = Linux ]; then
   GREP="egrep -a"
else
   GREP="egrep"
fi

while [ -n "`echo $1 | grep '-'`" ]; do
   case $1 in
     "-h" | "-help" | "--help" ) help="true" ; break;;
     "-dalton" )  shift; DALTON=$1; shift;;
     "-log" ) shift; listing=$1; shift;;
     "-keep" ) keep="true"; shift;;
     -param* ) shift; paramlist="$1"; shift;;
     "-reftest" ) reftest="true"; shift;;
     "-bell" ) bell="true"; shift;;
     "-benchmark" ) benchmark="true"; shift;;
     * ) usage;;
   esac
done
if [ $help ]; then
  usage
fi

#########################################################################
# set list of test cases:
#########################################################################
testcase=$*
if   [ "$testcase" = "" ]; then
  echo '    ***********************************'
  echo '    * ERROR: No testcase(s) specified *'
  echo '    ***********************************'
  usage
elif [ "$testcase" = "essential" ]; then
  testcase=$ESSENTIAL
elif [ "$testcase" = "short_nocc" ]; then
  testcase=$SHORTNOCC
elif [ "$testcase" = "shortcc" ]; then
  testcase=$SHORTCC
elif [ "$testcase" = "short" ]; then
  testcase=$SHORT
elif [ "$testcase" = "medium" ]; then
  testcase=$MEDIUM
elif [ "$testcase" = "long" ]; then
  testcase=$LONG
elif [ "$testcase" = "parallel" ]; then
  testcase=$PARALLEL
  if [ "$paramlist" = "" ]; then
    paramlist="-N 3"
  fi
elif [ "$testcase" = "all" ]; then
  testcase=$ALL
elif [ "$testcase" = "allcc" ]; then
  testcase=$ALLCC
elif [ "$testcase" = "dft" ]; then
  testcase=$DFT
elif [ "$testcase" = "dpt" ]; then
  testcase=$DPT
elif [ "$testcase" = "r12" ]; then
  testcase=$R12
elif [ "$testcase" = "benchmark" ]; then
  testcase=$BENCHMARK
elif [ "$testcase" = "numder" ]; then
  testcase=$NUMDER
fi



#########################################################################
# check file for test listing:
#########################################################################
if [  -s $listing ]; then
   echo "$listing already exists... should it be deleted first? (y/n)"
   read answer
   if [ "$answer" = "yes"  -o  "$answer" = "y" ]; then
     echo > $listing
   fi
fi

myprint "#####################################################################"
myprint "                          DALTON test suite"
myprint "#####################################################################"
myprint "invoked with          : $TESTparams"
myprint "date and time         : `date`"
myprint "dalton script         : $DALTON"
myprint "parameter list passed : $paramlist"
myprint "test listing          : $listing"
myprint "test cases            : $testcase"

#########################################################################
# loop over test cases:
#########################################################################
passedall="ALL TESTS ENDED PROPERLY!"
problems=""
numresult=0
for item in ${testcase}
do
  trouble=0
  myprint "###########################################################"
  myprint "start now with test $item:"
  myprint "-----------------------------------------------------------"
  chmod +x ./$item
  ./$item
  if [ -f $item.info ]; then
    cat $item.info | tee -a $listing
  fi
# Check if this is a multistep job
  numsteps=1
  if [ -r ./$item'__'1.dal ]; then
      multi=1
      numsteps=`ls ./$item\_\_[0-9].dal | wc -l`
      myprint "   This is a multi-step job consisting of $numsteps steps"
      rm -f ./$item'__'[0-9]'_'$item.log
      chmod +x ./$item'__'[0-9].check
  else
      multi=0
      rm -f ./$item.log
      chmod +x ./$item.check
  fi
# Multi-step tests loop over the different jobsteps, regular tests just
# go through this once
  step=1
  while [ "$step" -le "$numsteps" ]
  do
      if [ "$multi" -eq 1 ]; then
          if [ "$step" -gt 1 ]; then
              myprint ""
              myprint "start $item step $step:"
              myprint "-----------------------------------------------------------"
          fi
          molfile=$item
          dalfile=$item'__'$step
          logfile=./$item'__'$step'_'$item.log
          checkfile=./$item'__'$step.check
          reffile=./$item'__'$step.ref
          moldenfile=./$item'__'$step'_'$item.molden
      else
          molfile=$item
          dalfile=$item
          logfile=./$item.log
          checkfile=./$item.check
          reffile=./$item.ref
          moldenfile=./$item.molden
      fi
# If it's a reftest, no calculation is performed
      if [ "$reftest" = "true" ]; then
          myprint ""
          myprint "evaluate reference output file $reffile:"
          myprint "-----------------------------------------------------------"
          compressed="false"
          if [ ! -r $reffile ]; then
              if [ -r $reffile.gz ]; then
                  compressed="true"
                  gunzip -f $reffile.gz
              fi
          fi
          checkout=`$checkfile $reffile | tee -a $listing`
          if [ "$benchmark" = "true" ]; then
              if [ `$GREP "CPU  time used in DALTON" $reffile | wc -l` = 1 ]; then
                  CPU_usage=`$GREP "CPU  time used in DALTON" $reffile | sed s/">>>> Total CPU  time used in DALTON\:"/""/`
              else
                  CPU_usage="N/A"
              fi
          fi
          if [ "$compressed" = "true" ]; then
              gzip -f --best $reffile
          fi
      else
          if [ "$step" -eq "$numsteps" ]; then
              $DALTON $paramlist -ext log $dalfile $molfile | \
              grep -v '\*\*\**' | \
              grep -v 'OUTPUT FROM' | grep -v 'Version' | grep -v 'PID' | \
              grep -v '^$' | tee -a $listing
          else
              $DALTON -D $paramlist -ext log $dalfile $molfile | \
              grep -v '\*\*\**' | \
              grep -v 'OUTPUT FROM' | grep -v 'Version' | grep -v 'PID' | \
              grep -v '^$' | tee -a $listing
          fi
          myprint ""
          myprint "evaluate output file $logfile:"
          myprint "-----------------------------------------------------------"
          checkout=`$checkfile $logfile | tee -a $listing`
          if [ "$benchmark" = "true" ]; then
              if [ `$GREP "CPU  time used in DALTON" $logfile | wc -l` = 1 ]; then
                  CPU_usage=`$GREP "CPU  time used in DALTON" $logfile | sed s/">>>> Total CPU  time used in DALTON\:"/""/`
              else
                  CPU_usage="N/A"
              fi
          fi
      fi
      if [ "$benchmark" = "true" ]; then
          numresult=`expr $numresult \+ 1`
          if [ $step -eq 1 ]; then
              testlist[$numresult]="$item"
          else
              testlist[$numresult]="...step$step"
          fi
          timelist[$numresult]="$CPU_usage"
      fi
      echo $checkout
      passed=`echo $checkout | grep "TEST ENDED PROPERLY"`
      if [ -n "$passed" ]; then
        if [ "$keep" = "false" ]; then
          rm -f $dalfile.dal $dalfile.BAS $checkfile $logfile $item.info $dalfile.tar.gz
        fi
      else
        trouble=`expr $trouble \+ 1`
        if [ "$bell" = "true" ]; then
          echo "\a"
        fi
        passedall="THERE IS A PROBLEM IN TEST CASE"
        if [ "$trouble" -eq 1 ]; then
            problems="$problems $item"
        fi
      fi
    step=`expr $step \+ 1`
  done
  if [ "$trouble" -eq 0 ]; then
      if [ "$keep" = "false" ]; then
          rm -f $molfile.mol
      fi
  fi
done

#########################################################################
# final result:
#########################################################################

myprint ""
myprint "#####################################################################"
myprint "                              Summary"
myprint "#####################################################################"
myprint ""

if [ "$benchmark" = "true" ]; then
    if [ "$numresult" -gt 0  ]; then
        ind=1
        while [ "$ind" -le "$numresult" ]
        do
          namelength=`expr length ${testlist[$ind]}`
          spclength=`expr 32 \- $namelength`
          spc=`expr substr "$emptystring" 1 $spclength`
          myprint "	${testlist[$ind]}$spc${timelist[$ind]}"
          ind=`expr $ind \+ 1`
        done
        echo
    fi
fi

myprint "$passedall"
myprint "$problems"

exit 0
