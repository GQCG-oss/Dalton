#!/bin/sh
# test function definitions for dalton

# check_gen_input:
# generate several input and description files.
# $1 - test name
# $2 - test info.
# $3 - molecule file.
# $4 - dalton file.
# $5 - list of test check routines.
check_gen_input() {
testname=`basename $1`
if [ -x /bin/ksh ]; then
   CHECK_SHELL='#!/bin/ksh'
elif [ -x /bin/bash ]; then
   CHECK_SHELL='#!/bin/bash'
else
   CHECK_SHELL='#!/bin/sh'
fi

# Prefer gawk - we know exactly what it can do.
# awk on Sun does not support functions, need to use nawk for this
if gawk '{print 1}'</dev/null > /dev/null 2>&1; then
   AWK=gawk
elif nawk '{print 1}'</dev/null > /dev/null 2>&1; then
   AWK=nawk
else
   AWK=awk
fi
    if [ "$5" = "" ]; then echo "empty test check file. Test $1 broken."; fi
    echo "$2" > $testname.info
    echo "$3" > $testname.mol
    echo "$4" > $testname.dal
    echo "$CHECK_SHELL" >"$testname.check"
    echo "AWK=$AWK" >> "$testname.check"
    cat >>"$testname.check" <<'%EOF%'
log=$1
ERRLIST=""
. ./functions || { echo "current dir is not the test dir" ; exit 1; }
%EOF%

    echo "$5" >> "$testname.check"
    cat >>"$testname.check" <<'%EOF%'
if [ "$ERRLIST" = "" ]; then
  echo TEST ENDED PROPERLY
  exit 0
else
  echo "Failed tests: $ERRLIST"
  echo THERE IS A PROBLEM
  exit 1
fi
%EOF%
}

# ###################################################################
# miscellaneous tests listed here.

# check_scf_energy:
# $1 - calculation type: HF|DFT
# $2 - expected energy
# $3 - max deviation
check_scf_energy() {
[ "$3" = "" ] &&  echo "not enough parameters to check_scf_energy."
$AWK 'function e(v,r){#print "scf_energy: checking ",v, r;
return(v>r||v<-r)}
/Final *'$1' *energy:/{c=1;exit (e($4-('$2'),'$3'))} END{if(!c) exit(1)}
' $log || ERRLIST="$ERRLIST; SCF energy"
}

# check_dipole:
# $1 - expected dipole moment (au)
# $2 - max deviation
check_dipole() {
[ "$2" = "" ] &&  echo "not enough parameters to check_dipole."
$AWK '/Dipole moment$/{getline; getline;getline;s=($1<'$1-$2'||$1>'$1+$2'); exit 0;}END{exit (s?1:0)}' $log || ERRLIST="$ERRLIST; Dipole moment"
}

# check_dip_components:
# check components of the first dipole moment encountered in the 
# log file.
# $1 - x component
# $2 - y component
# $3 - z component
# $4 - max deviation
check_dip_components() {
[ "$4" = "" ] &&  echo "not enough parameters to check_dip_components."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)}
/Dipole moment components/{
for(i=0;i<5;i++)getline; 
if (s=e($3,'$1,$4')) exit 1;getline;
if (s=e($3,'$2,$4')) exit 1;getline;
if (s=e($3,'$3,$4')) exit 1;exit 0}
END{exit (s?1:0)}' $log || ERRLIST="$ERRLIST; Dipole moment"
}

# check_polarizability:
# check linear response polarizability
# $1 - value of X component
# $2 - value of Y component
# $3 - value of Z component
# $4 - max deviation.
check_polarizabilities() {
[ "$4" = "" ] &&  echo "not enough parameters to check_polarizabilities."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)} BEGIN {s=0}
/^@.*XDIPLEN/ {if(!e($8,'$1,$4'))s++}
/^@.*YDIPLEN/ {if(!e($8,'$2,$4'))s++}
/^@.*ZDIPLEN/ {if(!e($8,'$3,$4'))s++}
END{exit (s==3?0:1) }' $log || ERRLIST="$ERRLIST; Polarizabilities"
}

# check_hyperpolarizability:
# check quadratic response/hyperpolarizability
# $1 - value of frequency B
# $2 - value of frequency C
# $3 - combinations of operators, eg. 'X;Y,Y'
# $4 - expected value
# $5 - max deviation.
check_hyperpolarizabilities() {
[ "$5" = "" ] &&  echo "not enough parameters to check_hyperpolarizabilities."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)} BEGIN {s=0}
/^@ B-freq/ && $4=='$1' && $7=='$2' && $8=="beta('$3')"{if(!e($10,'$4,$5'))s++}
END{exit (s==1?0:1) }' $log || ERRLIST="$ERRLIST; Hyperpol-ties $4"
}

# check_general_lr:
# check linear response property P=<<X,Y>>
# $1 - label of X
# $2 - label of Y
# $3 - expected value of P
# $4 - max deviation.
check_general_lr() {
[ "$4" = "" ] &&  echo "not enough parameters to check_general_lr."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)} BEGIN {s=0}
/^@ -<< '$1'.*'$2'/ { value=substr($0,31)
                 gsub("D","E",value);
                 if(!e(value,'$3','$4')) s++; 
                 else { print substr($0,31) " " '$3'; }
               }
END{exit (s==1?0:1) }' $log || ERRLIST="$ERRLIST; Linear response"
}

# ###################################################################
# Geometry optimization functions.

# check_mol_gradient:
# check N:th molecular gradient in the file for given atom.
# $1 - which occurence of molecular gradient should be checked.
# $2 - 6-character atom label including symmetry equivalence number (if any)
# $3:$5 - gradient components.
# $6 - tolerance.
check_mol_gradient() {
if [ "$6" = "" ]; then
    echo "not enough parameters to check_mol_gradient."; return 1
fi
$AWK 'function e(v,r){#print "mol_grad: checking " v,",", r;
return(v>r||v<-r)}
 BEGIN {s=0;c=0}
/Molecular gradient/{
if(++c == '$1') { getline; getline;
#skip norms
cemty=0;
while(cempty<9 && substr($0,2,6)!="'"$2"'") {
  if($0=="") cempty++;
  getline;
}
if(cempty==9) { print "mol_gradient: Label '"$2"' not found!"; exit 1;}
split(substr($0,8),a);
exit( e(a[1]-('$3'),'$6') || e(a[2]-('$4'),'$6') || e(a[3]-('$5'),'$6'))
}
}
' $log || ERRLIST="$ERRLIST; molecular gradient"
}

# check_dip_gradient:
# check molecular gradient of dipole moment for given atom
# $1 - number of atoms to check
# $2 - tolerance
# $3 - components following format
# <label1> x <dxx> <dyx> <dzx>
# <label1> y <dxy> <dyy> <dzy>
# <label1> z <dxz> <dyz> <dzz>
# <label2> x <dxx> <dyx> <dzx>
# ...., ie. same as in the output file.
check_dip_gradient() {
if [ "$3" = "" ]; then
    echo "not enough parameters to check_dip_gradient."; return 1
fi
p=`echo $3`
$AWK 'function e(v,r){#print "mol_grad: checking " v,",", r;
return(v>r||v<-r)}
 BEGIN {s=0;c=0}
/Dipole moment gradient \(au\)/ {
getline; # ---------------------------
getline; #
getline; #  Ex             Ey             Ez
getline; #
atoms='$1'; tol='$2';
split("'"$p"'",arr," ");
idx=1;
failed=0;
for(a=0; a<atoms; a++) {
for(cor=0;cor<3; cor++) {
  lbl=arr[idx++]; coor=arr[idx++];
  x=arr[idx++];y=arr[idx++]; z=arr[idx++];
  getline;
  if($1 != lbl || $2 != coor ||
     e(x-$3,tol) || e(y-$4,tol) || e(z-$5,tol)) {
     print $0;
     print "match on ",lbl,":",coor,":", x,":", y,":", z," failed";
     failed++;
  }
}
  getline; #empty
}
}
END {exit(failed)}
' $log || ERRLIST="$ERRLIST; Dipole moment gradient"
}

# check_mol_hessian:
# check the molecular hessian.
# $1 - tolerance
# $2 - the hessian
# checking is tricky because of the large amount of data to be
# verified. We compare all the numbers in the string with given
# tolerance.  When passing string to awk, we compress spaces and
# trailing zeros because some variants of awk (notably on AIX) cannot
# handle strings longer than 399 characters.
check_mol_hessian() {
if [ "$3" = "" ]; then
    echo "not enough parameters to check_vibr_freq."; return 1
fi
p=`echo $3|sed 's,[ 0]* , ,g'`
$AWK 'function e(v,r){#print "mol_hessian: checking " v,",", r;
return(v>r||v<-r)}
 BEGIN {s=0;c=0}
/Molecular Hessian \(au\)/ {
getline; # ---------------------------
getline; #
tol='$1';
split("'"$p"'",arr," ");
idx=1;
failed=0;
while(arr[idx] != "") {
getline; split($0,l," ");
for(i=1; l[i]!= ""; i++) {
 #print "Expected:",arr[idx]," Found:",l[i]
 if(l[i] ~ /-?[.0-9]+/) {
   if(e(arr[idx]-l[i],tol)) failed++;
  } else {
   if(arr[idx] != l[i])     failed++
  } 
  idx++
}
if(failed>5) break
}
}
END {exit(failed)}
' $log || ERRLIST="$ERRLIST; Molecular Hessian"
}

# check_final_geometry:
# $1 - 6-character atom label including symmetry equivalence number
# $2:$4 - coordinates.
# $5    - tolerance
check_final_geometry() {
if [ "$5" = "" ]; then
    echo "not enough parameters to check_final_geometry."; return 1
fi
$AWK 'function e(v,r){#print "final_geometry;checking ",v, r;
return(v>r||v<-r)}
BEGIN {s=0;c=0}
/Final geometry/{ getline; getline;getline;
while($0 != "" && substr($0,2,6)!="'"$1"'") getline;
if($0 == "") { print "final_geometry: Label '"$1"' not found!"; exit 1;}
split(substr($0,8),a);
exit( e(a[1]-('$2'),'$5') || e(a[2]-('$3'),'$5') || e(a[3]-('$4'),'$5'))
}
' $log || ERRLIST="$ERRLIST; final geometry"
}

# check_final_energy:
# $1 - final geometry optimization energy
# $2 - tolerance.
check_final_energy() {
if [ "$2" = "" ]; then
    echo "not enough parameters to check_final_energy."; return 1
fi
$AWK 'function e(v,r){#print "checking ",v, r;
return(v>r||v<-r)}
/Energy at final geometry is/ { exit(e($7-('$1'),'$2'))  }
' $log || ERRLIST="$ERRLIST; final energy"
}

# check_rot_constants:
# check rotational constant
# $1 - expected value in MHz
# $2 - expected value in cm-1 
# Tested for a linear molecule.
check_rotational_const() {
if [ "$2" = "" ]; then
    echo "not enough parameters to check_rotational_const."; return 1
fi
$AWK '
/ B = /{if($3!='$1'||$6 != '$2')failed++}
END    {exit(failed)}
'  $log || ERRLIST="$ERRLIST; ROTATIONAL CONSTANTS $1"
}

# check_vibr_freqs:
# check the vibrational frequencies and intensities.
# $1 - tolerance
# $2 - the IR freq and intensity data
# use the same method as in molecular hessian. 
check_vibr_freqs() {
if [ "$2" = "" ]; then
    echo "not enough parameters to check_vibr_freq."; return 1
fi
p=`echo $2`
$AWK 'function e(v,r){#print "vibr_freq: checking " v,",", r;
return(v>r||v<-r)}
 BEGIN {s=0;c=0}
/ Vibrational Frequencies and IR Intensities/ {
for(i=0; i<8; i++) getline;
tol='$1';
split("'"$p"'",arr," ");
idx=1;
failed=0;
while(arr[idx] != "") {
getline; split($0,l," ");
for(i=1; l[i]!= ""; i++) {
 #print "Expected:",arr[idx]," Found:",l[i]
 if(l[i] ~ /-?[.0-9]+/) {
   if(e(arr[idx]-l[i],tol)) {failed++;print "a"}
  } else {
   if(arr[idx] != l[i])     {failed++;print "b"}
  } 
  idx++
}
if(failed>5) break
}
}
END {exit(failed)}
' $log || ERRLIST="$ERRLIST; Vibrational Frequencies"
}

# check_exp_grad:
# Check the orbital gradient.
# $1 - number of the basis function
# $2 - exponent of the basis function (for input cross-checking)
# $3 - expected value of the gradient
# $4 - tolerance
check_exp_grad() {
if [ "$4" = "" ]; then
    echo "not enough parameters to check_exp_grad."; return 1
fi
$AWK 'function e(v,r){#print "checking ",v, r;
return(v>r||v<-r)}
$1== "##" && $2 == '$1' && $7=='$3' { exit(e($8-('$3'),'$4'))  }
' $log || ERRLIST="$ERRLIST; ORB. GRADIENT $1"
}
