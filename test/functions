#!/bin/sh
# test function definitions for dalton

# check_gen_input:
# generate several input and description files.
# $1 - test name
# $2 - test info.
# $3 - molecule file.
# $4 - dalton file.
# $5 - list of test check routines.
check_gen_input() {
if [ -x /bin/ksh ]; then
   CHECK_SHELL='#!/bin/ksh'
elif [ -x /bin/bash ]; then
   CHECK_SHELL='#!/bin/bash'
else
   CHECK_SHELL='#!/bin/sh'
fi

# awk on Sun does not support functions, need to sue nawk for this
if nawk '{print 1}'</dev/null>& /dev/null; then
   AWK=nawk
else
   AWK=awk
fi
    if [ "$5" = "" ]; then echo "empty test check file. Test $1 broken."; fi
    echo "$2" > $1.info
    echo "$3" > $1.mol
    echo "$4" > $1.dal
    echo "$CHECK_SHELL" >"$1.check"
    echo "AWK=$AWK" >> "$1.check"
    cat >>"$1.check" <<'%EOF%'
log=$1
ERRLIST=""
. ./functions || { echo "current dir is not the test dir" ; exit 1; }
%EOF%

    echo "$5" >> "$1.check"
    cat >>"$1.check" <<'%EOF%'
if [ "$ERRLIST" = "" ]; then
  echo TEST ENDED PROPERLY
  exit 0
else
  echo "Failed tests: $ERRLIST"
  echo THERE IS A PROBLEM
  exit 1
fi
%EOF%
}

# ###################################################################
# miscellaneous tests listed here.

# check_scf_energy:
# $1 - calculation type: HF|DFT
# $2 - expected energy
# $3 - max deviation
check_scf_energy() {
[ "$3" = "" ] &&  echo "not enough parameters to check_scf_energy."
$AWK 'function e(v,r){#print "scf_energy: checking ",v, r;
return(v>r||v<-r)}
/Final *'$1' *energy:/{c=1;exit (e($4-('$2'),'$3'))} END{if(!c) exit(1)}
' $log || ERRLIST="$ERRLIST; SCF energy"
}

# check_dipole:
# $1 - expected dipole moment (au)
# $2 - max deviation
check_dipole() {
[ "$2" = "" ] &&  echo "not enough parameters to check_dipole."
$AWK '/Dipole moment$/{getline; getline;getline;s=($1<'$1-$2'||$1>'$1+$2'); exit 0;}END{exit (s?1:0)}' $log || ERRLIST="$ERRLIST; Dipole moment"
}

# check_dip_components:
# check components of the first dipole moment encountered in the 
# log file.
# $1 - x component
# $2 - y component
# $3 - z component
# $4 - max deviation
check_dip_components() {
[ "$4" = "" ] &&  echo "not enough parameters to check_dip_components."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)}
/Dipole moment components/{
for(i=0;i<5;i++)getline; 
if (s=e($3,'$1,$4')) exit 1;getline;
if (s=e($3,'$2,$4')) exit 1;getline;
if (s=e($3,'$3,$4')) exit 1;exit 0}
END{exit (s?1:0)}' $log || ERRLIST="$ERRLIST; Dipole moment"
}

# check_polarizability:
# check linear response polarizability
# $1 - value of X component
# $2 - value of Y component
# $3 - value of Z component
# $4 - max deviation.
check_polarizabilities() {
[ "$4" = "" ] &&  echo "not enough parameters to check_polarizabilities."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)} BEGIN {s=0}
/^@.*XDIPLEN/ {if(!e($8,'$1,$4'))s++}
/^@.*YDIPLEN/ {if(!e($8,'$2,$4'))s++}
/^@.*ZDIPLEN/ {if(!e($8,'$3,$4'))s++}
END{exit (s==3?0:1) }' $log || ERRLIST="$ERRLIST; Polarizabilities"
}

# check_hyperpolarizability:
# check quadratic response/hyperpolarizability
# $1 - value of frequency B
# $2 - value of frequency C
# $3 - combinations of operators, eg. 'X;Y,Y'
# $4 - expected value
# $5 - max deviation.
check_hyperpolarizabilities() {
[ "$5" = "" ] &&  echo "not enough parameters to check_hyperpolarizabilities."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)} BEGIN {s=0}
/^@ B-freq/ && $4=='$1' && $7=='$2' && $8=="beta('$3')"{if(!e($10,'$4,$5'))s++}
END{exit (s==1?0:1) }' $log || ERRLIST="$ERRLIST; Hyperpol-ties $4"
}

# check_general_lr:
# check linear response property P=<<X,Y>>
# $1 - label of X
# $2 - label of Y
# $3 - expected value of P
# $4 - max deviation.
check_general_lr() {
[ "$4" = "" ] &&  echo "not enough parameters to check_general_lr."
$AWK 'function e(a,b,r){return(a-b>r||a-b<-r)} BEGIN {s=0}
/^@ -<< '$1'.*'$2'/ { value=substr($0,31)
                 gsub("D","E",value);
                 if(!e(value,'$3','$4')) s++; 
                 else { print substr($0,31) " " '$3'; }
               }
END{exit (s==1?0:1) }' $log || ERRLIST="$ERRLIST; Linear response"
}

# ###################################################################
# Geometry optimization functions.

# check_mol_gradient:
# check N:th molecular gradient in the file for given atom.
# $1 - which occurence of molecular gradient should be checked.
# $2 - 6-character atom label including symmetry equivalence number (if any)
# $3:$5 - gradient components.
# $6 - tolerance.
check_mol_gradient() {
if [ "$6" = "" ]; then
    echo "not enough parameters to check_mol_gradient."; return 1
fi
$AWK 'function e(v,r){#print "mol_grad: checking " v,",", r;
return(v>r||v<-r)}
 BEGIN {s=0;c=0}
/Molecular gradient/{
if(++c == '$1') { getline; getline;
#skip norms
cemty=0;
while(cempty<9 && substr($0,2,6)!="'"$2"'") {
  if($0=="") cempty++;
  getline;
}
if(cempty==9) { print "mol_gradient: Label '"$2"' not found!"; exit 1;}
split(substr($0,8),a);
exit( e(a[1]-('$3'),'$6') || e(a[2]-('$4'),'$6') || e(a[3]-('$5'),'$6'))
}
}
' $log || ERRLIST="$ERRLIST; molecular gradient"
}


# check_final_geometry:
# $1 - 6-character atom label inculding symmetry equivalence number
# $2:$4 - coordinates.
# $5    - tolerance
check_final_geometry() {
if [ "$5" = "" ]; then
    echo "not enough parameters to check_final_geometry."; return 1
fi
$AWK 'function e(v,r){#print "final_geometry;checking ",v, r;
return(v>r||v<-r)}
BEGIN {s=0;c=0}
/Final geometry/{ getline; getline;getline;
while($0 != "" && substr($0,2,6)!="'"$1"'") getline;
if($0 == "") { print "final_geometry: Label '"$1"' not found!"; exit 1;}
split(substr($0,8),a);
exit( e(a[1]-('$2'),'$5') || e(a[2]-('$3'),'$5') || e(a[3]-('$4'),'$5'))
}
' $log || ERRLIST="$ERRLIST; final geometry"
}

# check_final_energy:
# $1 - final geometry optimization energy
# $2 - tolerance.
check_final_energy() {
if [ "$2" = "" ]; then
    echo "not enough parameters to check_final_energy."; return 1
fi
$AWK 'function e(v,r){#print "checking ",v, r;
return(v>r||v<-r)}
/Energy at final geometry is/ { exit(e($7-('$1'),'$2'))  }
' $log || ERRLIST="$ERRLIST; final energy"
}

# check_exp_grad:
# Check the orbital gradient.
# $1 - number of the basis function
# $2 - exponent of the basis function (for input cross-checking)
# $3 - expected value of the gradient
# $4 - tolerance
check_exp_grad() {
if [ "$4" = "" ]; then
    echo "not enough parameters to check_exp_grad."; return 1
fi
$AWK 'function e(v,r){#print "checking ",v, r;
return(v>r||v<-r)}
$1== "##" && $2 == '$1' && $7=='$3' { exit(e($8-('$3'),'$4'))  }
' $log || ERRLIST="$ERRLIST; ORB. GRADIENT $1"
}
