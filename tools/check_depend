#!/bin/csh -f

set ORI = `pwd`
set DIR = '/tmp'

set dirlist = `echo '.' $* | sed -e 's/-WF//g' -e 's/-I//g' -e 's/,/ /g' `

echo 'BEGIN{'  > $DIR/awk.tmp$$
foreach dir ( $dirlist )
  cd $dir
  set list = `find . -name "*.h" -print | sed -e 's/\.\///g'`
  foreach file ( $list )
   echo 'dir["'$file'"]="'$dir'/";'  >> $DIR/awk.tmp$$
  end
  cd $ORI
end
echo ' n = 3 }'  >> $DIR/awk.tmp$$

cat >> $DIR/awk.tmp$$ <<!
  { path = dir[\$1];
    if       ( n < 3 && path ) {printf("  %s%s",path,\$1);       n++  }
    else {if ( n == 3 && path ) {printf(" \\\\\n  %s%s",path,\$1); n = 1}} }

END{printf("\n");}
!

# search all Fortran and C source files for includes
foreach file (*.F *.f *.c *.cc)
  set root   = $file:r
  #  use awk to remove newline character from echo
  echo "$root.o $root.i $file" | awk '{printf("%s %s : %s ",$1,$2,$3)}'
  sed -n -e '/^ *# *include/p' $file | \
           sed -e 's/include//g' -e 's/[#<>" ]//g' | sort | uniq > $DIR/tmp.$$
  # strip path information from the strings extracted from the source files
  # by passing the file names through 'basename' (this needs a for loop since
  # for some reasons 'basename' doesn't work if invoked between pipes...)
  set myincludes=`cat $DIR/tmp.$$`
  rm $DIR/tmp.$$
  foreach entry ($myincludes);
    basename $entry >> $DIR/tmp.$$
  end
  touch $DIR/tmp.$$
  # invoke awk script to select those includes files which are part of DALTON,
  # i.e. are not e.g. standard includes from the C library etc.
  awk -f $DIR/awk.tmp$$ $DIR/tmp.$$
  echo " "
  echo " "
end

rm -f $DIR/awk.tmp$$ $DIR/tmp.$$ 

