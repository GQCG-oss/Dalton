C
C...   Copyright (c) 2005 by the authors of Dalton (see below).
C...   All Rights Reserved.
C...
C...   The source code in this file is part of
C...   "Dalton, a molecular electronic structure program, Release 2.0
C...   (2005), written by C. Angeli, K. L. Bak,  V. Bakken, 
C...   O. Christiansen, R. Cimiraglia, S. Coriani, P. Dahle,
C...   E. K. Dalskov, T. Enevoldsen, B. Fernandez, C. Haettig,
C...   K. Hald, A. Halkier, H. Heiberg, T. Helgaker, H. Hettema, 
C...   H. J. Aa. Jensen, D. Jonsson, P. Joergensen, S. Kirpekar, 
C...   W. Klopper, R.Kobayashi, H. Koch, O. B. Lutnaes, K. V. Mikkelsen, 
C...   P. Norman, J.Olsen, M. J. Packer, T. B. Pedersen, Z. Rinkevicius,
C...   E. Rudberg, T. A. Ruden, K. Ruud, P. Salek, A. Sanchez de Meras,
C...   T. Saue, S. P. A. Sauer, B. Schimmelpfennig, K. O. Sylvester-Hvid, 
C...   P. R. Taylor, O. Vahtras, D. J. Wilson, H. Agren.
C...   This source code is provided under a written licence and may be
C...   used, copied, transmitted, or stored only in accord with that
C...   written licence.
C...
C...   In particular, no part of the source code or compiled modules may
C...   be distributed outside the research group of the licence holder.
C...   This means also that persons (e.g. post-docs) leaving the research
C...   group of the licence holder may not take any part of Dalton,
C...   including modified files, with him/her, unless that person has
C...   obtained his/her own licence.
C...
C...   For questions concerning this copyright write to:
C...      dalton-admin@kjemi.uio.no
C...
C...   For information on how to get a licence see:
C...      http://www.kjemi.uio.no/software/dalton/dalton.html
C
#include <single.h>
C
C  /* Deck cc_soldrv */
C--------------------------------------------------------------------
      SUBROUTINE CC_SOLDRV(LIST,NSTAT,ORDER,ISIDE,
     &                     ISYMS, ISTAT, EIGVAL, LPROJ,
     &                     ISYMO, LABEL, FREQS, ICAU,
     &                     ISYOF, NVEC,  MAXVEC, WORK, LWORK)
C--------------------------------------------------------------------
C
C     Purpose: Direct solution of Coupled Cluster response equations.
C
C              LIST  -- list name, used to get the gradient vector and
C                       to read/write result to file
C
C              NSTAT -- nb. of involved excited states
C              ORDER -- response order (n.b. of Labels,frequencies...)
C
C              ISIDE = 1 : solve right response equations (A-w)R = X
C              ISIDE =-1 : solve left response equations  L(A+w) = X
C
C              ISYMS   -- symmetry of involved excitated states
C              ISTAT   -- indices of excited states
C              EIGVAL  -- excitation energies
C
C              ISYMO   -- operator symmetries
C              LABEL   -- operator labels
C              FREQS   -- associated frequencies
C              ICAU    -- cauchy order
C
C              ISYOFF  -- symmetry offsets, as generated by LSTSORT
C              NVEC    -- number of response equations to solve
C              MAXVEC  -- first dimension in allocation of ISYMS
C                         ISTAT,EIGVAL,ISYMO,LABEL,FREQS,ICAU
C
C              WORK/LWORK -- work space, length of work space
C            
C
C  Christof Haettig, Maj 1997, based on Ove's version of CC_SOLRSP
C  Christof Haettig, Jul 1997, excited state resp. eq. implemented
C  Christof Haettig, Oct 1997, batching for Cauchy eq. implemented
C  Christof Haettig, Feb 1998, second-order Cauchy eq. implemented
C  Sonia Coriani,    Mar 2000, added PL1 to ELn/ERn special batching
C  Christof Haettig, Apr 2002, small modifications for CC3
C----------------------------------------------------------------------
C
#include <implicit.h>
#include <priunit.h>
#include <dummy.h>
#include <maxorb.h>
#include <iratdef.h>
#include <cclr.h>
#include <ccorb.h>
#include <ccsdsym.h>
#include <ccfro.h>
#include <ccsdio.h>
#include <ccsdinp.h>
#include <leinf.h>
C
      LOGICAL LOCDBG
      PARAMETER (LOCDBG = .FALSE.) 
C
      LOGICAL TRIPLET
      PARAMETER (TRIPLET= .FALSE.) 
C
      CHARACTER LIST*(*)

      INTEGER NSTAT, ORDER, MAXVEC, NVEC, ISIDE, NSIMLEBAK
      INTEGER ISYOF(8)

      LOGICAL LPROJ(MAXVEC)
      CHARACTER*8 LABEL(MAXVEC,ORDER)
      INTEGER ISYMS(MAXVEC,NSTAT), ISTAT(MAXVEC,NSTAT)
      INTEGER ISYMO(MAXVEC,ORDER), ICAU(MAXVEC,ORDER)

#if defined (SYS_CRAY)
      REAL FREQS(MAXVEC,ORDER), EIGVAL(MAXVEC,NSTAT)
      REAL SIGN
      REAL ZERO, ONE
      PARAMETER (ZERO = 0.0, ONE = 1.0)
#else
      DOUBLE PRECISION FREQS(MAXVEC,ORDER), EIGVAL(MAXVEC,NSTAT)
      DOUBLE PRECISION SIGN
      DOUBLE PRECISION ZERO, ONE
      PARAMETER (ZERO = 0.0d0, ONE = 1.0d0)
#endif

      CHARACTER*8 FC1AM,FC2AM,FRHO1,FRHO2,FRHO12,FC12AM,FS12AM
      PARAMETER (FC1AM ='CCR_C1AM',FC2AM ='CCR_C2AM')
      PARAMETER (FRHO1 ='CCR_RHO1',FRHO2 ='CCR_RHO2')
      PARAMETER (FRHO12='CCR_RH12',FC12AM='CCR_C12M',FS12AM='CCR_S12M')

      LOGICAL LINQCC
      PARAMETER (LINQCC = .TRUE.) 

      DIMENSION WORK(LWORK)
      CHARACTER MODEL*10
      LOGICAL LTAKE, LPROJECT, LREDS

C
      CALL QENTER('CC_SOLDRV')
      LUFC1  = 0
      LUFC2  = 0
      LUFC12 = 0
      LUFR1  = 0
      LUFR2  = 0
      LUFR12 = 0
      LUFS12 = 0
C
      LREDS = CCR12
C
      IF (LOCDBG) THEN
        WRITE (LUPRI,*) 'LIST  :',LIST
        WRITE (LUPRI,*) 'NSTAT :',NSTAT
        WRITE (LUPRI,*) 'ORDER :',ORDER
        WRITE (LUPRI,*) 'ISIDE :',ISIDE
        WRITE (LUPRI,*) 'NVEC  :',NVEC
        WRITE (LUPRI,*) 'MAXVEC:',MAXVEC
        WRITE (LUPRI,*) 'ISYMS :',((ISYMS(I,J),J=1,NSTAT),I=1,NVEC)
        WRITE (LUPRI,*) 'ISTAT :',((ISTAT(I,J),J=1,NSTAT),I=1,NVEC)
        WRITE (LUPRI,*) 'EIGVAL:',((EIGVAL(I,J),J=1,NSTAT),I=1,NVEC)
        WRITE (LUPRI,*) 'ISYMO :',((ISYMO(I,J),J=1,ORDER),I=1,NVEC)
        WRITE (LUPRI,*) 'LABEL :',((LABEL(I,J),J=1,ORDER),I=1,NVEC)
        IF (LIST(1:1).NE.'C' .AND. LIST(2:2).NE.'C' .AND.
     &      LIST(1:2).NE.'M1'.AND. LIST(1:2).NE.'N2' ) THEN
          WRITE (LUPRI,*) 'FREQS :',((FREQS(I,J),J=1,ORDER),I=1,NVEC)
        END IF
        IF (LIST(1:1).EQ.'C' .OR.  LIST(2:2).EQ.'C') THEN
          WRITE (LUPRI,*) 'ICAU  :',((ICAU(I,J),J=1,ORDER),I=1,NVEC)
        END IF
        IF (LIST(1:2).EQ.'ER' .OR. LIST(1:2).EQ.'EL') THEN
          WRITE (LUPRI,*) 'LPROJ :',(LPROJ(I),I=1,NVEC)
        END IF
      END IF

      IF (NVEC.EQ.0) THEN
         CALL QEXIT('CC_SOLDRV')
         RETURN
      END IF

C
C-------------------------------------
C     Initialize Leinfi and variables.
C-------------------------------------
C
      IPRLE = IPRINT 
      MODEL = 'xxxxxxxxxx'
      IF (CCR12) THEN
        IF (CCS)             MODEL = 'CCS       '
        IF (CC2 .AND. CCR12) MODEL = 'CC2-R12   '
        IF (CCSD.AND. CCR12) MODEL = 'CCSD-R12  '
        IF (CC3 .AND. CCR12) MODEL = 'CC3-R12   '
      ELSE
        IF (CCS)  MODEL = 'CCS       '
        IF (CC2)  MODEL = 'CC2       '
        IF (CCSD) MODEL = 'CCSD      '
        IF (CC3)  MODEL = 'CC3       '
      END IF
C
      IF (.NOT.(CCS.OR.CC2.OR.CCSD.OR.CC3)) THEN
         WRITE(LUPRI,'(A)') ' CC_SOLRSP: Do not want to calculate '
     *           //'anything else than CCS, CC2 and CCSD properties '
         CALL QUIT('Model not CCS or CC2 or CCSD or CC3 in CC_SOLRSP')
      ENDIF
 
C---------------------------------------------------------------------
C        For CC3: switch batching OFF 
C        (presently we can not solve CC3 equations simultaneously,
C         because then we are not allowed to share the same reduced
C         space for equations with different frequencies...)
C---------------------------------------------------------------------
      NSIMLEBAK = NSIMLE
      IF (CCSDT) NSIMLE = 1

C-------------------------------------------------------------
C     Start loop structure - first loop over symmetry classes.
C-------------------------------------------------------------
 
      DO ISYM = 1, NSYM
 
C-----------------------------
C        Initialize Variables.
C-----------------------------
 
         ISYMTR = ISYM
         IF (CCS) THEN
           NCCVAR = NT1AM(ISYMTR)
         ELSE
           NCCVAR = NT1AM(ISYMTR) + NT2AM(ISYMTR)
           IF (CCR12) NCCVAR = NCCVAR + NGAMMA(ISYMTR)
         END IF
         CALL CCLR_LEINFI(TRIPLET)
         THRLE = THRLEQ
      IF (LETYPA .GT.0) THEN
 
C-------------------------------------------------------------------
C        Find out how many equations to solve in this symmetry class
C-------------------------------------------------------------------
         IBOFF = ISYOF(ISYM)
         IF (ISYM .EQ. NSYM) THEN
            IBEND = NVEC
         ELSE
            IBEND = ISYOF(ISYM+1)
         ENDIF
         NEQSYM  = IBEND - IBOFF
 
C---------------------------------------------------------------------
C        Make batching over nr. of simultaneous vectors to be solved:
C        all or take the number from input.
C---------------------------------------------------------------------
         IF (NEQSYM .EQ. 0 ) THEN
            NSIM = 0
            NBAT = 0
         ELSE
            IF ( NSIMLE .EQ. 0 ) THEN
               NSIM  = NEQSYM
            ELSE
               NSIM  = NSIMLE
            ENDIF
            NBAT  = (NEQSYM-1)/NSIM + 1
         ENDIF

*---------------------------------------------------------------------
*        special batching for excited state response vectors:
*        and projected Lagragian multipliers
*---------------------------------------------------------------------
         IF (LIST(1:2).EQ.'ER' .OR. LIST(1:2).EQ.'EL'
     &                         .OR. LIST(1:3).EQ.'PL1') THEN
           IREND = IBOFF
           NBAT  = 0
           DO WHILE (IREND.LT.IBOFF+NEQSYM)
               NBAT  = NBAT + 1
               IRST  = IREND+1
               NSIMR = 1
               IREND = IRST
               IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
                 LTAKE = ( ( ISTAT(IREND+1,1).EQ.ISTAT(IRST,1)
     &                        .AND. (LPROJ(IREND+1).EQV.LPROJ(IRST)) )
     &                    .OR. ((LPROJ(IREND+1).EQV..FALSE.)
     &                           .AND. (LPROJ(IRST).EQV..FALSE.)) ) 
               END IF
               DO WHILE (  IREND.LT.(IBOFF+NEQSYM) .AND.
     &                     NSIMR.LT.NSIM  .AND. LTAKE ) 
                 IREND = IREND + 1
                 NSIMR = NSIMR + 1
                 IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
                   LTAKE = ( ( ISTAT(IREND+1,1).EQ.ISTAT(IRST,1)
     &                         .AND. (LPROJ(IREND+1).EQV.LPROJ(IRST)) )
     &                      .OR. ((LPROJ(IREND+1).EQV..FALSE.)
     &                             .AND. (LPROJ(IRST).EQV..FALSE.)) ) 
                 END IF
               END DO
           END DO
         END IF

*---------------------------------------------------------------------
*        special batching for Cauchy vectors:
*---------------------------------------------------------------------
         IF ( (LIST(1:2).EQ.'RC'.AND. .NOT.NEWCAU) 
     &        .OR. LIST(1:2).EQ.'LC'
     &        .OR. LIST(1:2).EQ.'CR'
     &        .OR. LIST(1:2).EQ.'CL'               ) THEN
           IREND = IBOFF
           NBAT  = 0
           DO WHILE (IREND.LT.IBOFF+NEQSYM)
               NBAT  = NBAT + 1
               IRST  = IREND+1
               NSIMR = 1
               IREND = IRST
               IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
C                LTAKE = .TRUE.
C                DO IORD = 1, ORDER
C                  LTAKE = LTAKE .AND. 
C    &                       (ICAU(IREND+1,IORD) .EQ. ICAU(IRST,IORD))
C                END DO
                 ICAUS = 0
                 ICAUE = 0
                 DO IORD = 1, ORDER
                   ICAUS = ICAUS + ICAU(IRST,IORD)
                   ICAUE = ICAUE + ICAU(IREND+1,IORD)
                 END DO
                 LTAKE = ICAUE .EQ. ICAUS 
               END IF
               DO WHILE (  IREND.LT.(IBOFF+NEQSYM) .AND.
     &                     NSIMR.LT.NSIM  .AND. LTAKE ) 
                 IREND = IREND + 1
                 NSIMR = NSIMR + 1
                 IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
C                  LTAKE = .TRUE.
C                  DO IORD = 1, ORDER
C                    LTAKE = LTAKE .AND.
C    &                       (ICAU(IREND+1,IORD) .EQ. ICAU(IRST,IORD))
C                  END DO
                   ICAUS = 0
                   ICAUE = 0
                   DO IORD = 1, ORDER
                     ICAUS = ICAUS + ICAU(IRST,IORD)
                     ICAUE = ICAUE + ICAU(IREND+1,IORD)
                   END DO
                   LTAKE = ICAUE .EQ. ICAUS 
                 END IF
               END DO
           END DO
         END IF
*---------------------------------------------------------------------


C
         IF (LOCDBG ) THEN
            WRITE(LUPRI,*) '         '
            WRITE(LUPRI,*) 'CC_SOLRSP-1: NEQSYM = ',NEQSYM
            WRITE(LUPRI,*) 'CC_SOLRSP-1: IBOFF  = ',IBOFF
            WRITE(LUPRI,*) 'CC_SOLRSP-1: IBEND  = ',IBEND
            WRITE(LUPRI,*) 'CC_SOLRSP-1: NSIM   = ',NSIM
            WRITE(LUPRI,*) 'CC_SOLRSP-1: NBAT   = ',NBAT
         ENDIF
C
        IREND = IBOFF
        DO IRB = 1, NBAT
 
C----------------------------------------------------
C           Find start number for this batch on list.
C           and the number of equations.
C----------------------------------------------------

*..................................................................... 
*              special batching for excited state response vectors
*              and projected 1st-order Langrangian multipliers:
*..................................................................... 
            IF ( LIST(1:2).EQ.'ER' .OR. LIST(1:2).EQ.'EL'
     &                             .OR. LIST(1:3).EQ.'PL1' ) THEN
               IRST  = IREND+1
               NSIMR = 1
               IREND = IRST
               IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
                 LTAKE = ( ( ISTAT(IREND+1,1).EQ.ISTAT(IRST,1)
     &                        .AND. (LPROJ(IREND+1).EQV.LPROJ(IRST)) )
     &                    .OR. ((LPROJ(IREND+1).EQV..FALSE.)
     &                           .AND. (LPROJ(IRST).EQV..FALSE.)) ) 
               END IF
               DO WHILE (  IREND.LT.(IBOFF+NEQSYM) .AND.
     &                     NSIMR.LT.NSIM  .AND. LTAKE ) 
                 IREND = IREND + 1
                 NSIMR = NSIMR + 1
                 IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
                   LTAKE = ( ( ISTAT(IREND+1,1).EQ.ISTAT(IRST,1)
     &                          .AND. (LPROJ(IREND+1).EQV.LPROJ(IRST)))
     &                      .OR. ((LPROJ(IREND+1).EQV..FALSE.)
     &                             .AND. (LPROJ(IRST).EQV..FALSE.)) ) 
                 END IF
               END DO

*..................................................................... 
*              special batching for Cauchy equations:
*..................................................................... 
            ELSE IF ( (LIST(1:2).EQ.'RC' .AND. .NOT.NEWCAU)
     &                .OR. LIST(1:2).EQ.'LC'
     &                .OR. LIST(1:2).EQ.'CR'
     &                .OR. LIST(1:2).EQ.'CL'                 ) THEN
               IRST  = IREND+1
               NSIMR = 1
               IREND = IRST
               IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
C                LTAKE = .TRUE.
C                DO IORD = 1, ORDER
C                  LTAKE = LTAKE .AND.
C    &                     (ICAU(IREND+1,IORD) .EQ. ICAU(IRST,IORD))
C                END DO
                 ICAUS = 0
                 ICAUE = 0
                 DO IORD = 1, ORDER
                   ICAUS = ICAUS + ICAU(IRST,IORD)
                   ICAUE = ICAUE + ICAU(IREND+1,IORD)
                 END DO
                 LTAKE = ICAUE .EQ. ICAUS 
               END IF
               DO WHILE (  IREND.LT.(IBOFF+NEQSYM) .AND.
     &                     NSIMR.LT.NSIM  .AND. LTAKE ) 
                 IREND = IREND + 1
                 NSIMR = NSIMR + 1
                 IF ( IREND .LT. (IBOFF+NEQSYM) ) THEN
C                  LTAKE = .TRUE.
C                  DO IORD = 1, ORDER
C                    LTAKE = LTAKE .AND.
C    &                       (ICAU(IREND+1,IORD) .EQ. ICAU(IRST,IORD))
C                  END DO
                   ICAUS = 0
                   ICAUE = 0
                   DO IORD = 1, ORDER
                     ICAUS = ICAUS + ICAU(IRST,IORD)
                     ICAUE = ICAUE + ICAU(IREND+1,IORD)
                   END DO
                   LTAKE = ICAUE .EQ. ICAUS 
                 END IF
               END DO
    
               IF (CC3) THEN
                 IF (LOCDBG) THEN
                   WRITE(LUPRI,*) 'GET CAUCHY RHS VECTORS:' 
                   WRITE(LUPRI,*) 'VECTOR LIST :',LIST(1:3)
                   WRITE(LUPRI,*) 'CAUCHY ORDER:',ICAUS
                 END IF

                 IF (LIST(1:2).EQ.'RC') THEN
                    CALL CCRHSVEC('CO1',LABEL,
     &                            IDUMMY,IDUMMY,DUMMY,
     &                            ISYMO,DUMMY,LDUMMY,
     &                            ICAU,NSIMR,MAXVEC,IRST-1,
     &                            WORK,LWORK)
                 ELSE
                    CALL QUIT('Wrong Cauchy vector list in CC_SOLDRV.')
                 END IF

               END IF

               IF (LOCDBG) THEN
                 WRITE(LUPRI,*) 'SOLVE FOR CAUCHY VECTORS:' 
                 WRITE(LUPRI,*) 'VECTOR LIST :',LIST(1:3)
                 WRITE(LUPRI,*) 'CAUCHY ORDER:',ICAUS
               END IF

*..................................................................... 
*              standard batching for ground state response equations:
*..................................................................... 
            ELSE
               IRST  = IBOFF + (IRB-1)*NSIM + 1
               NSIMR = MIN(NSIM,NEQSYM - (IRB-1)*NSIM)
               IREND = IRST  + NSIMR - 1
            END IF
C
C
            IF (LOCDBG ) THEN
               WRITE(LUPRI,*) 'CC_SOLRSP-1: IRST   = ',IRST
               WRITE(LUPRI,*) 'CC_SOLRSP-1: IREND  = ',IREND
               WRITE(LUPRI,*) 'CC_SOLRSP-1: NSIMR  = ',NSIMR
            ENDIF
C
            IF (IPRINT.GT.2 .OR. LOCDBG) THEN
               WRITE (LUPRI,'(/,1X,A,I3,A)')
     &            'Solving ',NSIMR,' response equations:'
               DO IR = IRST, IREND
                 IF (LIST(1:1).EQ.'C' .OR. LIST(2:2).EQ.'C') THEN
                   WRITE (LUPRI,'(1X,2A,10(A8,I3,I3))') LIST,':',
     &               (LABEL(IR,I),ICAU(IR,I),ISYMO(IR,I),I=1,ORDER)
                 ELSE
                   WRITE (LUPRI,'(1X,2A,10(A8,F10.6,I3))') LIST,':',
     &               (LABEL(IR,I),FREQS(IR,I),ISYMO(IR,I),I=1,ORDER)
                 END IF
               END DO
            ENDIF
            IF (IPRINT.GT.10 .OR. LOCDBG)
     *            WRITE(LUPRI,*) 'CC_SOLRSP-1: Workspace:',LWORK
C
            CALL FLSHFO(LUPRI)
C
C------------------------------------------------------------------
C           Allocation of work space.
C           NB: The gradient vectors is not in memory at this time.
C------------------------------------------------------------------
C
            KIPLAC = 1
            KREDH  = KIPLAC + MAXRED
            KREDGD = KREDH  + MAXRED*MAXRED
            KEIVAL = KREDGD + MAXRED*NSIMR
            KSOLEQ = KEIVAL + MAXRED
            KWRK1  = KSOLEQ + MAXRED*MAXRED
            IF (LREDS) THEN
              KREDS = KWRK1 
              KWRK1 = KREDS + MAXRED*MAXRED
            END IF
            LWRK1  = LWORK  - KWRK1
C
            IF (LWRK1.LT. 0 )
     *         CALL QUIT(' TOO LITTLE WORKSPACE IN CC_SOLRSP')

C-------------------------------------------------------------------
C           Frequencies for diagonal scaling 
C-------------------------------------------------------------------
            IF (ISIDE.EQ.1) THEN
              SIGNF = ONE
            ELSE IF (ISIDE.EQ.-1) THEN
              SIGNF = -ONE
            END IF

            SIGNE = ONE
            IF (LIST(1:2).EQ.'M1' .OR. LIST(1:2).EQ.'N2') THEN
               SIGNE = -ONE
            END IF

            DO IFR = 1, NSIMR
               IR  = IRST + IFR - 1
               WORK(KEIVAL+IFR-1) = ZERO
               DO I = 1, NSTAT
                 WORK(KEIVAL+IFR-1) =
     &                 WORK(KEIVAL+IFR-1) + SIGNE * EIGVAL(IR,I)
               END DO
               IF ( LIST(1:1).NE.'C' .AND. LIST(2:2).NE.'C' ) THEN
                 DO I = 1, ORDER
                   WORK(KEIVAL+IFR-1) =
     &                   WORK(KEIVAL+IFR-1) + SIGNF * FREQS(IR,I)
                 END DO
               END IF
            END DO
C
C----------------------
C           Open files.
C----------------------
C
            CALL CC_FILOP(FRHO1,LUFR1,FRHO2,LUFR2,FRHO12,LUFR12,
     *                    FC1AM,LUFC1,FC2AM,LUFC2,FC12AM,LUFC12,
     *                    FS12AM,LUFS12)
C-------------------------------------------------------------------
C           check for projection: if we solve projected equations
C                                 set flat LPROJECT and store excited
C                                 state index in ISTATPRJ
C-------------------------------------------------------------------
            LPROJECT = .FALSE.
            ISTATPRJ = 0
            IF (LIST(1:2).EQ.'ER' .OR. LIST(1:2).EQ.'EL'
     &                             .OR. LIST(1:3).EQ.'PL1') THEN
              LPROJECT = LPROJ(IRST)
              ISTATPRJ = ISTAT(IRST,1)
              DO IDX = IRST+1,IRST+NSIMR-1
                IF ((LPROJ(IDX).NEQV.LPROJECT) .OR.
     &              (LPROJECT .AND. ISTAT(IDX,1).NE.ISTATPRJ) )
     &           CALL QUIT(
     &           'Error in batching for ERn/ELn/PL1 equations.')
              END DO
            END IF
 
C--------------------------------
C           Create start vectors.
C--------------------------------
C
            CALL CCEQ_STR(FC1AM,LUFC1,FC2AM,LUFC2,FC12AM,LUFC12,
     *                    LPROJECT,ISTATPRJ,
     *                    TRIPLET,ISIDE,IRST,NSIMR,NUPVEC,
     *                    NREDH,WORK(KEIVAL),WORK(KIPLAC),
     *                    WORK(KWRK1),LWRK1,LIST)
C
            CALL FLSHFO(LUPRI)
C
C---------------------------------------------
C           Solve equations by call to solver.
C---------------------------------------------
C
            IF (LINQCC .AND. CCSDT) ECURR = WORK(KEIVAL)
C
            CALL CCEQ_SOL(LIST,LPROJECT,ISTATPRJ,ECURR,
     *                    FRHO1,LUFR1,FRHO2,LUFR2,FRHO12,LUFR12,
     *                    FC1AM,LUFC1,FC2AM,LUFC2,FC12AM,LUFC12,
     *                    LREDS,WORK(KREDS),FS12AM,LUFS12,
     *                    LINQCC,TRIPLET,ISIDE,IRST,NSIMR,NUPVEC,
     *                    NREDH,WORK(KREDH),WORK(KEIVAL),
     *                    WORK(KSOLEQ),WORK(KWRK1),LWRK1)
C
            IF (LINQCC .AND. CCSDT) ECURR = 0.0D0
C
C---------------------------------------------------------
C           Analysis of solution vectors and save on disk.
C---------------------------------------------------------
C
           NVARPT = LETOT + 2*NALLAI(ISYM)
           KWRK2  = KWRK1 + NVARPT
           LWRK2  = LWORK - KWRK2
           NSIMUL = MIN(NSIMR,LWRK2/LETOT )
           NBATCH = (NSIMR -1)/NSIMUL + 1
           IOFF1  = 1
           ICOUNT = 0
           ILSTNR = IRST
C
           DO I = 1,NBATCH
              IOFF2 = MIN(NSIMUL,NSIMR  - (I-1)*NSIMUL)
              CALL CCCONV(LUFC1,FC1AM,LUFC2,FC2AM,LUFC12,FC12AM,
     *                    TRIPLET,CCR12,NREDH,IOFF1,IOFF2,WORK(KSOLEQ),
     *                    WORK(KWRK2),WORK(KWRK1))
              IF (DEBUG) THEN
                 WRITE(LUPRI,*) 'After CCCONV '
                 WRITE(LUPRI,*) 'IOFF1,IOFF2,NREDH',IOFF1,IOFF2,NREDH
                 WRITE(LUPRI,*) 'KWRK1,KWRK2',KWRK1,KWRK2
                 WRITE(LUPRI,*) 'LWRK1,LWRK2',LWRK1,LWRK2
                 X1  = DDOT(LETOT,WORK(KWRK1),1,WORK(KWRK1),1)
                 WRITE(LUPRI,*) 'norm KWRK1:',X1
                 X2  = DDOT(LETOT,WORK(KWRK2),1,WORK(KWRK2),1)
                 WRITE(LUPRI,*) 'norm KWRK2:',X2
              ENDIF
C
              IF ( IPRINT .GT. 30 ) THEN
                 CALL AROUND('CC_SOLRSP: response vectors in mo basis')
                 CALL OUTPUT(WORK(KWRK2),1,NCCVAR,1,IOFF2,
     *                       NCCVAR,IOFF2,1,LUPRI)
              ENDIF
C
              DO J = 1,IOFF2
                 ICOUNT = ICOUNT + 1
C
                 KT1 = KWRK2 + (ICOUNT-1)*LETOT
                 KT2 = KT1 + NT1AM(ISYM)
                 IF (IPRINT .GT. 1) THEN
                    WRITE(LUPRI,'(//1X,A)')
     *         'Analysis of CC Response/Cauchy vector:'
                    WRITE(LUPRI,'(1X,A)')
     *         '--------------------------------------'
C
                    CALL CC_PRAM(WORK(KWRK2 + (ICOUNT-1)*LETOT),
     *                           PT1,ISYM)
                    IF ((IPRINT.GT.10).OR.DEBUG) THEN
                      RHO1N = DDOT(NT1AM(ISYM),WORK(KT1),1,WORK(KT1),1)
                      WRITE(LUPRI,'(1X,A35,1X,E20.10)')
     *               'Norm of singles part:   ',RHO1N
                      IF ( .NOT. CCS) THEN
                       RHO2N=DDOT(NT2AM(ISYM),WORK(KT2),1,WORK(KT2),1)
                       WRITE(LUPRI,'(1X,A35,1X,E20.10)')
     *                 'Norm of doubles part:   ',RHO2N
                      ENDIF
                    ENDIF
                 ENDIF
C
C----------------------------------------------
C                Save response vectors on file.
C----------------------------------------------
C
                 KT1    = KWRK2 + (ICOUNT-1)*LETOT
                 KT2    = KT1 + NT1AM(ISYMTR)

                 IF (CCSTST) THEN
                   CALL DZERO(WORK(KT2),NT2AM(ISYMTR))
                 END IF

                 IOPT   = 3
                 CALL CC_WRRSP(LIST,ILSTNR,ISYM,IOPT,MODEL,DUMMY,
     *                  WORK(KT1),WORK(KT2),WORK(KWRK1),NVARPT)
                 IF (CCR12) THEN 
                   IOPT = 32
                   KT12 = KT2 + NT2AM(ISYMTR)
                   CALL CC_WRRSP(LIST,ILSTNR,ISYM,IOPT,MODEL,DUMMY,
     *                    DUMMY,WORK(KT12),WORK(KWRK1),NVARPT)
                 END IF
                 ILSTNR = ILSTNR + 1
C
              END DO
              IOFF1 = IOFF1 + NSIMUL
           END DO
C
C---------------------------------
C          Close and delete files.
C---------------------------------
C
           CALL CC_FILCL(FRHO1,LUFR1,FRHO2,LUFR2,FRHO12,LUFR12,
     *                   FC1AM,LUFC1,FC2AM,LUFC2,FC12AM,LUFC12,
     *                   FS12AM,LUFS12)
C
         END DO


      ELSE
        WRITE(LUPRI,*) 'There are no amplitudes of symmetry ',ISYM,'!'
      ENDIF
C
      END DO

C---------------------------------------------------------------------
C     For CC3 restore NSIMLE
C---------------------------------------------------------------------
      IF (CCSDT) NSIMLE = NSIMLEBAK

C-------------------------------------------------------------
C     finished
C-------------------------------------------------------------
      CALL QEXIT('CC_SOLDRV')
      RETURN
      END
C--------------------------------------------------------------------
C  /* Deck cc_getvec */
      SUBROUTINE CC_GETVEC(LUC1,FC1AM,LUC2,FC2AM,LUC12,FC12AM,
     *                     TRIPLET,IVEC,VEC)
C
C     Ove Christiansen 5-11-1996:
C
C     Get vector nr. IVEC from files 
C            FC1AM  (LUC1)  singles part
C            FC2AM  (LUC2)  doubles part
C            FC12AM (LUC12) R12 doubles part
C
      IMPLICIT NONE
C#include <implicit.h>
C#include <priunit.h>
C#include <iratdef.h>
#include <cclr.h>
#include <ccsdinp.h>
#include <ccsdsym.h>

#if defined (SYS_CRAY)
      REAL VEC(*)
#else
      DOUBLE PRECISION VEC(*)
#endif

      LOGICAL TRIPLET
      CHARACTER FC1AM*(*), FC2AM*(*), FC12AM*(*)
      INTEGER LUC1, LUC2, LUC12, IVEC, NT2VAR, NT12VAR, IADR
C
      CALL CC_RVEC(LUC1,FC1AM,NT1AM(ISYMTR),NT1AM(ISYMTR),IVEC,VEC(1))
      IF (.NOT. CCS) THEN
         IF (TRIPLET) THEN
            NT2VAR = NT2AMT(ISYMTR)
         ELSE
            NT2VAR = NT2AM(ISYMTR)
         END IF                          
         IADR = 1 + NT1AM(ISYMTR)
         CALL CC_RVEC(LUC2,FC2AM,NT2VAR,NT2VAR,IVEC,VEC(IADR))
         IF (CCR12) THEN
            NT12VAR = NGAMMA(ISYMTR)
            IADR    = 1 + NT1AM(ISYMTR) + NT2VAR
            CALL CC_RVEC(LUC12,FC12AM,NT12VAR,NT12VAR,IVEC,VEC(IADR))
         END IF
         IF (CCSTST) 
     *     CALL DZERO(VEC(1+NT1AM(ISYMTR)),NCCVAR-NT1AM(ISYMTR))
      ENDIF

      RETURN
      END
C  /* Deck cc_putvec */
      SUBROUTINE CC_PUTVEC(LUC1,FC1AM,LUC2,FC2AM,LUC12,FC12AM,
     *                     TRIPLET,IVEC,VEC)
C
C     Ove Christiansen 22-1-1996:
C
C            put vector nr. IVEC to 
C                singles file (name: FC1AM,  nr: LUC1)
C                doubles file (name: FC2AM,  nr: LUC2)
C            R12 doubles file (name: FC12AM, nr: LUC12)
C
      IMPLICIT NONE
C#include <implicit.h>
C#include <priunit.h>
C#include <iratdef.h>
#include <cclr.h>
#include <ccsdinp.h>
#include <ccsdsym.h>

#if defined (SYS_CRAY)
      REAL VEC(*)
#else
      DOUBLE PRECISION VEC(*)
#endif

      LOGICAL TRIPLET
      CHARACTER FC1AM*(*),FC2AM*(*),FC12AM
      INTEGER LUC1, LUC2, LUC12, IVEC, NT2VAR, NT12VAR, IADR
C
      CALL CC_WVEC(LUC1,FC1AM,NT1AM(ISYMTR),NT1AM(ISYMTR),
     *             IVEC,VEC(1))
      IF ( .NOT. CCS) THEN
         IF (CCSTST) 
     *     CALL DZERO(VEC(1+NT1AM(ISYMTR)),NCCVAR-NT1AM(ISYMTR))
         IF (TRIPLET) THEN
            NT2VAR = NT2AMT(ISYMTR)
         ELSE
            NT2VAR = NT2AM(ISYMTR)
         END IF                              
         IADR = 1 + NT1AM(ISYMTR)
         CALL CC_WVEC(LUC2,FC2AM,NT2VAR,NT2VAR,IVEC,VEC(IADR))
         IF (CCR12) THEN
            NT12VAR = NGAMMA(ISYMTR)
            IADR    = 1 + NT1AM(ISYMTR) + NT2VAR
            CALL CC_WVEC(LUC12,FC12AM,NT12VAR,NT12VAR,IVEC,VEC(IADR))
         END IF
      ENDIF
C
      RETURN
      END
C  /* Deck cc_filop  */
      SUBROUTINE CC_FILOP(FRHO1,LUFR1,FRHO2,LUFR2,FRHO12,LUFR12,
     *                    FC1AM,LUFC1,FC2AM,LUFC2,FC12AM,LUFC12,
     *                    FS12AM,LUFS12)
C
C     Ove Christiansen 22-1-1996:
C                Open files for linear solver.
C                Has to be 8 character long.
C
#include <implicit.h>
#include <iratdef.h>
#include <ccsdinp.h>
      CHARACTER*8 FRHO1,FRHO2,FC1AM,FC2AM,FRHO12,FC12AM,FS12AM
C
      CALL WOPEN2(LUFC1,FC1AM,64,0)
      CALL WOPEN2(LUFR1,FRHO1,64,0)
C
      IF ( .NOT. CCS ) THEN
         CALL WOPEN2(LUFC2,FC2AM,64,0)
         CALL WOPEN2(LUFR2,FRHO2,64,0)
      ENDIF
C
      IF ( CCR12 ) THEN
         CALL WOPEN2(LUFR12,FRHO12,64,0)
         CALL WOPEN2(LUFC12,FC12AM,64,0)
         CALL WOPEN2(LUFS12,FS12AM,64,0)
      END IF
C
      END
C  /* Deck cc_filcl  */
      SUBROUTINE CC_FILCL(FRHO1,LUFR1,FRHO2,LUFR2,FRHO12,LUFR12,
     *                    FC1AM,LUFC1,FC2AM,LUFC2,FC12AM,LUFC12,
     *                    FS12AM,LUFS12)
C
C     Ove Christiansen 22-1-1996:
C
#include <implicit.h>
#include <iratdef.h>
#include <ccsdinp.h>
C
      CHARACTER*8 FRHO1,FRHO2,FC1AM,FC2AM,FRHO12,FC12AM,FS12AM
C
C-----------------
C     Close files.
C-----------------
C
      CALL WCLOSE2(LUFC1,FC1AM,'DELETE')
      CALL WCLOSE2(LUFR1,FRHO1,'DELETE')
C
      IF ( .NOT. CCS) THEN
         IF (LUFC2 .GT. 0) CALL WCLOSE2(LUFC2,FC2AM,'DELETE')
         IF (LUFR2 .GT. 0) CALL WCLOSE2(LUFR2,FRHO2,'DELETE')
      ENDIF
C
      IF ( CCR12 ) THEN
         CALL WCLOSE2(LUFR12,FRHO12,'DELETE')
         CALL WCLOSE2(LUFC12,FC12AM,'DELETE')
         CALL WCLOSE2(LUFS12,FS12AM,'DELETE')
      END IF
C
      END
C--------------------------------------------------------------------
